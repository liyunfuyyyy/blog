---
title: 常用算法
date: 2022-03-14 18:17:13
categories: 知识点
tags: ['算法','数据结构']
---

## 题目1 - 将一个数组旋转k步

- 输入数组[1,2,3,4,5,6,7]
- k=3，即旋转3步
- 输出[5,6,7,1,2,3,4]

```tsx
const arr = [1, 2, 3, 4, 5, 6, 7]
function rotate2(arr, k) {
  const length = arr.length
  if (!k || length === 0) return arr
  const step = Math.abs(k % length)   // abs 取绝对值

  const part1 = arr.slice(-step)
  const part2 = arr.slice(0, length - step)
  const part3 = [...part1, ...part2]
  return part3
}

const arr2 = rotate2(arr, 3)
console.log(arr2)
```



## 题目2 - 快速排序

- 用JavaScript 实现快速排序，并说明时间复杂度



## 题目3 - 判断字符串是否括号匹配

- 一个字符串s可能包括{} () []三种括号
- 判断s是否是括号匹配
- 如(a{b}c)匹配，而{a(b]c)}就不匹配

```tsx
function isMatch(left, right) {
  if (left === '[' && right == ']') return true
  if (left === '{' && right == '}') return true
  if (left === '(' && right == ')') return true
  return false
}
function matchBracket(str) {
  const length = str.length
  if (length === 0) return true

  const stack = []

  const leftSymbols = '{[('
  const rightSymbols = '}])'

  for (let i = 0; i < length; i++) {
    const s = str[i]
    if (leftSymbols.includes(s)) {
      // 左括号
      stack.push(s)
    } else if (rightSymbols.includes(s)) {
      // 右括号，判断栈顶
      console.log('右括号' + s)
      const top = stack[stack.length - 1]
      if (isMatch(top, s)) {
        stack.pop()
      } else {
        return false
      }
    }
  }
  return stack.length === 0
}

const str = '{a(b[c])}'
console.log(matchBracket(str))
```

## 题目4 - 反转单向链表

- 输入一个单向链表，输出它的反转(头变尾，尾变头)

```tsx
interface ILinkListNode {
  value: number,
  next?: ILinkListNode
}
 // 反转链表
function reverseLinkList(listNode: ILinkListNode): ILinkListNode {
  // 定义三个指针
  let prevNode: ILinkListNode | undefined = undefined
  let curNode: ILinkListNode | undefined = undefined
  let nextNode: ILinkListNode | undefined = listNode

  // 以nextNode为主 遍历链表
  while (nextNode) {
    // 第一个元素 删掉next 防止循环引用
    if (curNode && !prevNode) {
      delete curNode.next
    }

    // 反转指针
    if (curNode && prevNode) {
      curNode.next = prevNode
    }

    // 整体向后移动
    prevNode = curNode
    curNode = nextNode
    nextNode = nextNode?.next
  }

  // 当nextNode空时
  curNode!.next = prevNode

  return curNode
}
  // 创建链表
function createLinkList(arr: number[]): ILinkListNode {
  const length = arr.length
  if (length === 0) throw new Error('arr is empty')

  let curNode: ILinkListNode = {
    value: arr[length - 1]
  }
  for (let i = length - 2; i >= 0; i--) {
    curNode = {
      value: arr[i],
      next: curNode
    }
  }

  return curNode
}

const arr = [100, 200, 300, 400, 500]
const list = createLinkList(arr)
console.log(list)

const list1 = reverseLinkList(list)
console.log(list1)
```

## 题目5 - 用链表实现队列

```tsx
interface ILinkListNode {
  value: number,
  next?: ILinkListNode
}

class MyQueue {
  private head: ILinkListNode | null = null
  private tail: ILinkListNode | null = null
  private len = 0
  // 入队 在tail位置
  add(n: number) {
    const newNode: ILinkListNode = {
      value: n,
      next: null
    }
    // 处理head
    if (this.head === null) {
      this.head = newNode
    }

    // 处理tail
    const tailNode = this.tail
    if (tailNode) {
      tailNode.next = newNode
    }
    this.tail = newNode

    // 记录长度
    this.len++
  }
  // 出队 在head位置
  delete(): number | null {
    const headNode = this.head
    if (headNode == null) return null
    if (this.len <= 0) return null

    // 取值
    const value = headNode.value

    //处理head
    this.head = headNode.next

    // 记录长度
    this.len--

    return value
  }
  get length(): number {
    // length要单独存储 不能遍历链表来存取 
    return this.len
  }
}

const q = new MyQueue()

q.add(100)
q.add(200)
q.add(300)
console.log('length1', q.length)
console.log(q.delete())
```



## 题目6 - 用两个栈实现一个队列

```tsx
class MyQueue {
  private stack1: number[] = []
  private stack2: number[] = []

  /**
   * 入队
   */
  add(n: number) {
    this.stack1.push(n)
  }

  /**
   * 出队
   */
  delete(): number | null {
    let res

    const stack1 = this.stack1
    const stack2 = this.stack2

    // 将stack1 所有元素移动到stack2中
    while (stack1.length) {
      const n = stack1.pop()
      if (n != null) {
        stack2.push(n)
      }
    }

    // stack2 pop
    res = stack2.pop()

    // 将stack2所有元素还给stack1
    while (stack2.length) {
      const n = stack2.pop()
      if (n != null) {
        stack1.push(n)
      }
    }
    return res || null
  }
  get length(): number {
    return this.stack1.length
  }
}
```

