---
title: 常用算法
date: 2022-03-14 18:17:13
categories: 知识点
tags: ['算法','数据结构']
---

### 题目1 - 将一个数组旋转k步

- 输入数组[1,2,3,4,5,6,7]
- k=3,即旋转3步

- 输出[5,6,7,1,2,3,4]

```javascript
const arr = [1, 2, 3, 4, 5, 6, 7]
function rotate2(arr, k) {
  const length = arr.length
  if (!k || length === 0) return arr
  const step = Math.abs(k % length)   // abs 取绝对值

  const part1 = arr.slice(-step)
  const part2 = arr.slice(0, length - step)
  const part3 = [...part1, ...part2]
  return part3
}

const arr2 = rotate2(arr, 3)
console.log(arr2)
```



### 题目2 - 快速排序

- 用JavaScipt 实现快速排序，并说明时间复杂度
- 找到中间位置midValue

- 遍历数组，小于midValue放在left，否则放在right
- 继续递归，最后concat拼接，返回

```typescript
function quickSort(arr:number[]):number[]{
  const length=arr.length
  if(length===0)return arr
  
  const midIndex=Math.floor(length/2)
  const midValue=arr.slice(midIndex,midIndex+1)[0]
  
  const left:number[]=[]
  const right:number[]=[]
  
  for(let i=0;i<length;i++){
    if(i!==midIndex){
      const n=arr[i]
      if(n<midValue){
        // 小于midValue 则放在left
        left.push(n)
      }else{
        // 大于 midValue 则放在right
        right.push(n)
      }
    }
  }
  
  return quickSort(left).concat([midValue],quickSort(right))
}

const arr=[1,6,2,7,3,8,4,9,5]
console.log(quickSort(arr))
```



### 题目3 - 判断字符串是否括号匹配

- 一个字符串s可能包含{} () [] 三种括号
- 判断s是否是括号匹配的

- 如(a{b}c)匹配，而{a(b或{a(b}c) 就不匹配

```javascript
function isMatch(left, right) {
  if (left === '[' && right == ']') return true
  if (left === '{' && right == '}') return true
  if (left === '(' && right == ')') return true
  return false
}
function matchBracket(str) {
  const length = str.length
  if (length === 0) return true

  const stack = []

  const leftSymbols = '{[('
  const rightSymbols = '}])'

  for (let i = 0; i < length; i++) {
    const s = str[i]
    if (leftSymbols.includes(s)) {
      // 左括号
      stack.push(s)
    } else if (rightSymbols.includes(s)) {
      // 右括号，判断栈顶
      console.log('右括号' + s)
      const top = stack[stack.length - 1]
      if (isMatch(top, s)) {
        stack.pop()
      } else {
        return false
      }
    }
  }
  return stack.length === 0
}

const str = '{a(b[c])}'
console.log(matchBracket(str))
```



### 题目4 - 反转单向链表

- 输入一个单向链表，输出它的反转(头变尾，尾变头)

```javascript
interface ILinkListNode {
  value: number,
  next?: ILinkListNode
}
 // 反转链表
function reverseLinkList(listNode: ILinkListNode): ILinkListNode {
  // 定义三个指针
  let prevNode: ILinkListNode | undefined = undefined
  let curNode: ILinkListNode | undefined = undefined
  let nextNode: ILinkListNode | undefined = listNode

  // 以nextNode为主 遍历链表
  while (nextNode) {
    // 第一个元素 删掉next 防止循环引用
    if (curNode && !prevNode) {
      delete curNode.next
    }

    // 反转指针
    if (curNode && prevNode) {
      curNode.next = prevNode
    }

    // 整体向后移动
    prevNode = curNode
    curNode = nextNode
    nextNode = nextNode?.next
  }

  // 当nextNode空时
  curNode!.next = prevNode

  return curNode
}
  // 创建链表
function createLinkList(arr: number[]): ILinkListNode {
  const length = arr.length
  if (length === 0) throw new Error('arr is empty')

  let curNode: ILinkListNode = {
    value: arr[length - 1]
  }
  for (let i = length - 2; i >= 0; i--) {
    curNode = {
      value: arr[i],
      next: curNode
    }
  }

  return curNode
}

const arr = [100, 200, 300, 400, 500]
const list = createLinkList(arr)
console.log(list)

const list1 = reverseLinkList(list)
console.log(list1)
```



### 题目5 - 用链表实现队列

```typescript
interface ILinkListNode {
  value: number,
  next?: ILinkListNode
}

class MyQueue {
  private head: ILinkListNode | null = null
  private tail: ILinkListNode | null = null
  private len = 0
  // 入队 在tail位置
  add(n: number) {
    const newNode: ILinkListNode = {
      value: n,
      next: null
    }
    // 处理head
    if (this.head === null) {
      this.head = newNode
    }

    // 处理tail
    const tailNode = this.tail
    if (tailNode) {
      tailNode.next = newNode
    }
    this.tail = newNode

    // 记录长度
    this.len++
  }
  // 出队 在head位置
  delete(): number | null {
    const headNode = this.head
    if (headNode == null) return null
    if (this.len <= 0) return null

    // 取值
    const value = headNode.value

    //处理head
    this.head = headNode.next

    // 记录长度
    this.len--

    return value
  }
  get length(): number {
    // length要单独存储 不能遍历链表来存取 
    return this.len
  }
}

const q = new MyQueue()

q.add(100)
q.add(200)
q.add(300)
console.log('length1', q.length)
console.log(q.delete())
```



### 题目6 - 用两个栈实现一个队列

```typescript
class MyQueue {
  private stack1: number[] = []
  private stack2: number[] = []

  /**
   * 入队
   */
  add(n: number) {
    this.stack1.push(n)
  }

  /**
   * 出队
   */
  delete(): number | null {
    let res

    const stack1 = this.stack1
    const stack2 = this.stack2

    // 将stack1 所有元素移动到stack2中
    while (stack1.length) {
      const n = stack1.pop()
      if (n != null) {
        stack2.push(n)
      }
    }

    // stack2 pop
    res = stack2.pop()

    // 将stack2所有元素还给stack1
    while (stack2.length) {
      const n = stack2.pop()
      if (n != null) {
        stack1.push(n)
      }
    }
    return res || null
  }
  get length(): number {
    return this.stack1.length
  }
}
```



### 题目7 - 用JS实现二分查找

- 递归 - 代码逻辑更加清晰
- 非递归 - 性能更好

- 时间复杂度O(logn)
- 循环查找

- 凡有序必二分，凡二分，时间复杂度必包含O(logn)

```typescript
function binarySearch1(arr: number[], target: number): number {
  const length = arr.length
  if (length === 0) return -1

  let startIndex = 0  // 开始位置
  let endIndex = length - 1  // 结束位置

  while (startIndex <= endIndex) {
    const midIndex = Math.floor((startIndex + endIndex) / 2)
    const midValue = arr[midIndex]
    if (target < midValue) {
      // 目标值较小 则继续在左侧查找
      endIndex = midIndex - 1
    } else if (target > midValue) {
      // 目标值较大，则继续在右侧查找
      startIndex = midIndex + 1
    } else {
      // 相等 返回
      return midIndex
    }
  }
  return -1
}

// 功能测试
const nums = [10, 20, 30, 40, 50, 60]
console.log(binarySearch1(nums, 50))
```

- 递归查找

```typescript
function binarySearch2(arr: number[], target: number, startIndex?: number, endIndex?: number) {
  const length = arr.length
  if (length === 0) return -1

  // 开始和结束的范围
  if (startIndex == null) startIndex = 0
  if (endIndex == null) endIndex = length - 1

  // 如果start 和 end相遇，则结束
  if (startIndex > endIndex) return -1

  // 中间位置
  const midIndex = Math.floor((startIndex + endIndex) / 2)
  const midValue = arr[midIndex]

  if (target < midValue) {
    // 目标值较小 则继续在左侧查找
    return binarySearch2(arr, target, startIndex, midIndex - 1)
  } else if (target > midValue) {
    // 目标值较大 则继续在右侧查找
    return binarySearch2(arr, target, midIndex + 1, endIndex)
  } else {
    // 相等 返回
    return midIndex
  }
}
```



### 题目8 - 给一个数组，找出其中和为n的两个元素

- 有一个递增的数组[1,2,4,7,11,15] 和一个n=15
- 数组中有两个数，和是n，即4+11===15

```typescript
function findTowNumber(arr: number[], n: number): number[] {
  const res: number[] = []

  const length = arr.length

  let i = 0  // 头
  let j = length - 1  //尾

  while (i < j) {
    const n1 = arr[i]
    const n2 = arr[j]
    const sum = n1 + n2

    if (sum > n) {
      // sum大于n 则j要向前移动
      j--
    } else if (sum < n) {
      // sum小于n 则i要向后移动
      i++
    } else {
      // 相等
      res.push(n1)
      res.push(n2)
      break
    }
  }
  return res
}

const nums = [1, 2, 4, 7, 11, 15]
console.info(findTowNumber(nums, 15))
```



### 题目9 - 求二叉搜索树的第k小值

![img](https://cdn.nlark.com/yuque/0/2022/png/1356933/1647328406540-1455e742-a6eb-4e14-bd9f-07323a8426d9.png)

- 二叉搜索树BST即左边小于根，右边大于根

```typescript
interface ITreeNode {
  value: number
  left: ITreeNode | null
  right: ITreeNode | null
}

const arr: number[] = []
function preOrderTraverse(node: ITreeNode) {
  if (node == null) return
  // console.log(node.value)
  arr.push(node.value)
  preOrderTraverse(node.left)
  preOrderTraverse(node.right)
}

function inOrderTraverse(node: ITreeNode | null) {
  if (node == null) return
  inOrderTraverse(node.left)
  // console.log(node.value)
  arr.push(node.value)
  inOrderTraverse(node.right)
}

function postOrderTraverse(node: ITreeNode | null) {
  if (node == null) return
  postOrderTraverse(node.left)
  postOrderTraverse(node.right)
  // console.log(node.value)
  arr.push(node.value)
}

function getKthValue(node: ITreeNode, k: number): number | null {
  inOrderTraverse(node)
  console.log(arr)

  return arr[k - 1] | null
}
const tree: ITreeNode = {
  value: 5,
  left: {
    value: 3,
    left: {
      value: 2,
      left: null,
      right: null
    },
    right: {
      value: 4,
      left: null,
      right: null
    }
  },
  right: {
    value: 7,
    left: {
      value: 6,
      left: null,
      right: null
    },
    right: {
      value: 8,
      left: null,
      right: null
    }
  }
}

console.log(getKthValue(tree, 3))
```



### 题目10 - 求斐波那契数列的弟n值

- 用JS计算斐波那契数列的第n个值
- 注意时间复杂度

```typescript
function fibonacci(n:number):number{
  if(n<=0) return 0
  if(n===1)return 1
  
  let n1=0
  let n2=1
  let res=0
  
  for(let i=2;i<=n;i++){
    res=n1+n2
    
    n1=n2
    n2=res
  }
  return res
}

console.log(fibonacci(3))
```



### 题目11 - 青蛙跳台阶

- 一只青蛙，一次可跳1级，也可跳2级
- 问：青蛙跳到n级台阶，总共有多少种方式

```javascript
var numWays = function(n) {
    if(n<=0)return 1
    if(n===1) return 1
    
    let n1=1
    let n2=1
    let res=0

    for(let i=2;i<=n;i++){
        res=(n1+n2)%(1e9+7)
        n1=n2
        n2=res
    }
    return res
};
```



### 题目12 - 将数组中的0移动到末尾

- 如输入[1,0,3,0,11,0] ， 输出[1,3,11,0,0,0]
- 只移动0，其他顺序不变

- 必须在原数组进行操作

```typescript
function moveZero(arr:number[]):void{
  const length=arr.length
  if(length===0) return
  
  let i
  j=-1  //指向第一个0
  for(i=0;i<length;i++){
    if(arr[i]===0){
      // 第一个0
      if(j<0){
        j=i
      }
    }
    if(arr[i]!==0&&j>=0){
      const n=arr[i]
      arr[i]=arr[j]
      arr[j]=n
      
      j++
    }
  }
}

const arr=[1,0,1,1,4,5,0,1,0,0,0,1,2]
moveZero(arr)
console.log(arr)
```



### 题目13 - 求字符串中连续最多的字符，以及次数

- 如，输入'abbccddeeee1234' ,计算得出
- 连续最多的字符是'e' 4次

**双指针**

- 定义指针`i`和`j`，`j`不动，`i`继续移动
- 如果`i`和 `j`的值一直相等，则`i`继续移动

- 直到`i`和`j`的值不相等，记录处理，让`j`追上`i`，继续第一步

```typescript
function findContinuousChar(str:string):IRes{
  const res:IRes={
    char:'',
    length:0
  }
  
  const length=str.length
  if(length===0)return res
  
  let tempLength=0  // 临时记录当前连续字符的长度
  let i=0
  let j=0
  
  for(;i<length;i++){
    if(str[i]===str[j]){
      tempLength++
    }
    
    if(str[i]!==str[j]||i===length-1){
      // 不相等 或者i到了字符串的末尾
      if(tempLength>res.length){
        res.char=str[j]
        res.length=tempLength
      }
      tempLength=0  //reset
      
      if(i<length-1){
        j=i  //让j追上 i
        i-- // 细节
      }
    }
  }
  
  return res
}

console.log(findContinuousChar("abaabbbbccddee"))
```



### 题目14 - 获取1-10000之前所有的对称数(回文数)

```javascript
function findPalindromeNumber(max:number):number[]{
  const res:number[]=[]
  if(max<=0)return res
  
  for(let i=1;i<=max;i++){
    let n=i
    let rev=0  //存储反转数
    
    // 生成反转数
    while(n>0){
      rev=rev*10+n%10
      n=Math.floor(n/10)
    }
    if(i===rev)res.push(i)
  }
  return res
}

console.log(findPalindromeNumber(200))

/*
[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]
*/
```



### 题目15 - 高效的英文单词前缀匹配

- 有一个英文单词库（数组），里面有几十万个英文单词
- 输入一个字符串，快速判断是不是某一个单词的前缀

- （说明思路，不用写代码）

**实现方法**

1. 将二十六个字母拆分匹配成一个26叉树  -  这一步很长时间才更新一次，不算进算法中
2. 使用hash key查找即可，例如`str.a.c.b.c.d`

1. 有明确范围的数据(如26个英文字母)，考虑使用哈希表(对象)



### 题目16 - 数字千分位格式化

- 将数字千分位格式化，输出字符串
- 如输入数字12050100，输出字符串12，050，100

- （注意：逆序判断）

**常见思路**

- 使用数组

```typescript
function format(n: number): string {
    n = Math.floor(n) // 只考虑整数

    const s = n.toString()
    const arr = s.split('').reverse()
    return arr.reduce((prev, val, index) => {
        if (index % 3 === 0) {
            if (prev) {
                return val + ',' + prev
            } else {
                return val
            }
        } else {
            return val + prev
        }
    }, '')
}
```

- 使用字符串（推荐）

```typescript
function format(n: number): string {
    n = Math.floor(n) // 只考虑整数

    let res = ''
    const s = n.toString()
    const length = s.length

    for (let i = length - 1; i >= 0; i--) {
        const j = length - i
        if (j % 3 === 0) {
            if (i === 0) {
                res = s[i] + res
            } else {
                res = ',' + s[i] + res
            }
        } else {
            res = s[i] + res
        }
    }

    return res
}
```



### 题目17 - 切换字母大小写

- 输入一个字符串，切换其中字母的大小写
- 如，输入字符串12bBc34，输出字符串12AbC34

**常见思路**

- 正则表达式
- ASCII表

```typescript
function switchLetterCase(s:string):string{
  const res=''
  
  const length=s.length
  if(length===0)return res
  
  for(let i=0;i<length;i++){
    const c=s[i]
    const code=c.charCodeAt(0)
    
    if(code>=65&&code<=90){
      res+=c.toLowerCase()
    }else if(code>=97&&code<=122){
      res+=c.toUpperCase()
    }else{
      res+=c
    }
  }
  
  return res
}

console.log(switchLetterCase('12bBc34'))
```



### 题目18 - 为什么0.1+0.2!==0.3

**计算机使用二进制存储数据**

- 整数转换二进制没有误差，如9转换为二进制是1001
- 而小数可能无法用二进制准确表达，如0.2转换为0.20000001

- 可以用`math.js`库



## 持续更新中……
