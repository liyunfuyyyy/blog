---
title: 常见面试题
date: 2022-04-10 20:13:17
tags: 面试
categories: 知识点
---



## 1. 为什么 0.1+0.2!==0.3

**计算机使用二进制存储数据**

- 整数转换二进制没有误差，如 9 转换为二进制是 1001
- 而小数可能无法用二进制准确表达，如 0.2 转换为 0.20000001
- 可以用`math.js` 库解决

## 2. Ajax-Fetch-Axios 三者有什么区别

**三者都用于网络请求，但是不同维度**

- Ajax 是一种技术统称
- Fetch 是一个具体的 API，支持 Promise
- Axios 是第三方库
- **lib 和 API 的区别**

```ts
function ajax(url, successFn) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url, false);
  xhr.onreadystateChange = function () {
    // 这里的函数异步执行
    if (xhr.readyState == 4) {
      if (xhr.status == 200) {
        successFn(xhr.responseText);
      }
    }
  };
  xhr.send(null);
}
function ajax(url) {
  return fetch(url).then((res) => res.json);
}
```

## 3. 节流和防抖

- 节流：限制执行频率，有节奏的执行
- 防抖：限制执行次数，多次密集的触发只触发一次
- 节流关注`过程` ，防抖关注`结果`
- 实际工作中可用`lodash`

**防抖** 输入框

```ts
function debounce(fn, delay = 200) {
  let timer = 0;

  return function () {
    if (timer) clearTimeout(timer);

    timer = setTimeout(() => {
      fn.apply(this, arguments); // 透传this和参数
      timer = 0;
    }, delay);
  };
}
```

**节流** banner，拖拽

```ts
function throttle(fn, delay = 100) {
  let timer = 0;

  return function () {
    if (timer) return;

    timer = setTimeout(() => {
      fn.apply(this, arguments);
      timer = 0;
    }, delay);
  };
}
```

## 4. px % em rem vw vh 有什么区别

- `px` 基本单位，绝对单位(其他都是相对单位)
- `%` 相对于父元素的宽度比例
- `em` 相对于当前元素的`font-size`
- `rem` 相对于根节点的`font-size`
- ` vw``vh ` 屏幕宽度的`1%`屏幕高度的`1%`
- `vmin` 两者的最小值，`vmax` 两者的最大值

## 5. 箭头函数

**缺点**

- 没有`arguments`
- 无法通过`apply` `call` `bind` 改变 this
- 某些箭头函数代码难以阅读

**不适用的场景**

1. 对象方法不能用箭头函数

```ts
const obj = {
  name: "haha",
  getName: () => {
    return this.name;
  },
};

console.log(obj.getName()); // 无打印
```

2. 原型方法

```ts
const obj = {
  name: "haha",
};
obj.__proto__.getName = () => {
  return this.name;
};

console.log(obj.getName()); // 无打印
```

3. 构造函数

```ts
const Foo = (name, city) => {
  this.name = name;
  this.city = city;
};

const f = new Foo("张三", "成都"); //Foo is not a constructor
```

4. 动态上下文的回调函数

```ts
const btn1 = document.getElementById("btn1");
btn1 = addEventListener("click", () => {
  this.innerHTML = "clicked";
});
```

5. Vue 生命周期和 method

```vue
{ data(){ return {name:'张三'} }, methods:{ getName:()=>{ return this.name } },
mounted:()=>{ console.log('msg',this.name) } }
```

## 6. 请描述 TCP 三次握手和四次挥手

**三次握手** - 建立连接

- client 发包，server 接收，server：有 client 要找我
- server 发包，client 接收，client：server 已经收到消息
- client 发包，server 接收，server：client 要准备发送了

**四次挥手** - 断开连接

- client 发包，server 接收，server：知道 client 要断开了
- server 发包，client 接收，server：我知道了，等我传输完
- server 发包，client 接收，server：东西发送完了，可以关闭连接
- client 发包，server 接收，server：收到可以关闭消息，关闭

## 7. for...in 和 for...of 有什么区别

**答案**

- `for...in` 用于`可枚举`数据，如对象、数组、字符串，得到 key
- `for...of`用于`可迭代`数据，如数组、字符串、Map、Set，得到 value

**key 和 value**

- `for...in` 遍历得到 key
- `for...of` 遍历得到 value

**适用于不同的数据对象**

- 遍历对象：`for...in` 可以，`for...of` 不可以
- 遍历 Map Set：`for...in` 不可以，`for...of` 可以
- 遍历 generator：`for...in` 不可以，`for...of` 可以

## 8. for await ...of 有什么用

- `for await ...of` 用于异步，遍历多个 Promise

```js
async function(){
  const p1=createPromise(100)
  const p2=createPromise(200)
  const p3=createPromise(300)

  const list=[p1,p2,p3]
  // 第一种访问方式
  Promise.all(list).then(res=>console.log(res))

  // 第二种访问方式
  for await(let res of list){
    console.log(res)
  }
}
```

- 一个一个打印

```js
const arr = [10, 20, 30];
for (let num of arr) {
  const res = await createPromise(num);
  console.log(res);
}
```

## 9. offsetHeight scrollHeight clientHeight 区别

**计算规则**

- `offsetHeight offsetWidth` ：border + padding + content
- `clientHeight clientWidth` ：padding + content
- `scrollHeight scrollWidth` ：padding + 实际内容尺寸

## 10. HTMLCollection 和 NodeList 区别

- NodeList 是一个静态集合，其不受 DOM 树元素变化的影响；相当于 DOM 树快照，节点数量和类型的快照，就是对节点增删，NodeList 感受不到，但是对节点内部内容修改，是可以感受到的，比如`innerHTML`
- HTMLCollection 是动态绑定的，是一个动态集合，DOM 树发生变化，HTMLCollection 也会随之变化，节点的增删是敏感的
- 只有 NodeList 对象有包含属性节点和文本节点
- HTMLCollection 元素可以通过`name` `id` 或`index` 索引来获取，NodeList 只能通过`index` 索引来获取
- HTMLCollection 和 NodeList 本身无法使用数组的方法：`pop()` `push()` `join()` 等，除非把他转为一个数组

```js
const nodelist = [...document.querySelectorAll("div")];

nodelist.forEach((item) => item);
nodelist.slice();
```

## 11. JS 严格模式有什么特点

**开启严格模式**

```js
"use strict"; //全局开启
function fn() {
  "use strict"; //某个函数开启
}
```

**特点**

- 不允许使用未声明的变量
- 不允许删除变量或对象、函数
- 不允许变量重名
- 不允许使用八进制
- 不允许使用转义字符
- 不允许对只读属性赋值
- 不允许对一个使用 getter()方法读取的属性进行赋值
- 不允许删除一个不允许删除的属性
- 变量名不能使用`eval` `arguments` 字符串
- 不能使用 with 语句
- 在作用域 eval()创建的变量不能被调用
- 函数在浏览器全局变量中被简单调用，非严格模式下`this` 指向`window` 在`use strict` 指明严格模式的情况下就是`undefined`

## 12. HTTP 跨域请求时为何发送 options 请求

**答案**

- options 请求，是跨域请求之前的预检查
- 浏览器自动发起的，无需我们干预
- 不影响实际的功能
- 预检查服务端是否支持某种请求方法 如 delete patch post 等

**JSONP 原理：A 网页定义全局函数，请求 B 网页，B 返回一个函数调用，由于在 script 中，所以当作函数执行**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647415319786-6073108d-c760-4d45-a6ed-baadb4b78cda.png)

**cors**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647415417964-cf694c47-27c7-4e07-9e94-1e3d43b9d04e.png)

## 13. JS 内存垃圾回收用什么算法

**什么是垃圾回收**

- 回收那些函数执行完成了，再也用不到的对象和数据

**引用计数（以前）**

- 所谓引用计数是指语言引擎有一张“引用表”，保存了内存里面所有的资源(通常是各种值)的引用次数，如果一个值的引用次数是 0，就标识这个值不再用到了，因此可以将这块内存释放

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647475929157-cd7f0fea-23c5-4a3a-a77d-29a408751804.png)

**标记清除（现代）算法**

- 标记阶段
  - 遍历所有对象找标记活动的对象
- 清扫阶段：遍历所有对象清除没有标记的对象，同时会清除第一阶段所作的标记，便于之后可以进行正常的工作

## 14. 闭包是内存泄漏吗

- 内存泄漏是非预期的结果
- 闭包存在内存中是预期的结果，不算内存泄漏
- 闭包数据不可以被回收

## 15. JS 内存泄漏如何检测，场景有哪些

**检测**

- 使用浏览器开发者工具的 Performance
- 勾选 memory，触发垃圾回收
- 开始检测，触发页面事件

**场景**

- 被全局遍历、函数引用、组件销毁时未清除
- 被全局事件、定时器引用，组件销毁时未清除
- 被自定义事件引用，组件销毁时未清除

**扩展**

- 如果用 Obj 或者 map、set 定义，函数执行完，引用 obj 还在，而 weakmap 和 weakset 是弱引用，函数执行完就清除了 obj，所以 weakmap 只能使用 get 去尝试访问有没有数据

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647477212923-d57d7314-7b42-40a1-aa22-041bf43c8289.png)

## 16. 浏览器和 nodejs 的事件循环有什么区别

**答案**

- 浏览器和 nodejs 的 event loop 流程基本相同
- nodejs 宏任务和微任务分类型，有优先级

**注意事项**

- 推荐使用`setImmediate` 代替`process.nextTick`

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647477791279-ad580ac8-418e-4c72-9ca6-906907a8bead.png)

**nodejs 异步**

- nodejs 同样使用 ES 语法，也是单线程，也需要异步
- 异步任务也分：宏任务 + 微任务
- 但是它的宏任务和微任务分不同类型，有不同优先级
- **宏任务优先级**
  - `timers`
  - `I/O callbacks`
  - `idls prepare`
  - `poll`
  - `check`
  - `close callbacks`

**nodejs event loop**

- 执行同步任务
- 执行微任务(process.nextTick 优先级更高)
- 按顺序执行 6 个类型的宏任务(每个结束时都执行当前的微任务)

## 17. VDOM 真的很快吗

**答案**

- vdom 并不快，JS 直接操作 DOM 才是最快的
- 但“数据驱动视图”要有合适的技术方案，不能全部 DOM 重建
- vdom 就是目前最合适的技术方案(并不是因为它块，而是合适)

## 18. 遍历一个数组用 for 和 forEach 哪个更快

**答案**

- for 更快
- forEach 每次都要创建一个函数来调用，而 for 不会创建函数
- 函数需要独立的作用域，会有额外的开销

## 19. nodejs 如何开启线程，进程如何通讯

**答案**

- 开启子进程`child_process.fork` 和`cluster.fork`
- 使用`send` 和`on` 传递消息

**进程 process vs 线程 Thread**

- 进程：OS 进行资源分配和调度的最小单位，有独立内存空间
- 线程：OS 进行运算调度的最小单位，共享进程内存空间
- JS 是单线程的，但可以开启多进程执行，如 WebWorker

**为何需要多进程**

- 多核 CPU，更适合处理多进程
- 内存较大，多个进程才能更好的利用(单进程有内存上限)
- 总之，“压榨”机器资源，更快，更节省

**nodejs 开启多进程**

- 主进程

```js
const http = require("http");
const fork = require("child_process").fork;

const server = http.createServer((req, res) => {
  if (req.url === "/get-sum") {
    console.info("主进程 id", process.pid);

    // 开启子进程
    const computeProcess = fork("./compute.js");
    computeProcess.send("开始计算");

    computeProcess.on("message", (data) => {
      console.info("主进程接受到的信息：", data);
      res.end("sum is " + data);
    });

    computeProcess.on("close", () => {
      console.info("子进程因报错而退出");
      computeProcess.kill();
      res.end("error");
    });
  }
});
server.listen(3000, () => {
  console.info("localhost: 3000");
});
```

- 子进程

```js
/**
 * @description 子进程，计算
 * @author 双越老师
 */

function getSum() {
  let sum = 0;
  for (let i = 0; i < 10000; i++) {
    sum += i;
  }
  return sum;
}

process.on("message", (data) => {
  console.log("子进程 id", process.pid);
  console.log("子进程接受到的信息: ", data);

  const sum = getSum();

  // 发送消息给主进程
  process.send(sum);
});
```

## 20. 请描述 JS Bridge 原理

**什么是 JS Bridge**

在 Hybrid 模式下，H5 经常需要使用 Native 的功能，Native 需要向 web 端发送推送更新状态，而 JS 是运行在单独的 JS Context 中，与原生运行环境相隔离，所以需要有一种机制实现 Native 和 web 端的双向通信，这就是 JSBridge

- JS 无法直接调用 native API
- 需要一些特定的格式来调用
- 这些格式统称 JS-Bridge 例如微信 JSSDK

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647482982390-8916359d-5bef-47f8-b497-3699b633e034.png)

## 21. requestIdleCallback 和 requestAnimationFrame 区别

**区别**

- `requestAnimationFrame` 每次渲染完都会执行，高优
- `requestIdleCallback` 空闲时才执行，低优

**它们是宏任务还是微任务**

- 两者都是宏任务
- 要等待 DOM 渲染完才执行，肯定是宏任务

## 22. Vue 每个生命周期都做了什么

**beforeCreate**

- 创建一个空白的 Vue 实例
- data method 尚未被初始化，不可使用

**created**

- Vue 实例初始化完成，完成响应式绑定
- data method 都已经初始化完成，可调用
- 尚未开始渲染模板

**beforeMount**

- 编译模板，调用 render 生成 vdom
- 还没有开始渲染 DOM

**mounted**

- 完成 DOM 渲染
- 组件创建完成
- 开始由“创建阶段”进入“运行阶段”

**beforeUpdate**

- data 发生变化之后
- 准备更新 DOM（尚未更新 DOM）

**updated**

- data 发生变化，且 DOM 更新完成
- （不要再 updated 中修改 data，可能会导致死循环）

**beforeUnmount**

- 组件进入销毁阶段（尚未销毁，可正常使用）
- 可移动、解绑一些全局事件、自定义事件

**unmounted**

- 组件被销毁
- 所有子组件也被销毁了

**keep-alive 组件**

- onActivated 缓存组件被激活
- onDeactivated 缓存组件被隐藏

## 连环问 vue 什么时候操作 DOM 比较合适

- mounted 和 updated 都不能保证子组件全部挂载完成
- 使用$nextTick 渲染 DOM

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647484709351-01352c82-2dbb-41d8-8ddb-6eedc9df277f.png)

## 连环问 Ajax 应该在哪个生命周期

- 有两个选择：created 和 mounted
- 推荐：mounted

## 连环问 Vue3 Composition API 生命周期有何区别

- 用 setup 代替了 beforeCreate 和 created
- 使用 Hooks 函数的形式，比如 mounted 改为 onMounted

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647484892946-e1b28e67-df7f-407d-8ca4-1cf3ef9df10c.png)

## 23. Vue2 Vue3 React 三者 diff 算法有何区别

**相同点**

- 只比较同一层级，不跨级比较
- tag 不同则删除重建
- 子节点通过 key 区分

**区别**

- React diff - 仅右移
- Vue2 双端比较 - 四个指针相互比较
- Vue3 最长递增子序列

## 连环问 Vue React 为何循环时必须使用 key

- vdom diff 算法会根据 key 判断元素是否要删除
- 匹配了 key，则只移动元素 - 性能较好
- 未匹配 key，则删除重建 - 性能较差

## 24. Vue-router 和 MemoryHistory 是什么

**Vue-router 三种模式**

- hash
  - 通过`location.hash` 实现的
- WebHistory
  - 通过`history.pushState` `window.onpopState` 实现
- MemoryHistory
  - 跳转页面 路由不变

## 25. 移动端 H5 click 有 300ms 延迟，该如何解决

**初期解决方案 FastClick**

- 原理：监听 touchend 事件（touchstart touchend 会先于 click 触发）
- 使用**自定义 DOM**事件模拟一个 click 事件
- 把默认的 click 事件(300ms 之后触发)禁止掉

![img](https://cdn.nlark.com/yuque/0/2022/png/1356933/1647491547551-48854d9f-a142-47a4-98eb-8243eafcdf52.png)

**现代浏览器的改进**

- 只要浏览器里面有`width=device-width`就不会有 300ms 延迟
- 手机认为你已经做了响应式了，不需要 300ms 延迟了

![img](https://cdn.nlark.com/yuque/0/2022/png/1356933/1647491677034-bcd5ce31-1b7d-442f-8c26-664b577d26c3.png)

## 26. 网络请求中，token 和 cookie 有什么区别

- `cookie` :HTTP 标准，跨域限制，配合 session 使用
- `token` ：无标准，无跨域限制，用于 JWT

**现代浏览器开始禁止第三方 cookie 使用 samsite**

- samsite：stick/lax/none 严格模式，松散模式，没有限制

**cookie 和 session**

- cookie 用于登录验证，存储用户标识
- session 在服务端，存储用户详细信息，和 cookie 信息一一对应
- cookie + session 是常见登录验证解决方案

**token vs cookie**

- cookie 是 HTTP 规范，而 token 是自定义传递
- cookie 会默认被浏览器传递，而 token 需自己传递
- token 默认没有跨域限制

**JWT（JSON Web Token）**

- 前端发起登录，后端验证成功之后，返回一个加密的 token
- 前端自行存储这个 token(其中包含了用户信息)
- 以后访问服务端就带上这个 token

## 27. session 和 JWT 哪个更好

**答案**

- 如有严格管理用户信息的需求(保密，快速封禁)推荐 session
- 如没有特殊要求，则使用 JWT

**session 优点**

- 原理简单，易于学习
- 用户信息存储在服务端，可快速封禁某个用户

**session 缺点**

- 占用服务器内存，硬件成本高
- 多进程，多服务器，不好同步 - 需使用第三方缓存，如 redis
- 不同 session 存储在不同进程中，需要使用 redis 统一管理 session
- 默认有跨域限制

**JWT 优点**

- 不占用服务端内存
- 多进程，多服务器不受影响
- 没有跨域限制

**JWT 缺点**

- 用户信息存储在客户端，无法快速封禁某用户
- 万一服务端密钥被泄漏，则用户信息全部丢失
- token 体积一般大于 cookie，会增加请求的数据量

## 28. 如何实现 SSO 单点登录

**基于 cookie**

- cookie 默认不可跨域共享，但某些情况下可设置为共享
- 主域名相同，如www.baidu.com image.baidu.com
- 设置 cookie domain 为主域名，即可共享 cookie

**SSO**

- 浏览器访问 A，A 重定向 SSO 网站，登陆后返回 ticket
- 浏览器访问 B，B 重定向 SSO 网站，登录后返回 ticket
- 当客户端登陆过 A 之后，去访问 B，B 就拿到 ticket 去找 SSO 校验

**OAuth 2.0**

- 第三方登录

## 29. HTTP 协议和 UDP 协议有什么区别

**答案**

- HTTP 是应用层，TCP UDP 是传输层
- TCP 有连接，有断开，稳定传输
- UDP 无连接，无断开，不稳定传输，但效率高

**网络协议**

- HTTP 协议在应用层
- TCP UDP 协议在传输层

**TCP 协议**

- 有连接(三次握手)
- 有断开(四次挥手)
- 稳定传输

**UDP 协议**

- 无连接，无断开
- 不稳定传输，但效率高
- 如视频会议，语音通话

## 30. HTTP 协议 1.0 1.1 2.0 有什么区别

**HTTP1.0**

- 最基本的 HTTP 协议
- 支持基本的 GET POST 方法

**HTTP1.1**

- 增加了缓存策略`cache-control` `e-tag` 等
- 支持长连接`Connection:keep-alive` 一次 TCP 连接多次请求
- 支持断点续传，状态码 206
- 支持新的方法 PUT DELETE 等，可用于 Restful API

**HTTP2.0**

- 可压缩 header，减少体积
- 多路复用，一次 TCP 连接中可以多个 HTTP 请求
- 服务端推送，websocket

## 31. 什么是 HTTPS 中间人攻击，如何预防

**HTTPS 加密传输**

- http 明文传输
- httos 加密传输 HTTP + TLS/SSL

当使用对称加密时用的同一套密钥，会被黑客劫持解密出来

非对称加密，公钥加密，私钥解密，但是如果有中间黑客，把自己的公钥给客户端，客户端发送的时候再劫持用自己的私钥解开

先使用非对称加密建立连接，然后使用对称加密传输数据

**预防** ：服务器使用 CA 证书，浏览器就能知道这个公钥是不是合法的

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647495776353-1fc37c70-70a3-42f6-933f-3af0e06e1792.png)

## 32. script 标签的 defer 和 async 有什么区别

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647495910968-4306deed-8de1-4d7f-afb8-1a4d6fdb85b7.png)

- defer 并行加载，延迟执行
- async 并行加载，加载完立刻执行，阻塞 HTML

## 33. prefetch 和 dns-prefetch 有什么区别

**答案**

- prefetch 是资源预获取（和 preload 有关）
- dns-prefetch 是 DNS 预查询（和 preconnect 相关）

**preload 和 prefetch**

- preload 资源再当前页面使用，会`优先`加载
- prefetch 资源在未来页面使用，`空闲时`加载

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647496293543-4b59745b-83e8-4a48-9364-e922549a4039.png)

**dns-prefetch 和 preconnect**

- dns-prefetch 即 DNS 预查询
- preconnect 即 DNS 预连接

## 34. 你知道哪些前端攻击，该如何预防

**XSS**

- Scross Site Script 跨站脚本攻击
- 手段：黑客将 JS 代码插入到网页内容中，渲染时执行 JS 代码
- 预防：特殊字符替换(前端或者后端)
- 只要 vue 和 react 不用 v-html 或 dangerouselySetInnerHTML 就可以预防

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647497073944-4262957b-b9f0-4bf4-8bf4-0edfdc1d0aa0.png)

**CSRF**

- Cross Site Request Forgery 跨站请求伪造
- 手段：黑客诱导用户去访问另一个网站的接口，伪造请求
- 预防：严格的跨域限制 + 验证码机制

**CSRF 详细过程**

- 用户登陆了 A 网站，有了 cookie
- 黑客诱导用户到 B 网站，并发起 A 网站的请求
- A 网站的 API 发现有 cookie，以为是用户自己操作的

**点击劫持**

- Click Jacking
- 手段：诱导界面上蒙一个透明的 iframe，诱导用户点击
- 预防：让 iframe 不能跨域加载

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647497559975-76f42309-4600-4e5e-8acd-28ca82864548.png)

**DDos**

- Distribute denial-of-service 分布式拒绝服务
- 手段：分布式的，大规模的流量访问，使服务器瘫痪
- 预防：软件层不好做，需硬件预防(如阿里云 WAF)

**SQL 注入**

- 手段：黑客提交内容时写入 SQL 语句，破坏数据库
- 预防：处理输入的内容，替换特殊字符

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647498240471-d8003c37-24d1-4caf-b537-bbc8c583c69e.png)

## 35. WebSocket 和 HTTP 区别

**答案**

- websocket 协议名是 ws://，可双端发送请求
- websocket 没有跨域限制
- 通过 send 和 onmessage 通讯(http 通过 req 和 res)

**WebSocket**

- 支持端对端通讯
- 可以有 client 发起，也可以由 server 发起
- 用于：消息通知，直播间讨论区，聊天室，协同编辑
- ws 可升级为 wss(像 https)
- 实际项目中推荐`socket.io` 实现
- 客户端

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647498649695-c35ed899-3ff1-4ccd-b42d-4d07ac77915f.png)

- 服务端

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647498675330-cb2c979d-2ea0-4cff-81c0-2efdc9b77997.png)

**WebSocket 连接过程**

- 先发起一个 HTTP 请求
- 成功之后再升级到 WebSocket 协议，再通讯

## 36. WebSocket 和 HTTP 长轮询的区别

- HTTP 长轮询：客户端发送请求，服务端阻塞，不回立即返回
- WebSocket：客户端可发送请求，服务端也可发起请求

**注意**

- HTTP 长轮询，需处理 timeout，即 timeout 之后重新发送请求

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647523786488-0fd9cd8d-13d7-4e32-b362-f5e356671353.png)

## 37. 描述从输入 url 到页面展示的完整过程

1. 网络请求：DNS 解析，HTTP 请求
2. 解析：DOM 树，CSSDOM 树，Render Tree
3. 渲染：计算、绘制、同时执行 JS

**网络请求**

1. DNS 查询(得到 IP)，建立 TCP 连接(三次握手)
2. 浏览器发送 HTTP 请求
3. 收到请求响应，得到 HTML 源代码
4. 解析 HTML 过程中，遇到静态资源还会继续发起网络请求
5. JS CSS 图片 视频等
6. 注意：静态资源可能有强缓存，此时不必请求

**结构化**

1. 字符串->结构化数据
2. HTML 构建 DOM 树
3. CSS 构建 CSSDOM 树(style tree)
4. 两者结合，形成 render tree

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647524219949-f5ec446e-a4c3-46e5-b20b-0c85476e2e67.png)

**渲染：Render Tree 绘制到页面**

- 计算各个 DOM 的尺寸、定位，最后绘制到页面
- 遇到 JS 可能会执行(参考 defer async)
- 异步 CSS、图片加载，可能会触发重新渲染

## 38. 网页重绘 repain 和重排 reflow 有什么区别

**动态网页，随时都会重绘，重排**

- 网页动画
- Modal Dialog 弹窗
- 增加/删除一个元素，显示/隐藏一个元素

**重绘 repain**

- 元素外观改变，如颜色、背景色
- 但元素的尺寸、定位不变，不会影响其他元素的位置

**重排 reflow**

- 重新计算尺寸和布局，可能会影响其他元素的位置
- 如元素高度增减，可能使相邻元素位置不变

**区别**

- 重排比重绘影响要大，消耗也更大
- 所以，要尽量避免无意义的重排

**优化**

- 集中修改样式，或直接切换 css class
- 修改之前先设置`display:none` 脱离标准文档流
- 使用 BFC 特性，不影响其他元素位置
- 频繁触发使用节流和防抖
- 使用 createDocumentFragment 批量操作 DOM
- 优化动画，使用 CSS3 和 requestAnimationFrame

**触发 BFC 的条件**

- 根节点\<html\>
- `float:left/right`
- `overflow:auto/hidden`
- `display:inline-block/table/table-row/table-cell`
- `display:flex/grid` 的直接子元素
- `position:absolute/fixed`

## 39. 如何实现网页多标签 tab 通讯

**答案**

- WebSocket 需要服务器，成本较高
- localStorage 简单易用，推荐
- SharedWorker 调试不方便，不兼容 IE11

**使用 websocket 通讯**

- 无跨域限制
- 需要服务端支持，成本高

**使用 localStorage 通讯**

- 同域的 A 和 B 两个页面
- A 页面设置 localStorage
- B 页面可监听到 localStorage 值的修改

**通过 SharedWorker 通讯**

- SharedWorker 使 WebWorker 的一种
- WebWorker 可开启进程执行 JS，但不能操作 DOM
- SharedWorker 可单独开启一个进程，用于同域页面通讯

## 40. 网页和 iframe 之间的通讯

**答案**

- 使用`postMessage`通讯
- 注意跨域的限制和判断

## 41. H5 页面如何进行首屏优化

**答案**

- 路由懒加载
- 服务端渲染 SSR
- App 预取
- 分页
- 图片懒加载
- Hybrid

**重点**

- 服务端 SSR 是 H5 的终极优化方案(但成本也高)
- 移动端 H5 要结合 App 能力去优化
- 严格来说 hybrid 不是 H5，但这里回答出来没有问题
- 性能优化要配合分析、统计、评分等，做了事情要有结果
- 性能优化也要配合体验，如骨架屏，loading 动画等
- 不同的形式，有不同的优化方式，要积极和面试官沟通

**路由懒加载**

- 适用于 SPA(不适用 MPA)
- 路由拆分，优先保证首页加载

**服务端渲染 SSR**

- 传统的前后端分离(SPA)渲染页面的过程复杂
- SSR 渲染页面过程简单，所以性能好
- 如果是纯 H5 页面，SSR 是性能优化的终极方案

**App 预取**

- 如果 H5 在 App WebVIew 中展示，可使用 App 预取
- 用户访问列表页时，App 预加载文章首屏内容
- 用户进入 H5 页，直接从 App 中获取内容，瞬间展示首屏

**分页**

- 针对列表页
- 默认只展示第一页内容
- 上滑加载更多

**图片懒加载 lazyload**

- 针对详情页
- 默认只展示文本内容，然后触发图片懒加载
- 注意：提前设置图片尺寸，尽量只重绘不重排

**Hybrid**

- 提前将 HTML JS CSS 下载到 App 内部
- 在 App webview 中使用 file://协议加载页面卡片
- 再用 Ajax 获取内容并展示(也可结合 App 获取)

## 42. 后端一次性返回 10W 条数据，你该如何渲染

**设计不合理**

- 后端返回 10w 条数据，本身技术方案设计就不合理
- 主动和面试官沟通此事(这也许是面试官所期待的)
- 如果面试官非要这么做，那再继续寻找解决方案

**浏览器能否处理 10w 条数据**

- JS 没问题
- 渲染到 DOM 会非常卡顿

**自定义中间层**

- 自定义 nodejs 中间层，获取并拆分这 10w 条数据
- 前端对接 nodejs 中间层，而不是服务端
- 成本比较高

**虚拟列表**

- 只渲染可视区域 DOM
- 其他隐藏区域不显示，只用\<div\>撑起高度
- 随着浏览器滚动，创建和销毁 DOM
- **借用第三方 lib** `Vue-virtual-scroll-list` `React-virtualized`

## 43. 文本超出省略，用哪个 CSS 样式

- 单行文本

```css
#box {
  border: 1px solid #ccc;
  width: 100px;
  white-space: nowrap; // 不换行
  overflow: hidden;
  text-overflow: ellipsis; // 超出省略
}
```

- 多行文本

```css
#box {
  border: 1px solid #ccc;
  width: 100px;
  overflow: hidden;
  display: -webkit-box; //将对象作为弹性伸缩盒子模型显示
  -webkit-box-orient: vertical; // 设置子元素排列方式
  -webkit-line-clamp: 3; //显示几行，超出的省略
}
```

## 44. 前端常用的设计模式和使用场景

**题目**

- 工厂模式
- 单例模式
- 代理模式
- 观察者模式
- 发布订阅模式
- 装饰器模式

**设计原则**

- 最重要的思想：开放封闭原则
- 对扩展开放
- 对修改封闭

**工厂模式**

- 用一个工厂函数，来创建实例，隐藏 new
- 如 jQuery $函数
- 如 React createElement 函数

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647568226606-a1c4975b-957c-460c-af51-178faf06c213.png)

**单例模式**

- 全局唯一的实例(无法生成第二个)
- 如 Vuex Redux 和 store
- 如全局唯一的 dialog modal
- **注意**：JS 是单线程的，创建单例很简单，Java 是支持多线程的，创建单例要考虑锁死线程，否则多个线程同时创建，单例就重复了(多线程共享进程内容)

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569555578-69f648cc-fa91-4d97-a9e2-0d670bc286d0.png)

**代理模式**

- 使用者不能直接访问对象，而是访问一个代理层
- 在代理层可以监听 get set 做很多事情
- 如 ES6 Proxy 实现 vue3 响应式

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569164500-e735f65a-b0a5-4766-bd6b-b8ab36c5c16a.png)

**观察者模式**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569198351-56e5028d-932b-4a88-b5e0-6ac64f3b0cfd.png)

**发布订阅**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569218415-755ed174-0a81-48ac-87c2-fb83817131de.png)

**装饰着模式**

- 原功能不变，增加一些新功能(AOP 面向切面编程)
- ES 和 Typescript 的 Decorator 语法
- 类装饰器，方法装饰器

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569390424-14473530-ecba-40c4-8a43-2531f1451a77.png)

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569415335-f53f2659-34e4-4e94-a06a-7b88c6111b53.png)

## 45. 观察者模式和发布订阅模式的区别

**观察者模式**

- Subject 和 Observer 直接绑定，没有中间媒介
- 如 addEventListener 绑定事件

**发布订阅**

- Publisher 和 Observer 互不相识，需要中间媒介 Event channel
- 如 EventBus 自定义事件

## 46. 你在实际工作中做过哪些 Vue 优化

**答案**

- v-if 和 v-show
- v-for 使用 key
- computed 缓存数据
- keep-alive 缓存组件
- 异步组件 路由懒加载
- SSR

**v-if 和 v-show**

- v-if 彻底销毁组件
- v-show 使用 css 隐藏组件
- 大部分情况下使用 v-if 更好，不要过渡优化

**v-for 使用 key**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569937881-efaa5003-a78b-4e25-b39d-5048b0fc1863.png)

**使用 computed 缓存**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569968220-21945ce8-3d9c-4205-b10e-2e2b3be347b3.png)

**keep-alive 缓存组件**

- 频繁切换的组件，如 tabs
- 不要乱用，缓存太多会占用内存，且不好 debug

**异步组件**

- 针对体积较大的组件，如编辑器、复杂表格、复杂表单等
- 拆包，需要时异步加载，不需要时不加载
- 减少主包的体积，首页会加载更快

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647570150427-fbd947cf-d45f-4e31-b261-5d1bb90db6d6.png)

**路由懒加载**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647570217627-6e999273-b12f-4e39-a28b-540cc6342683.png)

**服务端渲染 SSR**

- 可使用 Nuxt.js
- 按需优化，使用 SSR 的成本比较高

## 47. 你使用 Vue 遇到过哪些坑

**内存泄漏**

- 由于全局变量、全局事件、全局定时器绑定之后没有销毁造成内容泄漏
- 自定义事件未销毁

**Vue2 响应式的缺陷（Vue3 不再有）**

- data 新增属性用 Vue.set
- data 删除属性用 Vue.delete
- 无法直接修改数据 arr[index]=value

**路由切换时 scroll 到顶部**

- SPA 的通病，不仅是 Vue
- 如，列表页，滚动到第二屏，点击进入详情页
- 再返回到列表页(此时组件重新渲染)就 scroll 到顶部
- **解决方案**
  - 在列表页缓存数据和 scrollTop 值
  - 当再次返回列表时，渲染组件，执行 scrollTo(xxx)
  - 终极方案：MPA + APP WebView

## 48. 实际工作中，做过哪些 React 优化

**答案**

- 模拟 v-show
- 循环使用 key
- Fragment 减少层级
- JSX 不要定义函数
- 构造函数 bind this
- shouldComponentUpdate
- useMemo
- 异步组件
- 路由懒加载
- SSR

**修改 CSS 模拟 v-show**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571029995-c875e5cf-4479-4395-81a5-56f768688c39.png)

**循环使用 key**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571056055-25844a08-1ff5-40bc-8499-493ffd829362.png)

**使用 Fragment 减少层级**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571072248-f6f406af-35b0-4716-8d96-999e573eef2b.png)

**JSX 中不要定义函数**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571094019-b2b0ec48-0e1c-4c36-aa8d-2c37ec99d154.png)

**要在构造函数中 bind this**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571143063-17591928-c721-4c44-8a20-195c9d2b35ca.png)

**使用 shouldComponentUpdate**

- 使用`shouldComponentUpdate` 判断组件是否要更新
- 或者使用`React.PureComponent`
- 函数组件使用`React.memo`

**Hooks 缓存数据**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579459564-42b2cd64-6201-49fb-bf7f-d5a7e568e437.png)

**其他**

- 异步组件
- 路由懒加载
- SSR-Next.js

## 49. 你使用 React 时遇到哪些坑

**自定义组件的名称首字母要大写**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579721226-1a356f0d-4e21-4191-b69b-9925d0c4032f.png)

**JS 关键字的冲突**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579783625-e88ed79b-b7fb-4a6e-b411-d84a4617c7e9.png)

**JSX 数据类型**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579799446-6ce34219-5917-456c-9a21-b67012262d8f.png)

**setState 是异步更新的**

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579840808-3b68aef5-e693-471b-ad0d-20dffc0cc07d.png)

## 50. 如何统一监听 Vue 组件报错

**答案**

- `errorCaptured` 监听下级组件错误，返回 false 阻止向上传播
- `errorHandler`监听全局 Vue 组件的错误
- `window.onerror` 监听其他 JS 错误，如异步

**window.onerror**

- 全局监听所有 JS 错误
- 但它是 JS 级别的，识别不了 Vue 组件信息
- 捕捉一些 Vue 监听不到的错误

## 51. 如何统一监听 React 组件的报错

**答案**

- ErrorBoundary 监听组件渲染报错
- 事件报错使用 try-catch 或 window.onerror
- 异步报错使用 window.onerror

**ErrorBoundary 组件**

- 监听所有下级组件报错，可降级展示 UI
- 只监听组件渲染时报错，不监听 DOM 事件、异步错误
- `production` 环境生效，`dev`会直接抛出错误

```ts
import React from "react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null, // 存储当前的报错信息
    };
  }
  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染能够显示降级后的 UI
    console.info("getDerivedStateFromError...", error);
    return { error };
  }
  componentDidCatch(error, errorInfo) {
    // 统计上报错误信息
    console.info("componentDidCatch...", error, errorInfo);
  }
  render() {
    if (this.state.error) {
      // 提示错误
      return <h1>报错了</h1>;
    }

    // 没有错误，就渲染子组件
    return this.props.children;
  }
}

export default ErrorBoundary;
```

## 52. 如果一个 H5 很慢，你该如何排查性能问题

**答案**

- 分析性能指标，找到慢的原因
- 对症下药，解决问题
- 持续跟进，持续优化

**前端性能指标**

- First Paint(FP) 第一次无内容的渲染
- First Contentful Paint(FCP) 第一次有内容的渲染
- DomContentLoaded(DCL) DOM 内容加载完成
- Largest Contentfull Paint(LCP) 最大的一种渲染
- Load(L)

**工具**

- Chrome devTools
- light house

**如果是网页加载慢**

- 优化服务器硬件配置，使用 CDN
- 路由懒加载，大组件异步加载 - 减少主包的体积
- 优化 HTTP 缓存策略

**如果是网页喧染满**

- 优化服务端接口(如 Ajax 获取数据慢)
- 继续分析，优化前端组件内部的逻辑(参考 Vue React 优化)
- 服务端渲染 SSR

**持续跟进**

- 性能优化是一个循序渐进的过程，不像 bug 一次性解决
- 持续跟进统计结果，再逐步分析性能瓶颈，持续优化
- 可使用第三方统计服务，如阿里云 ARMS，百度统计

## 53. 令人失眠的 promise-then 执行顺序问题

**then 交替执行**

- 如果有多个`fulfilled promise`实例，同时执行 then 链式调用
- then 会交替执行
- 这是编译器的优化，防止一个`promise`占据太久时间

**then 中返回 promise 实例**

- 相当于多出一个 promise 实例
- 也会遵守“交替执行”
- (但会直接声明一个 promise 实例，结果有些差异)

**慢半拍**

- then 中返回 promise 实例，会出现`慢半拍` 的效果
- 第一拍，promise 需要由 pending 变为 fulfilled
- 第二拍，then 函数挂载到 MicroTaskQueue(参考 Event Loop)

## 54. setState 是微任务还是宏任务

**答案**

- setState 是同步执行，state 是同步更新
- 即，在微任务 Promise.then 开始之前，state 已经计算完了
- 同步，不是微任务或宏任务

**setState 本质是同步**

- setState 是同步，只不过让 React 做成了异步的样子
- 因为要考虑性能，多次 state 修改，只进行一次 DOM 渲染
- 日常说的`异步`是不严谨的，但沟通成本低

## 55. 对象属性类型的问题

**JS 对象 key 的数据类型**

- 只能是`字符串`和`Symbol` 类型
- 其他类型会被转换为字符串
- 就是将类型`toString()`之后作为 key

**Symbol 无论内部一样，外面都是不一样的**

- 所以一样的字符串 Symbol 都是不一样的不回覆盖

**Map 和 WeakMap 的 key 就不会出现这种情况**

- Map 的 key 可以是各种类型
- WeakMap 的 key 只能是引用类型，不能是值类型

![img](https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647654516971-f88b4de3-14a4-4d73-a2f4-c59d13964865.png)

- 第一个由于 类型转换为`123` 则覆盖前面，结果`c`
- 第二个，Symbol 定义的总是不一样，所以不覆盖，结果`b`
- 第三个，对象 toString 之后都是`[object Object]` 字符串，覆盖，结果`c`

## 56. 何时使用 SSR，何时不用

**SSR 的优势**

服务端直出 html

- 性能好
- 对 SEO 优化

**SSR 的劣势**

前后端同构，开发成本高(学习、测试、运维等)

**是否需要 SSR**

- 你的项目是否需要 SSR ——管理后台就不需要
- 你的项目是否在一极致的性能优化，或者是否有可能处于弱网环境 ——管理后台不需要

如果急需要 SSR 的优势和价值，那就去承担 SSR 的成本，如果不需要这些优势，那 SSR 就成了一个累赘

**SSR 的应用场景**

C 端，以阅读为主的单页面，如新闻页，运营宣传广告页面，官网等，1.需要快 2. 需要 SEO

## 57. 如何做 Code-Review

**如何做 Code-Review**

- 代码规范(eslint 不能全面检查，如变量命名，代码语义)
- 重复的代码要抽离，复用
- 单个函数内容过长，需要拆分
- 算法复杂度是否可用，是否可继续优化
- 是否有安全漏洞
- 扩展性如何(不用为了扩展而扩展，不封闭即可)
- 是否有现有的功能重复了
- 是否有完整的单元测试
- 组件设计是否合理

**Code review 的时机**

- 提交 PR 时，通过代码 diff 进行 Code review
- 每周例行一次集体 Code review

**持续优化**

- 每次 Code review 的问题要记录下
- 归纳整理，形成自己的 diamagnetic 规范体系
- 新加入的成员要提前学习，提高规避

**之前没有做过 Code review 怎么办**

- 作为一个跳槽的理由(要求进步，想去流程规范的团队)

## 58. 如何学习一门新语言，要考虑哪些方面

**考虑内容**

- 它的优势和应用场景
- 语法(常量、变量、数据类型，运算符，函数等)
- 内置模块和 API
- 常用的第三方框架和库
- 开发环境和调试工具
- 线上环境和发布过程

## 59. 你认为自己还有什么不足之处

**答案模板**

- 我觉得自己在 xxx 方面存在不足
- 但我已经意识到，并开始学习 xxx
- 我估计会在 xxx 时间把这块补齐

**不足不要乱说**

- 范围限定在技术方面
- 非核心技术栈
- 容易弥补的，后面容易翻身

**反转话题**
