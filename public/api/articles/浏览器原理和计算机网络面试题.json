{"title":"浏览器原理和计算机网络面试题","uid":"50772cbc2a7ccf0256f62abf804cb4b7","slug":"浏览器原理和计算机网络面试题","date":"2022-04-10T12:20:25.000Z","updated":"2022-04-10T12:20:53.292Z","comments":true,"path":"api/articles/浏览器原理和计算机网络面试题.json","keywords":null,"cover":[],"content":"<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h2 id=\"一、HTTP协议\"><a href=\"#一、HTTP协议\" class=\"headerlink\" title=\"一、HTTP协议\"></a>一、HTTP协议</h2><h3 id=\"1-GET和POST的请求的区别\"><a href=\"#1-GET和POST的请求的区别\" class=\"headerlink\" title=\"1. GET和POST的请求的区别\"></a>1. GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p>\n<ul>\n<li><strong>应用场景：</strong> GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li>\n<li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>\n<li><strong>发送的报文格式：</strong> Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li>\n<li><strong>安全性：</strong> Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li>\n<li><strong>请求长度：</strong> 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li>\n<li><strong>参数类型：</strong> post 的参数传递支持更多的数据类型。</li>\n</ul>\n<h3 id=\"2-POST和PUT请求的区别\"><a href=\"#2-POST和PUT请求的区别\" class=\"headerlink\" title=\"2. POST和PUT请求的区别\"></a>2. POST和PUT请求的区别</h3><ul>\n<li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li>\n<li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li>\n</ul>\n<h3 id=\"3-常见的HTTP请求头和响应头\"><a href=\"#3-常见的HTTP请求头和响应头\" class=\"headerlink\" title=\"3. 常见的HTTP请求头和响应头\"></a>3. 常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p>\n<ul>\n<li>Accept:浏览器能够处理的内容类型</li>\n<li>Accept-Charset:浏览器能够显示的字符集</li>\n<li>Accept-Encoding：浏览器能够处理的压缩编码</li>\n<li>Accept-Language：浏览器当前设置的语言</li>\n<li>Connection：浏览器与服务器之间连接的类型</li>\n<li>Cookie：当前页面设置的任何Cookie</li>\n<li>Host：发出请求的页面所在的域</li>\n<li>Referer：发出请求的页面的URL</li>\n<li>User-Agent：浏览器的用户代理字符串</li>\n</ul>\n<p><strong>HTTP Responses Header 常见的响应头：</strong></p>\n<ul>\n<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>\n<li>server:服务器名称</li>\n<li>Connection：浏览器与服务器之间连接的类型</li>\n<li>Cache-Control：控制HTTP缓存</li>\n<li>content-type:表示后面的文档属于什么MIME类型</li>\n</ul>\n<p>常见的 Content-Type 属性值有以下四种：</p>\n<p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>\n<p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>\n<p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p>\n<p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p>\n<h3 id=\"4-HTTP状态码304是多好还是少好\"><a href=\"#4-HTTP状态码304是多好还是少好\" class=\"headerlink\" title=\"4. HTTP状态码304是多好还是少好\"></a>4. HTTP状态码304是多好还是少好</h3><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p>\n<p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p>\n<p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p>\n<p><strong>产生较多304状态码的原因：</strong></p>\n<ul>\n<li>页面更新周期长或不更新</li>\n<li>纯静态页面或强制生成静态html</li>\n</ul>\n<p><strong>304状态码出现过多会造成以下问题：</strong></p>\n<ul>\n<li>网站快照停止；</li>\n<li>收录减少；</li>\n<li>权重下降。</li>\n</ul>\n<h3 id=\"5-常见的HTTP请求方法\"><a href=\"#5-常见的HTTP请求方法\" class=\"headerlink\" title=\"5. 常见的HTTP请求方法\"></a>5. 常见的HTTP请求方法</h3><ul>\n<li>GET: 向服务器获取数据；</li>\n<li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li>\n<li>PUT：上传文件，更新数据；</li>\n<li>DELETE：删除服务器上的对象；</li>\n<li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li>\n<li>OPTIONS：询问支持的请求方法，用来跨域请求；</li>\n<li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li>\n<li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li>\n</ul>\n<h3 id=\"6-OPTIONS请求方法及使用场景\"><a href=\"#6-OPTIONS请求方法及使用场景\" class=\"headerlink\" title=\"6. OPTIONS请求方法及使用场景\"></a>6. OPTIONS请求方法及使用场景</h3><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p>\n<p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p>\n<p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p>\n<ul>\n<li>获取服务器支持的所有HTTP请求方法；</li>\n<li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li>\n</ul>\n<h3 id=\"7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？\"><a href=\"#7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？\" class=\"headerlink\" title=\"7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？\"></a>7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>HTTP 1.0和 HTTP 1.1 有以下区别</strong>：</p>\n<ul>\n<li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>\n<li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n<li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>\n<li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>\n<li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li>\n</ul>\n<h3 id=\"8-HTTP-1-1-和-HTTP-2-0-的区别\"><a href=\"#8-HTTP-1-1-和-HTTP-2-0-的区别\" class=\"headerlink\" title=\"8. HTTP 1.1 和 HTTP 2.0 的区别\"></a>8. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul>\n<li><strong>二进制协议</strong>：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>\n<li><strong>多路复用：</strong> HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>\n<li><strong>数据流：</strong> HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>\n<li><strong>头信息压缩：</strong> HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>\n<li><strong>服务器推送：</strong> HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li>\n</ul>\n<p><strong>【1】队头堵塞：</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p></blockquote>\n<h3 id=\"9-HTTP和HTTPS协议的区别\"><a href=\"#9-HTTP和HTTPS协议的区别\" class=\"headerlink\" title=\"9. HTTP和HTTPS协议的区别\"></a>9. HTTP和HTTPS协议的区别</h3><p>HTTP和HTTPS协议的主要区别如下：</p>\n<ul>\n<li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li>\n<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>\n<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>\n<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>\n</ul>\n<h3 id=\"10-GET方法URL长度限制的原因\"><a href=\"#10-GET方法URL长度限制的原因\" class=\"headerlink\" title=\"10. GET方法URL长度限制的原因\"></a>10. GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token constant\">GET</span>的长度值 <span class=\"token operator\">=</span> <span class=\"token constant\">URL</span>（<span class=\"token number\">2083</span>）<span class=\"token operator\">-</span> （你的Domain<span class=\"token operator\">+</span>Path）<span class=\"token operator\">-</span><span class=\"token number\">2</span>（<span class=\"token number\">2</span>是<span class=\"token keyword\">get</span>请求中<span class=\"token operator\">?</span><span class=\"token operator\">=</span>两个字符的长度）\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>下面看一下主流浏览器对get方法中url的长度限制范围：</p>\n<ul>\n<li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。</li>\n<li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。</li>\n<li>Safari (Browser)：URL最大长度限制为 80,000 个字符。</li>\n<li>Opera (Browser)：URL最大长度限制为 190,000 个字符。</li>\n<li>Google (chrome)：URL最大长度限制为 8182 个字符。</li>\n</ul>\n<p>主流的服务器对get方法中url的长度限制范围：</p>\n<ul>\n<li>Apache (Server)：能接受最大url长度为8192个字符。</li>\n<li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。</li>\n</ul>\n<p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p>\n<h3 id=\"11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？\"><a href=\"#11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？\" class=\"headerlink\" title=\"11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？\"></a>11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p>（1）<strong>解析URL：</strong> 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p>\n<p>（2）<strong>缓存判断：</strong> 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>\n<p>（3）<strong>DNS解析：</strong> 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>\n<p>（4）<strong>获取MAC地址：</strong> 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p>\n<p>（5）<strong>TCP三次握手：</strong> 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>\n<p>（6）<strong>HTTPS握手：</strong> 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>\n<p>（7）<strong>返回数据：</strong> 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p>\n<p>（8）<strong>页面渲染：</strong> 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p>\n<p>（9）<strong>TCP四次挥手：</strong> 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>\n<h3 id=\"12-对keep-alive的理解\"><a href=\"#12-对keep-alive的理解\" class=\"headerlink\" title=\"12. 对keep-alive的理解\"></a>12. 对keep-alive的理解</h3><p>HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是<strong>短连接</strong>。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是<strong>长连接</strong>。其使用方法如下：</p>\n<ul>\n<li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</li>\n<li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段。</li>\n</ul>\n<p>Keep-Alive的<strong>建立过程</strong>：</p>\n<ul>\n<li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li>\n<li>服务器收到请求并处理 Connection字段</li>\n<li>服务器回送Connection:Keep-Alive字段给客户端</li>\n<li>客户端接收到Connection字段</li>\n<li>Keep-Alive连接建立成功</li>\n</ul>\n<p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p>\n<ul>\n<li>客户端向服务器只是发送内容报文（不包含Connection字段）</li>\n<li>服务器收到请求并处理</li>\n<li>服务器返回客户端请求的资源并关闭连接</li>\n<li>客户端接收资源，发现没有Connection字段，断开连接</li>\n</ul>\n<p><strong>客户端请求断开连接过程</strong>：</p>\n<ul>\n<li>客户端向服务器发送Connection:close字段</li>\n<li>服务器收到请求并处理connection字段</li>\n<li>服务器回送响应资源并断开连接</li>\n<li>客户端接收资源并断开连接</li>\n</ul>\n<p>开启Keep-Alive的<strong>优点：</strong></p>\n<ul>\n<li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li>\n<li>允许请求和应答的HTTP管线化；</li>\n<li>降低拥塞控制 （TCP连接减少了）；</li>\n<li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li>\n<li>报告错误⽆需关闭TCP连；</li>\n</ul>\n<p>开启Keep-Alive的<strong>缺点</strong>：</p>\n<ul>\n<li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li>\n</ul>\n<h3 id=\"13-页面有多张图片，HTTP是怎样的加载表现？\"><a href=\"#13-页面有多张图片，HTTP是怎样的加载表现？\" class=\"headerlink\" title=\"13. 页面有多张图片，HTTP是怎样的加载表现？\"></a>13. 页面有多张图片，HTTP是怎样的加载表现？</h3><ul>\n<li>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li>\n<li>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</li>\n</ul>\n<h3 id=\"14-HTTP2的头部压缩算法是怎样的？\"><a href=\"#14-HTTP2的头部压缩算法是怎样的？\" class=\"headerlink\" title=\"14. HTTP2的头部压缩算法是怎样的？\"></a>14. HTTP2的头部压缩算法是怎样的？</h3><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>\n<p>具体来说:</p>\n<ul>\n<li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li>\n<li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li>\n<li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li>\n</ul>\n<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bda10d6c69e74996b6505777d29b9a74~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<h3 id=\"15-HTTP请求报文的是什么样的？\"><a href=\"#15-HTTP请求报文的是什么样的？\" class=\"headerlink\" title=\"15. HTTP请求报文的是什么样的？\"></a>15. HTTP请求报文的是什么样的？</h3><p>请求报⽂有4部分组成:</p>\n<ul>\n<li>请求⾏</li>\n<li>请求头部</li>\n<li>空⾏</li>\n<li>请求体</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb5bb2cb1664850b52e32d57af74f2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image.png\"> <strong>其中：</strong> （1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 （2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔</p>\n<ul>\n<li>User-Agent：产⽣请求的浏览器类型。</li>\n<li>Accept：客户端可识别的内容类型列表。</li>\n<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li>\n</ul>\n<p>（3）请求体: post put等请求携带的数据 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eacc55d7152149e99730346f1edfc9ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image.png\"></p>\n<h3 id=\"16-HTTP响应报文的是什么样的？\"><a href=\"#16-HTTP响应报文的是什么样的？\" class=\"headerlink\" title=\"16. HTTP响应报文的是什么样的？\"></a>16. HTTP响应报文的是什么样的？</h3><p>请求报⽂有4部分组成:</p>\n<ul>\n<li>响应⾏</li>\n<li>响应头</li>\n<li>空⾏</li>\n<li>响应体</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0183eb91ce451aa17bd515d047062d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image.png\"></p>\n<ul>\n<li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。</li>\n<li>响应头：响应部⾸组成</li>\n<li>响应体：服务器响应的数据</li>\n</ul>\n<h3 id=\"17-HTTP协议的优点和缺点\"><a href=\"#17-HTTP协议的优点和缺点\" class=\"headerlink\" title=\"17. HTTP协议的优点和缺点\"></a>17. HTTP协议的优点和缺点</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p>\n<p>HTTP协议具有以下<strong>优点</strong>：</p>\n<ul>\n<li>支持客户端/服务器模式</li>\n<li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li>\n<li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li>\n<li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li>\n<li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li>\n</ul>\n<p>HTTP协议具有以下<strong>缺点</strong>：</p>\n<ul>\n<li><strong>无状态：</strong> HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li>\n<li><strong>明文传输：</strong> 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li>\n<li><strong>不安全</strong></li>\n</ul>\n<p>（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；</p>\n<h3 id=\"18-说一下HTTP-3-0\"><a href=\"#18-说一下HTTP-3-0\" class=\"headerlink\" title=\"18. 说一下HTTP 3.0\"></a>18. 说一下HTTP 3.0</h3><p>HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a0a2ec0ef143b49d79256cea543418~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<ol>\n<li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li>\n<li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li>\n<li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48df233ce8e541efa165160c169b7a70~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<ol>\n<li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li>\n</ol>\n<h3 id=\"19-HTTP协议的性能怎么样\"><a href=\"#19-HTTP协议的性能怎么样\" class=\"headerlink\" title=\"19. HTTP协议的性能怎么样\"></a>19. HTTP协议的性能怎么样</h3><p>HTTP 协议是基于 TCP/IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p>\n<ul>\n<li><strong>长连接</strong></li>\n</ul>\n<p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p>\n<p>对于不同版本的采用不同的连接方式：</p>\n<ul>\n<li>在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</li>\n<li>在HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f756e23ecf3a4d2a80d632b5fa8b0b6d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<ul>\n<li><strong>管道网络传输</strong></li>\n</ul>\n<p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p>\n<p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p>\n<ul>\n<li><strong>队头堵塞</strong></li>\n</ul>\n<p>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。</p>\n<p><strong>队头阻塞的解决方案：</strong> （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p>\n<h3 id=\"20-URL有哪些组成部分\"><a href=\"#20-URL有哪些组成部分\" class=\"headerlink\" title=\"20. URL有哪些组成部分\"></a>20. URL有哪些组成部分</h3><p>以下面的URL为例：**<a href=\"https://link.juejin.cn/?target=http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1%23name\">www.aspxfans.com:8080/news/index.…</a>**</p>\n<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>\n<ul>\n<li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符；</li>\n<li><strong>域名部分</strong>：该URL的域名部分为“<a href=\"https://link.juejin.cn/?target=http://www.aspxfans.com%E2%80%9D%E3%80%82%E4%B8%80%E4%B8%AAURL%E4%B8%AD%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8IP%E5%9C%B0%E5%9D%80%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%90%8D%E4%BD%BF%E7%94%A8\">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li>\n<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li>\n<li><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</li>\n<li><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li>\n<li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li>\n<li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>\n</ul>\n<h3 id=\"21-与缓存相关的HTTP请求头有哪些\"><a href=\"#21-与缓存相关的HTTP请求头有哪些\" class=\"headerlink\" title=\"21. 与缓存相关的HTTP请求头有哪些\"></a>21. 与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p>\n<ul>\n<li>Expires</li>\n<li>Cache-Control</li>\n</ul>\n<p>协商缓存：</p>\n<ul>\n<li>Etag、If-None-Match</li>\n<li>Last-Modified、If-Modified-Since</li>\n</ul>\n<h2 id=\"二、HTTPS协议\"><a href=\"#二、HTTPS协议\" class=\"headerlink\" title=\"二、HTTPS协议\"></a>二、HTTPS协议</h2><h3 id=\"1-什么是HTTPS协议？\"><a href=\"#1-什么是HTTPS协议？\" class=\"headerlink\" title=\"1. 什么是HTTPS协议？\"></a>1. 什么是HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>\n<p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p>\n<h3 id=\"2-TLS-SSL的工作原理\"><a href=\"#2-TLS-SSL的工作原理\" class=\"headerlink\" title=\"2. TLS/SSL的工作原理\"></a>2. TLS/SSL的工作原理</h3><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>\n<p>TLS/SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p>\n<ul>\n<li>基于散列函数验证信息的完整性</li>\n<li>对称加密算法采用协商的秘钥对数据加密</li>\n<li>非对称加密实现身份认证和秘钥协商</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5696ee8ccb0d44b08b812a7c964695b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<h4 id=\"（1）散列函数hash\"><a href=\"#（1）散列函数hash\" class=\"headerlink\" title=\"（1）散列函数hash\"></a>（1）散列函数hash</h4><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p>\n<p><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p>\n<h4 id=\"（2）对称加密\"><a href=\"#（2）对称加密\" class=\"headerlink\" title=\"（2）对称加密\"></a>（2）对称加密</h4><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>\n<p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p>\n<p><strong>特点：</strong> 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p>\n<h4 id=\"（3）非对称加密\"><a href=\"#（3）非对称加密\" class=\"headerlink\" title=\"（3）非对称加密\"></a>（3）非对称加密</h4><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p>\n<p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p>\n<p><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p>\n<p>综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p>\n<h3 id=\"3-数字证书是什么？\"><a href=\"#3-数字证书是什么？\" class=\"headerlink\" title=\"3. 数字证书是什么？\"></a>3. 数字证书是什么？</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p>\n<p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>\n<p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90da1f506e7040aaba5e1536c1f6c373~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<h3 id=\"4-HTTPS通信（握手）过程\"><a href=\"#4-HTTPS通信（握手）过程\" class=\"headerlink\" title=\"4. HTTPS通信（握手）过程\"></a>4. HTTPS通信（握手）过程</h3><p>HTTPS的通信过程如下：</p>\n<ol>\n<li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>\n<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>\n<li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>\n<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>\n<li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li>\n</ol>\n<h3 id=\"5-HTTPS的特点\"><a href=\"#5-HTTPS的特点\" class=\"headerlink\" title=\"5. HTTPS的特点\"></a>5. HTTPS的特点</h3><p>HTTPS的<strong>优点</strong>如下：</p>\n<ul>\n<li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li>\n<li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li>\n<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li>\n</ul>\n<p>HTTPS的<strong>缺点</strong>如下：</p>\n<ul>\n<li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li>\n<li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li>\n<li>SSL证书是收费的，功能越强大的证书费用越高；</li>\n<li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li>\n<li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li>\n</ul>\n<h3 id=\"6-HTTPS是如何保证安全的？\"><a href=\"#6-HTTPS是如何保证安全的？\" class=\"headerlink\" title=\"6. HTTPS是如何保证安全的？\"></a>6. <strong>HTTPS</strong>是如何保证安全的？</h3><p>先理解两个概念：</p>\n<ul>\n<li>对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。</li>\n<li>⾮对称加密：</li>\n</ul>\n<ol>\n<li>私钥 + 公钥= 密钥对</li>\n<li>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</li>\n<li>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</li>\n<li>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</li>\n</ol>\n<p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p>\n<p><strong>解决⽅案：</strong></p>\n<p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。</p>\n<p>此时⼜带来⼀个问题，中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。</p>\n<p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p>\n<p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。</p>\n<p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。</p>\n<h2 id=\"三、HTTP状态码\"><a href=\"#三、HTTP状态码\" class=\"headerlink\" title=\"三、HTTP状态码\"></a>三、HTTP状态码</h2><p>状态码的类别：</p>\n<table>\n<thead>\n<tr>\n<th><strong>类别</strong></th>\n<th><strong>原因</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1xx</td>\n<td>Informational(信息性状态码)</td>\n<td>接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2xx</td>\n<td>Success(成功状态码)</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3xx</td>\n<td>Redirection(重定向状态码)</td>\n<td>需要进行附加操作一完成请求</td>\n</tr>\n<tr>\n<td>4xx</td>\n<td>Client Error (客户端错误状态码)</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5xx</td>\n<td>Server Error(服务器错误状态码)</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-2XX-Success-成功状态码\"><a href=\"#1-2XX-Success-成功状态码\" class=\"headerlink\" title=\"1. 2XX (Success 成功状态码)\"></a>1. 2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了。</p>\n<h4 id=\"（1）200-OK\"><a href=\"#（1）200-OK\" class=\"headerlink\" title=\"（1）200 OK\"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了。</p>\n<h4 id=\"（2）204-No-Content\"><a href=\"#（2）204-No-Content\" class=\"headerlink\" title=\"（2）204 No Content\"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p>\n<h4 id=\"（3）206-Partial-Content\"><a href=\"#（3）206-Partial-Content\" class=\"headerlink\" title=\"（3）206 Partial Content\"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>\n<h3 id=\"2-3XX-Redirection-重定向状态码\"><a href=\"#2-3XX-Redirection-重定向状态码\" class=\"headerlink\" title=\"2. 3XX (Redirection 重定向状态码)\"></a>2. 3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>\n<h4 id=\"（1）301-Moved-Permanently\"><a href=\"#（1）301-Moved-Permanently\" class=\"headerlink\" title=\"（1）301 Moved Permanently\"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong> 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li>\n<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>\n</ul>\n<h4 id=\"（2）302-Found\"><a href=\"#（2）302-Found\" class=\"headerlink\" title=\"（2）302 Found\"></a>（2）302 Found</h4><p><strong>临时重定向。</strong> 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li>\n<li>未登陆的用户访问用户中心重定向到登录页面。</li>\n<li>访问404页面重新定向到首页。</li>\n</ul>\n<h4 id=\"（3）303-See-Other\"><a href=\"#（3）303-See-Other\" class=\"headerlink\" title=\"（3）303 See Other\"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。</p>\n<p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p>\n<p>注意：</p>\n<ul>\n<li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li>\n<li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li>\n</ul>\n<h4 id=\"（4）304-Not-Modified\"><a href=\"#（4）304-Not-Modified\" class=\"headerlink\" title=\"（4）304 Not Modified\"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong> 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p>\n<p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p>\n<p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p>\n<h4 id=\"（5）307-Temporary-Redirect\"><a href=\"#（5）307-Temporary-Redirect\" class=\"headerlink\" title=\"（5）307 Temporary Redirect\"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong> 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p>\n<p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p>\n<h3 id=\"3-4XX-Client-Error-客户端错误状态码\"><a href=\"#3-4XX-Client-Error-客户端错误状态码\" class=\"headerlink\" title=\"3. 4XX (Client Error 客户端错误状态码)\"></a>3. 4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>\n<h4 id=\"（1）400-Bad-Request\"><a href=\"#（1）400-Bad-Request\" class=\"headerlink\" title=\"（1）400 Bad Request\"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>\n<h4 id=\"（2）401-Unauthorized\"><a href=\"#（2）401-Unauthorized\" class=\"headerlink\" title=\"（2）401 Unauthorized\"></a>（2）401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</p>\n<p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>\n<p>以下情况会出现401：</p>\n<ul>\n<li>401.1 - 登录失败。</li>\n<li>401.2 - 服务器配置导致登录失败。</li>\n<li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li>\n<li>401.4 - 筛选器授权失败。</li>\n<li>401.5 - ISAPI/CGI 应用程序授权失败。</li>\n<li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li>\n</ul>\n<h4 id=\"（3）403-Forbidden\"><a href=\"#（3）403-Forbidden\" class=\"headerlink\" title=\"（3）403 Forbidden\"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。</p>\n<p>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</p>\n<ul>\n<li>403.1 - 执行访问被禁止。</li>\n<li>403.2 - 读访问被禁止。</li>\n<li>403.3 - 写访问被禁止。</li>\n<li>403.4 - 要求 SSL。</li>\n<li>403.5 - 要求 SSL 128。</li>\n<li>403.6 - IP 地址被拒绝。</li>\n<li>403.7 - 要求客户端证书。</li>\n<li>403.8 - 站点访问被拒绝。</li>\n<li>403.9 - 用户数过多。</li>\n<li>403.10 - 配置无效。</li>\n<li>403.11 - 密码更改。</li>\n<li>403.12 - 拒绝访问映射表。</li>\n<li>403.13 - 客户端证书被吊销。</li>\n<li>403.14 - 拒绝目录列表。</li>\n<li>403.15 - 超出客户端访问许可。</li>\n<li>403.16 - 客户端证书不受信任或无效。</li>\n<li>403.17 - 客户端证书已过期或尚未生效</li>\n<li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li>\n<li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li>\n<li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li>\n</ul>\n<h4 id=\"（4）404-Not-Found\"><a href=\"#（4）404-Not-Found\" class=\"headerlink\" title=\"（4）404 Not Found\"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：</p>\n<ul>\n<li>404.0 -（无） – 没有找到文件或目录。</li>\n<li>404.1 - 无法在所请求的端口上访问 Web 站点。</li>\n<li>404.2 - Web 服务扩展锁定策略阻止本请求。</li>\n<li>404.3 - MIME 映射策略阻止本请求。</li>\n</ul>\n<h4 id=\"（5）405-Method-Not-Allowed\"><a href=\"#（5）405-Method-Not-Allowed\" class=\"headerlink\" title=\"（5）405 Method Not Allowed\"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Access<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Methods<span class=\"token operator\">:</span> <span class=\"token constant\">GET</span><span class=\"token punctuation\">,</span><span class=\"token constant\">HEAD</span><span class=\"token punctuation\">,</span><span class=\"token constant\">PUT</span><span class=\"token punctuation\">,</span><span class=\"token constant\">PATCH</span><span class=\"token punctuation\">,</span><span class=\"token constant\">POST</span><span class=\"token punctuation\">,</span><span class=\"token constant\">DELETE</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-5XX-Server-Error-服务器错误状态码\"><a href=\"#4-5XX-Server-Error-服务器错误状态码\" class=\"headerlink\" title=\"4. 5XX (Server Error 服务器错误状态码)\"></a>4. 5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p>\n<h4 id=\"（1）500-Internal-Server-Error\"><a href=\"#（1）500-Internal-Server-Error\" class=\"headerlink\" title=\"（1）500 Internal Server Error\"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>\n<h4 id=\"（2）502-Bad-Gateway\"><a href=\"#（2）502-Bad-Gateway\" class=\"headerlink\" title=\"（2）502 Bad Gateway\"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p>\n<ul>\n<li>502.1 - CGI （通用网关接口）应用程序超时。</li>\n<li>502.2 - CGI （通用网关接口）应用程序出错。</li>\n</ul>\n<h4 id=\"（3）503-Service-Unavailable\"><a href=\"#（3）503-Service-Unavailable\" class=\"headerlink\" title=\"（3）503 Service Unavailable\"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>服务器停机维护时，主动用503响应请求；</li>\n<li>nginx 设置限速，超过限速，会返回503。</li>\n</ul>\n<h4 id=\"（4）504-Gateway-Timeout\"><a href=\"#（4）504-Gateway-Timeout\" class=\"headerlink\" title=\"（4）504 Gateway Timeout\"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。</p>\n<p>使用场景：代码执行时间超时，或者发生了死循环。</p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p><strong>（1）2XX 成功</strong></p>\n<ul>\n<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>\n<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>\n<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>\n<li>206 Partial Content，进行范围请求</li>\n</ul>\n<p><strong>（2）3XX 重定向</strong></p>\n<ul>\n<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>\n<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>\n<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>\n<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>\n<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li>\n</ul>\n<p><strong>（3）4XX 客户端错误</strong></p>\n<ul>\n<li>400 bad request，请求报文存在语法错误</li>\n<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n<li>404 not found，表示在服务器上没有找到请求的资源</li>\n</ul>\n<p><strong>（4）5XX 服务器错误</strong></p>\n<ul>\n<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>\n<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>\n<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>\n</ul>\n<h3 id=\"6-同样是重定向，307，303，302的区别？\"><a href=\"#6-同样是重定向，307，303，302的区别？\" class=\"headerlink\" title=\"6. 同样是重定向，307，303，302的区别？\"></a>6. 同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。</p>\n<h2 id=\"四、DNS协议介绍\"><a href=\"#四、DNS协议介绍\" class=\"headerlink\" title=\"四、DNS协议介绍\"></a>四、DNS协议介绍</h2><h3 id=\"1-DNS-协议是什么\"><a href=\"#1-DNS-协议是什么\" class=\"headerlink\" title=\"1. DNS 协议是什么\"></a>1. DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>\n<p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>\n<h3 id=\"2-DNS同时使用TCP和UDP协议？\"><a href=\"#2-DNS同时使用TCP和UDP协议？\" class=\"headerlink\" title=\"2. DNS同时使用TCP和UDP协议？\"></a>2. DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong> （1）在区域传输的时候使用TCP协议</p>\n<ul>\n<li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li>\n<li>TCP是一种可靠连接，保证了数据的准确性。</li>\n</ul>\n<p>（2）在域名解析的时候使用UDP协议</p>\n<ul>\n<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>\n</ul>\n<h3 id=\"3-DNS完整的查询过程\"><a href=\"#3-DNS完整的查询过程\" class=\"headerlink\" title=\"3. DNS完整的查询过程\"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p>\n<ul>\n<li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>\n<li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>\n<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>\n<li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>\n<li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>\n<li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li>\n<li>本地DNS服务器将返回结果返回给浏览器</li>\n</ul>\n<p>比如要查询 <a href=\"https://link.juejin.cn/?target=http://www.baidu.com/\">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p>\n<h3 id=\"4-迭代查询与递归查询\"><a href=\"#4-迭代查询与递归查询\" class=\"headerlink\" title=\"4. 迭代查询与递归查询\"></a>4. 迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>\n<ul>\n<li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li>\n<li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li>\n</ul>\n<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>\n<h3 id=\"5-DNS-记录和报文\"><a href=\"#5-DNS-记录和报文\" class=\"headerlink\" title=\"5. DNS 记录和报文\"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">（Name，Value，Type，TTL）\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p>\n<p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p>\n<ul>\n<li>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>\n<li>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>\n<li>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>\n<li>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>\n</ul>\n<h2 id=\"五、网络模型\"><a href=\"#五、网络模型\" class=\"headerlink\" title=\"五、网络模型\"></a>五、网络模型</h2><h3 id=\"1-OSI七层模型\"><a href=\"#1-OSI七层模型\" class=\"headerlink\" title=\"1. OSI七层模型\"></a>1. OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e8e168d9f249788c74c5b50e0528e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<h4 id=\"（1）应用层\"><a href=\"#（1）应用层\" class=\"headerlink\" title=\"（1）应用层\"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p>\n<ul>\n<li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li>\n<li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘``迅雷</code>应该是基于此协议的。</li>\n<li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li>\n</ul>\n<h4 id=\"（2）表示层\"><a href=\"#（2）表示层\" class=\"headerlink\" title=\"（2）表示层\"></a>（2）表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>\n<p>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p>\n<h4 id=\"（3）会话层\"><a href=\"#（3）会话层\" class=\"headerlink\" title=\"（3）会话层\"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>\n<h4 id=\"（4）传输层\"><a href=\"#（4）传输层\" class=\"headerlink\" title=\"（4）传输层\"></a>（4）传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p>\n<h4 id=\"（5）网络层\"><a href=\"#（5）网络层\" class=\"headerlink\" title=\"（5）网络层\"></a>（5）网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p>\n<h4 id=\"（6）数据链路层\"><a href=\"#（6）数据链路层\" class=\"headerlink\" title=\"（6）数据链路层\"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p>\n<h4 id=\"（7）物理层\"><a href=\"#（7）物理层\" class=\"headerlink\" title=\"（7）物理层\"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>\n<p><strong>OSI七层模型通信特点：对等通信</strong> 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>\n<h3 id=\"2-TCP-IP五层协议\"><a href=\"#2-TCP-IP五层协议\" class=\"headerlink\" title=\"2. TCP/IP五层协议\"></a>2. TCP/IP五层协议</h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48cd77d608714c298366f4dac77f33fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<ul>\n<li><p>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</p>\n</li>\n<li><p>传输层 (transport layer)</p>\n<p>：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：</p>\n<ul>\n<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>\n<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>\n</ul>\n</li>\n<li><p>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</p>\n</li>\n<li><p>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p>\n</li>\n<li><p>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</p>\n</li>\n</ul>\n<p>从上图中可以看出，<code>TCP/IP</code>模型比<code>OSI</code>模型更加简洁，它把<code>应用层/表示层/会话层</code>全部整合为了<code>应用层</code>。</p>\n<p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a89b9ddb9d541a880fee0dccd1c03e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db9226a6cdb4ee48daecd9bc4181b64~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c0d79ff592242a8af294ce32177c8e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image.png\"></p>\n<h2 id=\"六、TCP与UDP\"><a href=\"#六、TCP与UDP\" class=\"headerlink\" title=\"六、TCP与UDP\"></a>六、TCP与UDP</h2><h3 id=\"1-TCP-和-UDP的概念及特点\"><a href=\"#1-TCP-和-UDP的概念及特点\" class=\"headerlink\" title=\"1. TCP 和 UDP的概念及特点\"></a>1. TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：</p>\n<p><strong>（1）UDP</strong></p>\n<p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>\n<p>它的特点如下：</p>\n<p><strong>1）面向无连接</strong></p>\n<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>\n<p>具体来说就是：</p>\n<ul>\n<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>\n<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>\n</ul>\n<p><strong>2）有单播，多播，广播的功能</strong></p>\n<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>\n<p><strong>3）面向报文</strong></p>\n<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>\n<p><strong>4）不可靠性</strong></p>\n<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>\n<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>\n<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>\n<p><strong>5）头部开销小，传输数据报文时是很高效的。</strong> <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14d246d14aac47919989fc620fbb17dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>UDP 头部包含了以下几个数据：</p>\n<ul>\n<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>\n<li>整个数据报文的长度</li>\n<li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li>\n</ul>\n<p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p>\n<p><strong>（2）TCP</strong> TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p>\n<p>它有以下几个特点：</p>\n<p><strong>1）面向连接</strong></p>\n<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>\n<p><strong>2）仅支持单播传输</strong></p>\n<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>\n<p><strong>3）面向字节流</strong></p>\n<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>\n<p><strong>4）可靠传输</strong></p>\n<p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>\n<p><strong>5）提供拥塞控制</strong></p>\n<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p>\n<p><strong>6）提供全双工通信</strong></p>\n<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>\n<h3 id=\"2-TCP和UDP的区别\"><a href=\"#2-TCP和UDP的区别\" class=\"headerlink\" title=\"2. TCP和UDP的区别\"></a>2. TCP和UDP的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否连接</td>\n<td>无连接</td>\n<td>面向连接</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>不可靠传输，不使用流量控制和拥塞控制</td>\n<td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td>连接对象个数</td>\n<td>支持一对一，一对多，多对一和多对多交互通信</td>\n<td>只能是一对一通信</td>\n</tr>\n<tr>\n<td>传输方式</td>\n<td>面向报文</td>\n<td>面向字节流</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>首部开销小，仅8字节</td>\n<td>首部最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>适用于实时应用，例如视频会议、直播</td>\n<td>适用于要求可靠传输的应用，例如文件传输</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-TCP和UDP的使用场景\"><a href=\"#3-TCP和UDP的使用场景\" class=\"headerlink\" title=\"3. TCP和UDP的使用场景\"></a>3. TCP和UDP的使用场景</h3><ul>\n<li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>\n<li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>\n</ul>\n<h3 id=\"4-UDP协议为什么不可靠？\"><a href=\"#4-UDP协议为什么不可靠？\" class=\"headerlink\" title=\"4. UDP协议为什么不可靠？\"></a>4. UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>\n<ul>\n<li>不保证消息交付：不确认，不重传，无超时</li>\n<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>\n<li>不跟踪连接状态：不必建立连接或重启状态机</li>\n<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>\n</ul>\n<h3 id=\"5-TCP的重传机制\"><a href=\"#5-TCP的重传机制\" class=\"headerlink\" title=\"5. TCP的重传机制\"></a>5. TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p>\n<p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>\n<h3 id=\"6-TCP的拥塞控制机制\"><a href=\"#6-TCP的拥塞控制机制\" class=\"headerlink\" title=\"6. TCP的拥塞控制机制\"></a>6. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p>\n<ul>\n<li>慢启动（慢开始）</li>\n<li>拥塞避免</li>\n<li>快速重传</li>\n<li>快速恢复</li>\n</ul>\n<p><strong>（1）慢启动（慢开始）</strong></p>\n<ul>\n<li>在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）</li>\n<li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li>\n<li>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)<ul>\n<li>当cnwd &lt; ssthresh，使用慢开始算法</li>\n<li>当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>\n<li>当cnwd &gt; ssthresh，使用拥塞避免算法</li>\n</ul>\n</li>\n</ul>\n<p><strong>（2）拥塞避免</strong></p>\n<ul>\n<li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li>\n<li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li>\n<li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示: <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06b60b174bb242b498d244002caded1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li>\n</ul>\n<p><strong>（3）快速重传</strong></p>\n<ul>\n<li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>\n<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li>\n</ul>\n<p><strong>（4）快速恢复</strong></p>\n<ul>\n<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>\n<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f5339da8c741d19f416cac2af18e4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></li>\n</ul>\n<h3 id=\"7-TCP的流量控制机制\"><a href=\"#7-TCP的流量控制机制\" class=\"headerlink\" title=\"7. TCP的流量控制机制\"></a>7. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p>\n<ul>\n<li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li>\n<li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li>\n<li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li>\n<li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li>\n</ul>\n<h3 id=\"8-TCP的可靠传输机制\"><a href=\"#8-TCP的可靠传输机制\" class=\"headerlink\" title=\"8. TCP的可靠传输机制\"></a>8. TCP的可靠传输机制</h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>\n<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p>\n<p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p>\n<p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p>\n<p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p>\n<h3 id=\"9-TCP的三次握手和四次挥手\"><a href=\"#9-TCP的三次握手和四次挥手\" class=\"headerlink\" title=\"9. TCP的三次握手和四次挥手\"></a>9. TCP的三次握手和四次挥手</h3><h4 id=\"（1）三次握手\"><a href=\"#（1）三次握手\" class=\"headerlink\" title=\"（1）三次握手\"></a>（1）三次握手</h4><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55a81db348584e57abdd01c9555f1d5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>\n<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>\n<ul>\n<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p></blockquote>\n<ul>\n<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y</p></blockquote>\n<ul>\n<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></blockquote>\n<p><strong>那为什么要三次握手呢？两次不行吗？</strong></p>\n<ul>\n<li>为了确认双方的接收能力和发送能力都正常</li>\n<li>如果是用两次握手，则会出现下面这种情况：</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote>\n<p><strong>简单来说就是以下三步：</strong></p>\n<ul>\n<li><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>\n<li><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>\n<li><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>\n</ul>\n<p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p>\n<h4 id=\"（2）四次挥手\"><a href=\"#（2）四次挥手\" class=\"headerlink\" title=\"（2）四次挥手\"></a>（2）四次挥手</h4><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4190d0d324b427cb63154d3f84e47bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>\n<ul>\n<li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p></blockquote>\n<ul>\n<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p></blockquote>\n<ul>\n<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p></blockquote>\n<ul>\n<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p></blockquote>\n<p><strong>那为什么需要四次挥手呢？</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p></blockquote>\n<p><strong>简单来说就是以下四步：</strong></p>\n<ul>\n<li><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>\n<li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>\n<li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>\n<li><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>\n</ul>\n<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>\n<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p>\n<h3 id=\"10-TCP粘包是怎么回事，如何处理\"><a href=\"#10-TCP粘包是怎么回事，如何处理\" class=\"headerlink\" title=\"10. TCP粘包是怎么回事，如何处理?\"></a>10. TCP粘包是怎么回事，如何处理?</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.</p>\n<p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p>\n<p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: A. 先接收到 data1, 然后接收到 data2 . B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. D. ⼀次性接收到了 data1 和 data2 的全部数据.</p>\n<p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:</p>\n<ul>\n<li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li>\n<li><strong>关闭 Nagle 算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</li>\n<li><strong>进⾏封包/拆包：</strong> 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</li>\n</ul>\n<h3 id=\"11-为什么udp不会粘包？\"><a href=\"#11-为什么udp不会粘包？\" class=\"headerlink\" title=\"11. 为什么udp不会粘包？\"></a>11. 为什么<strong>udp</strong>不会粘包？</h3><ul>\n<li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li>\n<li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li>\n</ul>\n<h2 id=\"七、WebSocket\"><a href=\"#七、WebSocket\" class=\"headerlink\" title=\"七、WebSocket\"></a>七、WebSocket</h2><h3 id=\"1-对-WebSocket-的理解\"><a href=\"#1-对-WebSocket-的理解\" class=\"headerlink\" title=\"1. 对 WebSocket 的理解\"></a>1. 对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p>\n<p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p>\n<p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。 </p>\n<p><strong>WebSocket 特点的如下：</strong></p>\n<ul>\n<li>支持双向通信，实时性更强</li>\n<li>可以发送文本，也可以发送二进制数据‘’</li>\n<li>建立在TCP协议之上，服务端的实现比较容易</li>\n<li>数据格式比较轻量，性能开销小，通信高效</li>\n<li>没有同源限制，客户端可以与任意服务器通信</li>\n<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>\n<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>\n</ul>\n<p><strong>Websocket的使用方法如下：</strong> </p>\n<p>在客户端中：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span>\n<span class=\"token keyword\">let</span> ws <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ws://localhost:9999'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 在客户端与服务端建立连接后触发</span>\nws<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onopen</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Connection open.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    ws<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 在服务端给客户端发来消息的时候触发</span>\nws<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onmessage</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 打印的是MessageEvent对象</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 打印的是收到的消息</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 在客户端与服务端建立关闭后触发</span>\nws<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onclose</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">evt</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Connection closed.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> \n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？\"><a href=\"#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？\" class=\"headerlink\" title=\"2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？\"></a>2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p>\n<p><strong>短轮询的基本思路：</strong> 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>\n<p><strong>长轮询的基本思路：</strong> 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>\n<p><strong>SSE 的基本思想：</strong> 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p>\n<p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p>\n<p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p>\n<p>对于这四种即使通信协议，从性能的角度来看： <strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong> 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： <strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong> 所以，还是要根据具体的使用场景来判断使用哪种方式。</p>\n<h2 id=\"浏览器原理\"><a href=\"#浏览器原理\" class=\"headerlink\" title=\"浏览器原理\"></a>浏览器原理</h2><h2 id=\"一、浏览器安全\"><a href=\"#一、浏览器安全\" class=\"headerlink\" title=\"一、浏览器安全\"></a>一、浏览器安全</h2><h3 id=\"1-什么是-XSS-攻击？\"><a href=\"#1-什么是-XSS-攻击？\" class=\"headerlink\" title=\"1.  什么是 XSS 攻击？\"></a>1.  什么是 XSS 攻击？</h3><h4 id=\"（1）概念\"><a href=\"#（1）概念\" class=\"headerlink\" title=\"（1）概念\"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>\n<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>\n<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>\n<ul>\n<li>获取页面的数据，如DOM、cookie、localStorage；</li>\n<li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>\n<li>破坏页面结构；</li>\n<li>流量劫持（将链接指向某网站）；</li>\n</ul>\n<h4 id=\"（2）攻击类型\"><a href=\"#（2）攻击类型\" class=\"headerlink\" title=\"（2）攻击类型\"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p>\n<ul>\n<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>\n<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li>\n<li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li>\n</ul>\n<p><strong>1）存储型 XSS 的攻击步骤：</strong></p>\n<ol>\n<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li>\n<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>\n<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>\n<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>\n</ol>\n<p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p>\n<p><strong>2）反射型 XSS 的攻击步骤：</strong></p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>\n<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>\n<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>\n</ol>\n<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p>\n<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>\n<p><strong>3）DOM 型 XSS 的攻击步骤：</strong></p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>⽤户打开带有恶意代码的 URL。</li>\n<li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li>\n<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>\n</ol>\n<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>\n<h3 id=\"2-如何防御-XSS-攻击？\"><a href=\"#2-如何防御-XSS-攻击？\" class=\"headerlink\" title=\"2. 如何防御 XSS 攻击？\"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p>\n<ul>\n<li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li>\n<li>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li>\n<li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 </li>\n</ol></blockquote>\n<ul>\n<li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li>\n</ul>\n<h3 id=\"3-什么是-CSRF-攻击？\"><a href=\"#3-什么是-CSRF-攻击？\" class=\"headerlink\" title=\"3. 什么是 CSRF 攻击？\"></a>3. 什么是 CSRF 攻击？</h3><h4 id=\"（1）概念-1\"><a href=\"#（1）概念-1\" class=\"headerlink\" title=\"（1）概念\"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>\n<p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>\n<h4 id=\"（2）攻击类型-1\"><a href=\"#（2）攻击类型-1\" class=\"headerlink\" title=\"（2）攻击类型\"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p>\n<ul>\n<li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>\n<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>\n<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>\n</ul>\n<h3 id=\"4-如何防御-CSRF-攻击？\"><a href=\"#4-如何防御-CSRF-攻击？\" class=\"headerlink\" title=\"4. 如何防御 CSRF 攻击？\"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>\n<ul>\n<li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li>\n<li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li>\n<li><strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>\n<li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>\n</ul>\n<h3 id=\"5-什么是中间人攻击？如何防范中间人攻击？\"><a href=\"#5-什么是中间人攻击？如何防范中间人攻击？\" class=\"headerlink\" title=\"5. 什么是中间人攻击？如何防范中间人攻击？\"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>\n<p>攻击过程如下:</p>\n<ul>\n<li>客户端发送请求到服务端，请求被中间⼈截获</li>\n<li>服务器向客户端发送公钥</li>\n<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li>\n<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li>\n<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li>\n<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li>\n</ul>\n<h3 id=\"6-有哪些可能引起前端安全的问题\"><a href=\"#6-有哪些可能引起前端安全的问题\" class=\"headerlink\" title=\"6. 有哪些可能引起前端安全的问题?\"></a>6. 有哪些可能引起前端安全的问题?</h3><ul>\n<li>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；</li>\n<li>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li>\n<li>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</li>\n<li>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li>\n</ul>\n<h3 id=\"7-网络劫持有哪几种，如何防范？\"><a href=\"#7-网络劫持有哪几种，如何防范？\" class=\"headerlink\" title=\"7. 网络劫持有哪几种，如何防范？\"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种:</p>\n<p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p>\n<ul>\n<li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>\n<li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li>\n</ul>\n<p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p>\n<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>\n<h2 id=\"二、进程与线程\"><a href=\"#二、进程与线程\" class=\"headerlink\" title=\"二、进程与线程\"></a>二、进程与线程</h2><h3 id=\"1-进程与线程的概念\"><a href=\"#1-进程与线程的概念\" class=\"headerlink\" title=\"1. 进程与线程的概念\"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>\n<ul>\n<li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>\n<li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li>\n</ul>\n<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>\n<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p>\n<p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p>\n<p>进程和线程之间的关系有以下四个特点：</p>\n<p><strong>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>\n<p><strong>（2）线程之间共享进程中的数据。</strong></p>\n<p><strong>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong> 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>\n<p><strong>（4）进程之间的内容相互隔离。</strong> 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p>\n<p><strong>Chrome浏览器的架构图</strong>： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83e928a4f95d4ebe91d0881b5b2cf94b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 从图中可以看出，最新的 Chrome 浏览器包括：</p>\n<ul>\n<li>1 个浏览器主进程</li>\n<li>1 个 GPU 进程</li>\n<li>1 个网络进程</li>\n<li>多个渲染进程</li>\n<li>多个插件进程</li>\n</ul>\n<p>这些进程的功能：</p>\n<ul>\n<li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>\n<li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>\n<li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>\n<li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>\n<li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>\n</ul>\n<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>\n<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>\n<ul>\n<li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>\n<li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li>\n</ul>\n<h3 id=\"2-进程和线程的区别\"><a href=\"#2-进程和线程的区别\" class=\"headerlink\" title=\"2. 进程和线程的区别\"></a>2. 进程和线程的区别</h3><ul>\n<li>进程可以看做独立应用，线程不能</li>\n<li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li>\n<li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li>\n<li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>\n<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li>\n</ul>\n<h3 id=\"3-浏览器渲染进程的线程有哪些\"><a href=\"#3-浏览器渲染进程的线程有哪些\" class=\"headerlink\" title=\"3. 浏览器渲染进程的线程有哪些\"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6e583f59dc742b9b4e88cf3a3b0f1d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> <strong>（1）GUI渲染线程</strong> 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>\n<p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>\n<p><strong>（2）JS引擎线程</strong> JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>\n<p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n<p><strong>（3）时间触发线程</strong> <strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>\n<p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>\n<p><strong>（4）定时器触发进程</strong> <strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>\n<p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>\n<p><strong>（5）异步http请求线程</strong></p>\n<ul>\n<li>XMLHttpRequest连接后通过浏览器新开一个线程请求；</li>\n<li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li>\n</ul>\n<h3 id=\"4-进程之前的通信方式\"><a href=\"#4-进程之前的通信方式\" class=\"headerlink\" title=\"4. 进程之前的通信方式\"></a>4. 进程之前的通信方式</h3><p><strong>（1）管道通信</strong></p>\n<p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p>\n<p>管道的特点：</p>\n<ul>\n<li>只能单向通信</li>\n<li>只能血缘关系的进程进行通信</li>\n<li>依赖于文件系统</li>\n<li>生命周期随进程</li>\n<li>面向字节流的服务</li>\n<li>管道内部提供了同步机制</li>\n</ul>\n<p><strong>（2）消息队列通信</strong></p>\n<p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>\n<p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>\n<p><strong>（3）信号量通信</strong></p>\n<p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>\n<p><strong>（4）信号通信</strong></p>\n<p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p>\n<p><strong>（5）共享内存通信</strong></p>\n<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>\n<p><strong>（6）套接字通信</strong></p>\n<p>上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>\n<h3 id=\"5-僵尸进程和孤儿进程是什么？\"><a href=\"#5-僵尸进程和孤儿进程是什么？\" class=\"headerlink\" title=\"5. 僵尸进程和孤儿进程是什么？\"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul>\n<li><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>\n<li><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</li>\n</ul>\n<h3 id=\"6-死锁产生的原因？-如果解决死锁的问题？\"><a href=\"#6-死锁产生的原因？-如果解决死锁的问题？\" class=\"headerlink\" title=\"6. 死锁产生的原因？ 如果解决死锁的问题？\"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>\n<p>系统中的资源可以分为两类：</p>\n<ul>\n<li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>\n<li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>\n</ul>\n<p><strong>产生死锁的原因：</strong></p>\n<p><strong>（1）竞争资源</strong></p>\n<ul>\n<li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li>\n<li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li>\n</ul>\n<p><strong>（2）进程间推进顺序非法</strong></p>\n<p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>\n<p><strong>产生死锁的必要条件：</strong></p>\n<ul>\n<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>\n<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>\n<li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li>\n</ul>\n<p><strong>预防死锁的方法：</strong></p>\n<ul>\n<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>\n<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>\n<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>\n<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>\n</ul>\n<h3 id=\"7-如何实现浏览器内多个标签页之间的通信\"><a href=\"#7-如何实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"7. 如何实现浏览器内多个标签页之间的通信?\"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>\n<ul>\n<li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>\n<li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>\n<li><strong>使用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>\n<li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li>\n</ul>\n<h3 id=\"8-对Service-Worker的理解\"><a href=\"#8-对Service-Worker的理解\" class=\"headerlink\" title=\"8. 对Service Worker的理解\"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>\n<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// index.js</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>navigator<span class=\"token punctuation\">.</span>serviceWorker<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  navigator<span class=\"token punctuation\">.</span>serviceWorker\n    <span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sw.js'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">registration</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'service worker 注册成功'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'servcie worker 注册失败'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// sw.js</span>\n<span class=\"token comment\">// 监听 `install` 事件，回调中缓存所需文件</span>\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'install'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  e<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntil</span><span class=\"token punctuation\">(</span>\n    caches<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my-cache'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cache</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'./index.html'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'./index.js'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 拦截所有请求事件</span>\n<span class=\"token comment\">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span>\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetch'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  e<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span>\n    caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> response\n      <span class=\"token punctuation\">&#125;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetch source'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ef126ed3be8463a8e04d4156b2addd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 在 Cache 中也可以发现所需的文件已被缓存： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a223ee3c073d47188ecee7c410ee557c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<h2 id=\"三、浏览器缓存\"><a href=\"#三、浏览器缓存\" class=\"headerlink\" title=\"三、浏览器缓存\"></a>三、浏览器缓存</h2><h3 id=\"1-对浏览器的缓存机制的理解\"><a href=\"#1-对浏览器的缓存机制的理解\" class=\"headerlink\" title=\"1. 对浏览器的缓存机制的理解\"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p>\n<ul>\n<li>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li>\n<li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li>\n<li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li>\n<li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li>\n<li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6837d8d1c74cf2894d8967a20115d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"业务流程图1.png\"> 很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p>\n<h3 id=\"2-浏览器资源缓存的位置有哪些？\"><a href=\"#2-浏览器资源缓存的位置有哪些？\" class=\"headerlink\" title=\"2. 浏览器资源缓存的位置有哪些？\"></a>2. 浏览器资源缓存的位置有哪些？</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p>\n<ol>\n<li><strong>Service Worker：**Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且</strong>缓存是持续性的<strong>。当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。</strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。**</li>\n<li><strong>Memory Cache：</strong> Memory Cache 就是内存缓存，它的效率最快，<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li>\n<li><strong>Disk Cache：</strong> Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></li>\n</ol>\n<p><strong>Disk Cache：</strong> Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：</p>\n<ul>\n<li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li>\n<li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li>\n<li>一旦连接被关闭，Push Cache 就被释放</li>\n<li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>\n<li>Push Cache 中的缓存只能被使用一次</li>\n<li>浏览器可以拒绝接受已经存在的资源推送</li>\n<li>可以给其他域名推送资源****</li>\n</ul>\n<h3 id=\"3-协商缓存和强缓存的区别\"><a href=\"#3-协商缓存和强缓存的区别\" class=\"headerlink\" title=\"3. 协商缓存和强缓存的区别\"></a>3. 协商缓存和强缓存的区别</h3><h4 id=\"（1）强缓存\"><a href=\"#（1）强缓存\" class=\"headerlink\" title=\"（1）强缓存\"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p>\n<p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p>\n<p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>\n<p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p>\n<p><code>Cache-Control</code>可设置的字段：</p>\n<ul>\n<li><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；</li>\n<li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>\n<li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>\n<li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>\n<li><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li>\n<li><code>s-maxage=</code>：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>\n<li><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>\n</ul>\n<p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p>\n<p><strong>no-cache和no-store很容易混淆：</strong></p>\n<ul>\n<li>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li>\n<li>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li>\n</ul>\n<h4 id=\"（2）协商缓存\"><a href=\"#（2）协商缓存\" class=\"headerlink\" title=\"（2）协商缓存\"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p>\n<p>上面已经说到了，命中协商缓存的条件有两个：</p>\n<ul>\n<li><code>max-age=xxx</code> 过期了</li>\n<li>值为<code>no-store</code></li>\n</ul>\n<p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p>\n<p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的<strong>Etag</strong> 和<strong>Last-Modified</strong>属性。</p>\n<p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p>\n<p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p>\n<p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>\n<p><strong>总结：</strong></p>\n<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>\n<h3 id=\"4-为什么需要浏览器缓存？\"><a href=\"#4-为什么需要浏览器缓存？\" class=\"headerlink\" title=\"4. 为什么需要浏览器缓存？\"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>\n<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>\n<p>使用浏览器缓存，有以下优点：</p>\n<ul>\n<li>减少了服务器的负担，提高了网站的性能</li>\n<li>加快了客户端网页的加载速度</li>\n<li>减少了多余网络数据传输</li>\n</ul>\n<h3 id=\"5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？\"><a href=\"#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？\" class=\"headerlink\" title=\"5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？\"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul>\n<li><strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>\n<li><strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>\n<li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>\n</ul>\n<h2 id=\"四、浏览器组成\"><a href=\"#四、浏览器组成\" class=\"headerlink\" title=\"四、浏览器组成\"></a>四、浏览器组成</h2><h3 id=\"1-对浏览器的理解\"><a href=\"#1-对浏览器的理解\" class=\"headerlink\" title=\"1. 对浏览器的理解\"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p>\n<p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p>\n<p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p>\n<ul>\n<li>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li>\n<li>内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</li>\n</ul>\n<h3 id=\"2-对浏览器内核的理解\"><a href=\"#2-对浏览器内核的理解\" class=\"headerlink\" title=\"2. 对浏览器内核的理解\"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p>\n<ul>\n<li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li>\n<li>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</li>\n</ul>\n<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n<h3 id=\"3-常见的浏览器内核比较\"><a href=\"#3-常见的浏览器内核比较\" class=\"headerlink\" title=\"3. 常见的浏览器内核比较\"></a>3. 常见的浏览器内核比较</h3><ul>\n<li><strong>Trident：</strong> 这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li>\n<li><strong>Gecko：</strong> 这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li>\n<li><strong>Presto：</strong> Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li>\n<li><strong>Webkit：</strong> Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li>\n<li><strong>Blink：</strong> 谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li>\n</ul>\n<h3 id=\"4-常见浏览器所用内核\"><a href=\"#4-常见浏览器所用内核\" class=\"headerlink\" title=\"4. 常见浏览器所用内核\"></a>4. 常见浏览器所用内核</h3><p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p>\n<p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p>\n<p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p>\n<p>（4） Safari 浏览器内核：Webkit 内核；</p>\n<p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p>\n<p>（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p>\n<p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p>\n<p>（8） 百度浏览器、世界之窗内核：IE 内核；</p>\n<p>（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p>\n<p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p>\n<h3 id=\"5-浏览器的主要组成部分\"><a href=\"#5-浏览器的主要组成部分\" class=\"headerlink\" title=\"5. 浏览器的主要组成部分\"></a>5. 浏览器的主要组成部分</h3><ul>\n<li><strong>⽤户界⾯</strong> 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。</li>\n<li><strong>浏览器引擎</strong> 在⽤户界⾯和呈现引擎之间传送指令。</li>\n<li><strong>呈现引擎</strong> 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li><strong>⽹络</strong> ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。</li>\n<li><strong>⽤户界⾯后端</strong> ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。</li>\n<li><strong>JavaScript 解释器</strong>。⽤于解析和执⾏ JavaScript 代码。</li>\n<li><strong>数据存储</strong> 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。</li>\n</ul>\n<p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p>\n<h2 id=\"五、浏览器渲染原理\"><a href=\"#五、浏览器渲染原理\" class=\"headerlink\" title=\"五、浏览器渲染原理\"></a>五、浏览器渲染原理</h2><h3 id=\"1-浏览器的渲染过程\"><a href=\"#1-浏览器的渲染过程\" class=\"headerlink\" title=\"1. 浏览器的渲染过程\"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p>\n<ul>\n<li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>\n<li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li>\n<li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>\n<li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>\n<li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>\n</ul>\n<p>大致过程如图所示： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d69da20c3f84782948226798effc60a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p><strong>注意：</strong> 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n<h3 id=\"2-浏览器渲染优化\"><a href=\"#2-浏览器渲染优化\" class=\"headerlink\" title=\"2. 浏览器渲染优化\"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript：</strong> JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>\n<p>（1）尽量将JavaScript文件放在body的最后</p>\n<p>（2） body中间尽量不要写<code>&lt;script&gt;</code>标签</p>\n<p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p>\n<ul>\n<li><strong>script</strong> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li>\n<li><strong>async</strong> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</li>\n<li><strong>defer</strong> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li>\n</ul>\n<p>**（2）针对CSS：**使用CSS有三种方式：使用**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：</p>\n<ul>\n<li><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li>\n<li><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li>\n<li><strong>style</strong>：GUI直接渲染</li>\n</ul>\n<p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>\n<p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>\n<p><strong>（3）针对DOM树、CSSOM树：</strong> 可以通过以下几种方式来减少渲染的时间：</p>\n<ul>\n<li>HTML文件的代码层级尽量不要太深</li>\n<li>使用语义化的标签，来避免不标准语义化的特殊处理</li>\n<li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li>\n</ul>\n<p><strong>（4）减少回流与重绘：</strong></p>\n<ul>\n<li>操作DOM时，尽量在低层级的DOM节点进行操作</li>\n<li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li>\n<li>使用CSS的表达式</li>\n<li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li>\n<li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>\n<li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>\n<li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>\n<li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li>\n</ul>\n<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>\n<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>\n<p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>\n<h3 id=\"3-渲染过程中遇到-JS-文件如何处理？\"><a href=\"#3-渲染过程中遇到-JS-文件如何处理？\" class=\"headerlink\" title=\"3. 渲染过程中遇到 JS 文件如何处理？\"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>\n<h3 id=\"4-什么是文档的预解析？\"><a href=\"#4-什么是文档的预解析？\" class=\"headerlink\" title=\"4. 什么是文档的预解析？\"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>\n<h3 id=\"5-CSS-如何阻塞文档解析？\"><a href=\"#5-CSS-如何阻塞文档解析？\" class=\"headerlink\" title=\"5. CSS 如何阻塞文档解析？\"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>\n<h3 id=\"6-如何优化关键渲染路径？\"><a href=\"#6-如何优化关键渲染路径？\" class=\"headerlink\" title=\"6. 如何优化关键渲染路径？\"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>\n<p>（1）关键资源的数量。</p>\n<p>（2）关键路径长度。</p>\n<p>（3）关键字节的数量。</p>\n<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>\n<p>优化关键渲染路径的常规步骤如下：</p>\n<p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p>\n<p>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p>\n<p>（3）优化关键字节数以缩短下载时间（往返次数）。</p>\n<p>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>\n<h3 id=\"7-什么情况会阻塞渲染？\"><a href=\"#7-什么情况会阻塞渲染？\" class=\"headerlink\" title=\"7. 什么情况会阻塞渲染？\"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>\n<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>\n<h2 id=\"六、浏览器本地存储\"><a href=\"#六、浏览器本地存储\" class=\"headerlink\" title=\"六、浏览器本地存储\"></a>六、浏览器本地存储</h2><h3 id=\"1-浏览器本地存储方式及使用场景\"><a href=\"#1-浏览器本地存储方式及使用场景\" class=\"headerlink\" title=\"1. 浏览器本地存储方式及使用场景\"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id=\"（1）Cookie\"><a href=\"#（1）Cookie\" class=\"headerlink\" title=\"（1）Cookie\"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p>\n<p><strong>Cookie的特性：</strong></p>\n<ul>\n<li>Cookie一旦创建成功，名称就无法修改</li>\n<li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>\n<li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li>\n<li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>\n<li>Cookie在请求一个新的页面的时候都会被发送过去</li>\n</ul>\n<p>如果需要域名之间跨域共享Cookie，有两种方法：</p>\n<ol>\n<li>使用Nginx反向代理</li>\n<li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li>\n</ol>\n<p><strong>Cookie的使用场景：</strong></p>\n<ul>\n<li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li>\n<li>可以用来统计页面的点击次数</li>\n</ul>\n<h4 id=\"（2）LocalStorage\"><a href=\"#（2）LocalStorage\" class=\"headerlink\" title=\"（2）LocalStorage\"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>\n<p><strong>LocalStorage的优点：</strong></p>\n<ul>\n<li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>\n<li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>\n<li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>\n</ul>\n<p><strong>LocalStorage的缺点：</strong></p>\n<ul>\n<li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>\n<li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>\n<li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>\n</ul>\n<p><strong>LocalStorage的常用API：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 保存数据到 localStorage</span>\nlocalStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'key'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'value'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 localStorage 获取数据</span>\n<span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 localStorage 删除保存的数据</span>\nlocalStorage<span class=\"token punctuation\">.</span><span class=\"token function\">removeItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 localStorage 删除所有保存的数据</span>\nlocalStorage<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 获取某个索引的Key</span>\nlocalStorage<span class=\"token punctuation\">.</span><span class=\"token function\">key</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>LocalStorage的使用场景：</strong></p>\n<ul>\n<li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li>\n<li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li>\n</ul>\n<h4 id=\"（3）SessionStorage\"><a href=\"#（3）SessionStorage\" class=\"headerlink\" title=\"（3）SessionStorage\"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>\n<p><strong>SessionStorage与LocalStorage对比：</strong></p>\n<ul>\n<li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li>\n<li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>\n<li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>\n</ul>\n<p><strong>SessionStorage的常用API：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 保存数据到 sessionStorage</span>\nsessionStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'key'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'value'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 sessionStorage 获取数据</span>\n<span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> sessionStorage<span class=\"token punctuation\">.</span><span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 sessionStorage 删除保存的数据</span>\nsessionStorage<span class=\"token punctuation\">.</span><span class=\"token function\">removeItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 从 sessionStorage 删除所有保存的数据</span>\nsessionStorage<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 获取某个索引的Key</span>\nsessionStorage<span class=\"token punctuation\">.</span><span class=\"token function\">key</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>SessionStorage的使用场景</strong></p>\n<ul>\n<li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li>\n</ul>\n<h3 id=\"2-Cookie有哪些字段，作用分别是什么\"><a href=\"#2-Cookie有哪些字段，作用分别是什么\" class=\"headerlink\" title=\"2. Cookie有哪些字段，作用分别是什么\"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p>\n<ul>\n<li><strong>Name</strong>：cookie的名称</li>\n<li><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li>\n<li><strong>Size</strong>： cookie的大小</li>\n<li><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</li>\n<li><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li>\n<li><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li>\n<li><strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li>\n<li><strong>Expires/Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li>\n</ul>\n<p><strong>总结：</strong> 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p>\n<h3 id=\"3-Cookie、LocalStorage、SessionStorage区别\"><a href=\"#3-Cookie、LocalStorage、SessionStorage区别\" class=\"headerlink\" title=\"3. Cookie、LocalStorage、SessionStorage区别\"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>\n<ul>\n<li><strong>cookie：</strong> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li>\n<li><strong>sessionStorage：</strong> html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li>\n<li><strong>localStorage：</strong> html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li>\n</ul>\n<p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>\n<h3 id=\"4-前端储存的⽅式有哪些？\"><a href=\"#4-前端储存的⽅式有哪些？\" class=\"headerlink\" title=\"4. 前端储存的⽅式有哪些？\"></a>4. 前端储存的⽅式有哪些？</h3><ul>\n<li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li>\n<li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li>\n<li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；</li>\n<li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；</li>\n<li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li>\n</ul>\n<h3 id=\"5-IndexedDB有哪些特点？\"><a href=\"#5-IndexedDB有哪些特点？\" class=\"headerlink\" title=\"5. IndexedDB有哪些特点？\"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p>\n<ul>\n<li><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li>\n<li><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li>\n<li><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li>\n<li><strong>同源限制：</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li>\n<li><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li>\n<li><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li>\n</ul>\n<h2 id=\"七、浏览器同源策略\"><a href=\"#七、浏览器同源策略\" class=\"headerlink\" title=\"七、浏览器同源策略\"></a>七、浏览器同源策略</h2><h3 id=\"1-什么是同源策略\"><a href=\"#1-什么是同源策略\" class=\"headerlink\" title=\"1. 什么是同源策略\"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p></blockquote>\n<p>下表给出了与 URL <a href=\"https://link.juejin.cn/?target=http://store.company.com/dir/page.html\">store.company.com/dir/page.ht…</a> 的源进行对比的示例:</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://link.juejin.cn/?target=http://store.company.com/dir/page.html\">store.company.com/dir/page.ht…</a></td>\n<td>同源</td>\n<td>完全相同</td>\n</tr>\n<tr>\n<td><a href=\"https://link.juejin.cn/?target=http://store.company.com/dir/inner/another.html\">store.company.com/dir/inner/a…</a></td>\n<td>同源</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><a href=\"https://link.juejin.cn/?target=https://store.company.com/secure.html\">store.company.com/secure.html</a></td>\n<td>跨域</td>\n<td>协议不同</td>\n</tr>\n<tr>\n<td><a href=\"https://link.juejin.cn/?target=http://store.company.com:81/dir/etc.html\">store.company.com:81/dir/etc.htm…</a></td>\n<td>跨域</td>\n<td>端口不同 ( http:// 默认端口是80)</td>\n</tr>\n<tr>\n<td><a href=\"https://link.juejin.cn/?target=http://news.company.com/dir/other.html\">news.company.com/dir/other.h…</a></td>\n<td>跨域</td>\n<td>主机不同</td>\n</tr>\n</tbody></table>\n<p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p>\n<p><strong>同源政策主要限制了三个方面：</strong></p>\n<ul>\n<li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>\n<li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li>\n<li>当前域下 ajax 无法发送跨域请求。</li>\n</ul>\n<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>\n<h3 id=\"2-如何解决跨越问题\"><a href=\"#2-如何解决跨越问题\" class=\"headerlink\" title=\"2. 如何解决跨越问题\"></a>2. 如何解决跨越问题</h3><h4 id=\"（1）CORS\"><a href=\"#（1）CORS\" class=\"headerlink\" title=\"（1）CORS\"></a>（1）CORS</h4><p>下面是MDN对于CORS的定义：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p></blockquote>\n<p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p>\n<p>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p>\n<p>简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p>\n<p><strong>1）请求方法是以下三种方法之一：</strong></p>\n<ul>\n<li>HEAD</li>\n<li>GET</li>\n<li>POST</li>\n</ul>\n<p><strong>2）HTTP的头信息不超出以下几种字段：</strong></p>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n</ul>\n<p>若不满足以上条件，就属于非简单请求了。</p>\n<p><strong>（1）简单请求过程：</strong></p>\n<p>对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Access<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Origin<span class=\"token operator\">:</span> http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>api<span class=\"token punctuation\">.</span>bob<span class=\"token punctuation\">.</span>com  <span class=\"token comment\">// 和Orign一直</span>\nAccess<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Credentials<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>   <span class=\"token comment\">// 表示是否允许发送Cookie</span>\nAccess<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Expose<span class=\"token operator\">-</span>Headers<span class=\"token operator\">:</span> FooBar   <span class=\"token comment\">// 指定返回其他字段的值</span>\nContent<span class=\"token operator\">-</span>Type<span class=\"token operator\">:</span> text<span class=\"token operator\">/</span>html<span class=\"token punctuation\">;</span> charset<span class=\"token operator\">=</span>utf<span class=\"token operator\">-</span><span class=\"token number\">8</span>   <span class=\"token comment\">// 表示文档类型</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p>\n<p><strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>Access-Control-Allow-Origin</code></p>\n<p><strong>（2）非简单请求过程</strong></p>\n<p>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p>\n<p>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p>\n<p>预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p>\n<ul>\n<li><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li>\n<li><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li>\n</ul>\n<p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p>\n<p>服务器回应的CORS的字段如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Access<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Origin<span class=\"token operator\">:</span> http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>api<span class=\"token punctuation\">.</span>bob<span class=\"token punctuation\">.</span>com  <span class=\"token comment\">// 允许跨域的源地址</span>\nAccess<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Methods<span class=\"token operator\">:</span> <span class=\"token constant\">GET</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">POST</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">PUT</span> <span class=\"token comment\">// 服务器支持的所有跨域请求的方法</span>\nAccess<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Headers<span class=\"token operator\">:</span> <span class=\"token constant\">X</span><span class=\"token operator\">-</span>Custom<span class=\"token operator\">-</span>Header  <span class=\"token comment\">// 服务器支持的所有头信息字段</span>\nAccess<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Credentials<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>   <span class=\"token comment\">// 表示是否允许发送Cookie</span>\nAccess<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Max<span class=\"token operator\">-</span>Age<span class=\"token operator\">:</span> <span class=\"token number\">1728000</span>  <span class=\"token comment\">// 用来指定本次预检请求的有效期，单位为秒</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>\n<p><strong>在非简单请求中，至少需要设置以下字段：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token string\">'Access-Control-Allow-Origin'</span>  \n<span class=\"token string\">'Access-Control-Allow-Methods'</span>\n<span class=\"token string\">'Access-Control-Allow-Headers'</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"减少OPTIONS请求次数：\"><a href=\"#减少OPTIONS请求次数：\" class=\"headerlink\" title=\"减少OPTIONS请求次数：\"></a>减少OPTIONS请求次数：</h5><p>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p>\n<h5 id=\"CORS中Cookie相关问题：\"><a href=\"#CORS中Cookie相关问题：\" class=\"headerlink\" title=\"CORS中Cookie相关问题：\"></a>CORS中Cookie相关问题：</h5><p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p>\n<ul>\n<li>在请求中设置 <code>withCredentials</code></li>\n</ul>\n<p>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 原生 xml 的设置方式</span>\n<span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span>withCredentials <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// axios 设置方式</span>\naxios<span class=\"token punctuation\">.</span>defaults<span class=\"token punctuation\">.</span>withCredentials <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>Access-Control-Allow-Credentials 设置为 true</li>\n<li>Access-Control-Allow-Origin 设置为非 <code>*</code></li>\n</ul>\n<h4 id=\"（2）JSONP\"><a href=\"#（2）JSONP\" class=\"headerlink\" title=\"（2）JSONP\"></a>（2）JSONP</h4><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 1）原生JS实现：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n    <span class=\"token keyword\">var</span> script <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    script<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> <span class=\"token string\">'text/javascript'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span>\n    script<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'</span><span class=\"token punctuation\">;</span>\n    document<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 回调执行函数</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">handleCallback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>服务端返回如下（返回时即执行全局函数）：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token function\">handleCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token string-property property\">\"success\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string-property property\">\"user\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"admin\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>2）Vue axios实现：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$http <span class=\"token operator\">=</span> axios<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$http<span class=\"token punctuation\">.</span><span class=\"token function\">jsonp</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://www.domain2.com:8080/login'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token literal-property property\">params</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">jsonp</span><span class=\"token operator\">:</span> <span class=\"token string\">'handleCallback'</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>后端node.js代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> querystring <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'querystring'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'request'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> params <span class=\"token operator\">=</span> querystring<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> fn <span class=\"token operator\">=</span> params<span class=\"token punctuation\">.</span>callback<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// jsonp返回设置</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token string-property property\">'Content-Type'</span><span class=\"token operator\">:</span> <span class=\"token string\">'text/javascript'</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fn <span class=\"token operator\">+</span> <span class=\"token string\">'('</span> <span class=\"token operator\">+</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token string\">'8080'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Server is running at port 8080...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>JSONP的缺点：</strong></p>\n<ul>\n<li>具有局限性， 仅支持get方法</li>\n<li>不安全，可能会遭受XSS攻击</li>\n</ul>\n<h4 id=\"（3）postMessage-跨域\"><a href=\"#（3）postMessage-跨域\" class=\"headerlink\" title=\"（3）postMessage 跨域\"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\n<ul>\n<li>页面和其打开的新窗口的数据传递</li>\n<li>多窗口之间消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n<p>用法：postMessage(data,origin)方法接受两个参数：</p>\n<ul>\n<li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>\n<li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>\n</ul>\n<p>1）a.html：(domain1.com/a.html)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>iframe id<span class=\"token operator\">=</span><span class=\"token string\">\"iframe\"</span> src<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.domain2.com/b.html\"</span> style<span class=\"token operator\">=</span><span class=\"token string\">\"display:none;\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>iframe<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>       \n    <span class=\"token keyword\">var</span> iframe <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'iframe'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    iframe<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'aym'</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 向domain2传送跨域数据</span>\n        iframe<span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">.</span><span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://www.domain2.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 接受domain2返回数据</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data from domain2 ---> '</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2）b.html：(domain2.com/b.html)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n    <span class=\"token comment\">// 接收domain1的数据</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data from domain1 ---> '</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            data<span class=\"token punctuation\">.</span>number <span class=\"token operator\">=</span> <span class=\"token number\">16</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 处理后再发回domain1</span>\n            window<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span><span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://www.domain1.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"（4）nginx代理跨域\"><a href=\"#（4）nginx代理跨域\" class=\"headerlink\" title=\"（4）nginx代理跨域\"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>\n<p>1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">location / &#123;\n  add_header Access-Control-Allow-Origin *;\n&#125;\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2）nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>\n<p>nginx具体配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">#proxy服务器\nserver <span class=\"token punctuation\">&#123;</span>\n    listen       <span class=\"token number\">81</span><span class=\"token punctuation\">;</span>\n    server_name  www<span class=\"token punctuation\">.</span>domain1<span class=\"token punctuation\">.</span>com<span class=\"token punctuation\">;</span>\n    location <span class=\"token operator\">/</span> <span class=\"token punctuation\">&#123;</span>\n        proxy_pass   http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>domain2<span class=\"token punctuation\">.</span>com<span class=\"token operator\">:</span><span class=\"token number\">8080</span><span class=\"token punctuation\">;</span>  #反向代理\n        proxy_cookie_domain www<span class=\"token punctuation\">.</span>domain2<span class=\"token punctuation\">.</span>com www<span class=\"token punctuation\">.</span>domain1<span class=\"token punctuation\">.</span>com<span class=\"token punctuation\">;</span> #修改cookie里域名\n        index  index<span class=\"token punctuation\">.</span>html index<span class=\"token punctuation\">.</span>htm<span class=\"token punctuation\">;</span>\n        # 当用webpack<span class=\"token operator\">-</span>dev<span class=\"token operator\">-</span>server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Origin http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>domain1<span class=\"token punctuation\">.</span>com<span class=\"token punctuation\">;</span>  #当前端只跨域不带cookie时，可为<span class=\"token operator\">*</span>\n        add_header Access<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Credentials <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"（5）nodejs-中间件代理跨域\"><a href=\"#（5）nodejs-中间件代理跨域\" class=\"headerlink\" title=\"（5）nodejs 中间件代理跨域\"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>\n<p><strong>1）非vue框架的跨域</strong> 使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>\n<ul>\n<li>前端代码：</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 前端开关：浏览器是否读写cookie</span>\nxhr<span class=\"token punctuation\">.</span>withCredentials <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 访问http-proxy-middleware代理服务器</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'get'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://www.domain1.com:3000/login?user=admin'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>中间件服务器代码：</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> express <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'express'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> proxy <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http-proxy-middleware'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> app <span class=\"token operator\">=</span> <span class=\"token function\">express</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token function\">proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 代理跨域目标接口</span>\n    <span class=\"token literal-property property\">target</span><span class=\"token operator\">:</span> <span class=\"token string\">'http://www.domain2.com:8080'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">changeOrigin</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 修改响应头信息，实现跨域并允许带cookie</span>\n    <span class=\"token function-variable function\">onProxyRes</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">proxyRes<span class=\"token punctuation\">,</span> req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">header</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Access-Control-Allow-Origin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://www.domain1.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">header</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Access-Control-Allow-Credentials'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'true'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 修改响应信息中的cookie域名</span>\n    <span class=\"token literal-property property\">cookieDomainRewrite</span><span class=\"token operator\">:</span> <span class=\"token string\">'www.domain1.com'</span>  <span class=\"token comment\">// 可以为false，表示不修改</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Proxy server is listen at port 3000...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>2）vue框架的跨域</strong></p>\n<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>\n<p>webpack.config.js部分配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token literal-property property\">devServer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token literal-property property\">historyApiFallback</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">proxy</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token literal-property property\">context</span><span class=\"token operator\">:</span> <span class=\"token string\">'/login'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">target</span><span class=\"token operator\">:</span> <span class=\"token string\">'http://www.domain2.com:8080'</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 代理跨域目标接口</span>\n            <span class=\"token literal-property property\">changeOrigin</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">secure</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 当代理某些https服务报错时用</span>\n            <span class=\"token literal-property property\">cookieDomainRewrite</span><span class=\"token operator\">:</span> <span class=\"token string\">'www.domain1.com'</span>  <span class=\"token comment\">// 可以为false，表示不修改</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">noInfo</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"（6）document-domain-iframe跨域\"><a href=\"#（6）document-domain-iframe跨域\" class=\"headerlink\" title=\"（6）document.domain + iframe跨域\"></a>（6）document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>iframe id<span class=\"token operator\">=</span><span class=\"token string\">\"iframe\"</span> src<span class=\"token operator\">=</span><span class=\"token string\">\"http://child.domain.com/b.html\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>iframe<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n    document<span class=\"token punctuation\">.</span>domain <span class=\"token operator\">=</span> <span class=\"token string\">'domain.com'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> user <span class=\"token operator\">=</span> <span class=\"token string\">'admin'</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>1）子窗口：(child.domain.com/a.html)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n    document<span class=\"token punctuation\">.</span>domain <span class=\"token operator\">=</span> <span class=\"token string\">'domain.com'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 获取父窗口中变量</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'get js data from parent ---> '</span> <span class=\"token operator\">+</span> window<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"（7）location-hash-iframe跨域\"><a href=\"#（7）location-hash-iframe跨域\" class=\"headerlink\" title=\"（7）location.hash + iframe跨域\"></a>（7）location.hash + iframe跨域</h4><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>\n<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>\n<p>1）a.html：(domain1.com/a.html)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>iframe id<span class=\"token operator\">=</span><span class=\"token string\">\"iframe\"</span> src<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.domain2.com/b.html\"</span> style<span class=\"token operator\">=</span><span class=\"token string\">\"display:none;\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>iframe<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n    <span class=\"token keyword\">var</span> iframe <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'iframe'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 向b.html传hash值</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        iframe<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> iframe<span class=\"token punctuation\">.</span>src <span class=\"token operator\">+</span> <span class=\"token string\">'#user=admin'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 开放给同域c.html的回调方法</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">onCallback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data from c.html ---> '</span> <span class=\"token operator\">+</span> res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2）b.html：(.domain2.com/b.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain1.com&#x2F;c.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    &#x2F;&#x2F; 监听a.html传来的hash值，再传给c.html\n    window.onhashchange &#x3D; function () &#123;\n        iframe.src &#x3D; iframe.src + location.hash;\n    &#125;;\n&lt;&#x2F;script&gt;\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3）c.html：(<a href=\"https://link.juejin.cn/?target=https://link.zhihu.com/?target=http://www.domain1.com/c.html\">www.domain1.com/c.html</a>)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n    <span class=\"token comment\">// 监听b.html传来的hash值</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onhashchange</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 再通过操作同域a.html的js回调，将结果传回</span>\n        window<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span><span class=\"token function\">onCallback</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello: '</span> <span class=\"token operator\">+</span> location<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#user='</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"（8）window-name-iframe跨域\"><a href=\"#（8）window-name-iframe跨域\" class=\"headerlink\" title=\"（8）window.name + iframe跨域\"></a>（8）window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<p>1）a.html：(domain1.com/a.html)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">proxy</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">url<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> state <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> iframe <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'iframe'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 加载跨域页面</span>\n    iframe<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> url<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span>\n    iframe<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>state <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span>\n            <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>iframe<span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">destoryFrame</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>state <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 第1次onload(跨域页)成功后，切换到同域代理页面</span>\n            iframe<span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">.</span>location <span class=\"token operator\">=</span> <span class=\"token string\">'http://www.domain1.com/proxy.html'</span><span class=\"token punctuation\">;</span>\n            state <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>iframe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">destoryFrame</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        iframe<span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">.</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        iframe<span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>iframe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 请求跨域b页面数据</span>\n<span class=\"token function\">proxy</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://www.domain2.com/b.html'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2）proxy.html：(domain1.com/proxy.html)</p>\n<p>中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>    \n    window<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'This is domain2 data!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\n<h4 id=\"（9）WebSocket协议跨域\"><a href=\"#（9）WebSocket协议跨域\" class=\"headerlink\" title=\"（9）WebSocket协议跨域\"></a>（9）WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>\n<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>\n<p>1）前端代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>user input：<span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"text\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script src<span class=\"token operator\">=</span><span class=\"token string\">\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n<span class=\"token keyword\">var</span> socket <span class=\"token operator\">=</span> <span class=\"token function\">io</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://www.domain2.com:8080'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 连接成功处理</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'connect'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 监听服务端消息</span>\n    socket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data from server: ---> '</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 监听服务端关闭</span>\n    socket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'disconnect'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Server socket has closed.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onblur</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    socket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2）Nodejs socket后台：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> socket <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'socket.io'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 启http服务</span>\n<span class=\"token keyword\">var</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token string-property property\">'Content-type'</span><span class=\"token operator\">:</span> <span class=\"token string\">'text/html'</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token string\">'8080'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Server is running at port 8080...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 监听socket连接</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>server<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'connection'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">client</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 接收信息</span>\n    client<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        client<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello：'</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data from client: ---> '</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 断开处理</span>\n    client<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'disconnect'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Client socket has closed.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-正向代理和反向代理的区别\"><a href=\"#3-正向代理和反向代理的区别\" class=\"headerlink\" title=\"3. 正向代理和反向代理的区别\"></a>3. 正向代理和反向代理的区别</h3><ul>\n<li><strong>正向代理：</strong></li>\n</ul>\n<p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p>\n<ul>\n<li><strong>反向代理：</strong></li>\n</ul>\n<p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p>\n<p>两者区别如图示： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97e92248f2654185808f80b65f3ca0f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p>\n<h3 id=\"4-Nginx的概念及其工作原理\"><a href=\"#4-Nginx的概念及其工作原理\" class=\"headerlink\" title=\"4. Nginx的概念及其工作原理\"></a>4. Nginx的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p>\n<p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p>\n<p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p>\n<h2 id=\"八、浏览器事件机制\"><a href=\"#八、浏览器事件机制\" class=\"headerlink\" title=\"八、浏览器事件机制\"></a>八、浏览器事件机制</h2><h3 id=\"1-事件是什么？事件模型？\"><a href=\"#1-事件是什么？事件模型？\" class=\"headerlink\" title=\"1. 事件是什么？事件模型？\"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>\n<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p>\n<ul>\n<li><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li>\n<li><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li>\n<li><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li>\n</ul>\n<h3 id=\"2-如何阻止事件冒泡\"><a href=\"#2-如何阻止事件冒泡\" class=\"headerlink\" title=\"2. 如何阻止事件冒泡\"></a>2. 如何阻止事件冒泡</h3><ul>\n<li>普通浏览器使用：event.stopPropagation()</li>\n<li>IE浏览器使用：event.cancelBubble = true;</li>\n</ul>\n<h3 id=\"3-对事件委托的理解\"><a href=\"#3-对事件委托的理解\" class=\"headerlink\" title=\"3. 对事件委托的理解\"></a>3. 对事件委托的理解</h3><h4 id=\"（1）事件委托的概念\"><a href=\"#（1）事件委托的概念\" class=\"headerlink\" title=\"（1）事件委托的概念\"></a>（1）事件委托的概念</h4><p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p>\n<p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p>\n<h4 id=\"（2）事件委托的特点\"><a href=\"#（2）事件委托的特点\" class=\"headerlink\" title=\"（2）事件委托的特点\"></a>（2）事件委托的特点</h4><ul>\n<li><strong>减少内存消耗</strong></li>\n</ul>\n<p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>list<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>item 1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>item 2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>item 3<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  ......\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>item n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p>\n<ul>\n<li><strong>动态绑定事件</strong></li>\n</ul>\n<p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span>\n<span class=\"token comment\">// 给父层元素绑定事件</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'list'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 兼容性处理</span>\n  <span class=\"token keyword\">var</span> event <span class=\"token operator\">=</span> e <span class=\"token operator\">||</span> window<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> target <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>target <span class=\"token operator\">||</span> event<span class=\"token punctuation\">.</span>srcElement<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 判断是否匹配目标元素</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">.</span>nodeName<span class=\"token punctuation\">.</span>toLocaleLowerCase <span class=\"token operator\">===</span> <span class=\"token string\">'li'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'the content is: '</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">.</span>innerHTML<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>\n<h4 id=\"（3）局限性\"><a href=\"#（3）局限性\" class=\"headerlink\" title=\"（3）局限性\"></a>（3）局限性</h4><p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p>\n<p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p>\n<ul>\n<li>元素中，绑定事件委托的次数；</li>\n<li>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li>\n</ul>\n<p>在必须使用事件委托的地方，可以进行如下的处理：</p>\n<ul>\n<li>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</li>\n<li>尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</li>\n<li>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li>\n</ul>\n<h3 id=\"4-事件委托的使用场景\"><a href=\"#4-事件委托的使用场景\" class=\"headerlink\" title=\"4. 事件委托的使用场景\"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">document<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>nodeName <span class=\"token operator\">==</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span>\n\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p>\n<p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">document<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>parentNode<span class=\"token punctuation\">.</span>nodeName <span class=\"token operator\">!=</span> <span class=\"token string\">\"BODY\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>nodeName <span class=\"token operator\">==</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t\tnode <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>parentNode<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-同步和异步的区别\"><a href=\"#5-同步和异步的区别\" class=\"headerlink\" title=\"5. 同步和异步的区别\"></a>5. 同步和异步的区别</h3><ul>\n<li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li>\n<li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li>\n</ul>\n<h3 id=\"6-对事件循环的理解\"><a href=\"#6-对事件循环的理解\" class=\"headerlink\" title=\"6. 对事件循环的理解\"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426a3bf11f404821abb636690119621b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>Event Loop 执行顺序如下所示：</p>\n<ul>\n<li>首先执行同步代码，这属于宏任务</li>\n<li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>\n<li>执行所有微任务</li>\n<li>当执行完所有微任务后，如有必要会渲染页面</li>\n<li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li>\n</ul>\n<h3 id=\"7-宏任务和微任务分别有哪些\"><a href=\"#7-宏任务和微任务分别有哪些\" class=\"headerlink\" title=\"7. 宏任务和微任务分别有哪些\"></a>7. 宏任务和微任务分别有哪些</h3><ul>\n<li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li>\n<li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li>\n</ul>\n<h3 id=\"8-什么是执行栈\"><a href=\"#8-什么是执行栈\" class=\"headerlink\" title=\"8. 什么是执行栈\"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/391e7d7e880f42d59809dbc16af5d7bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p>\n<p>平时在开发中，可以在报错中找到执行栈的痕迹：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab3646b742d946659e4bce34d5af6751~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"> 可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#125;</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cac7e59102dc4c3a9efa53aecd64bf9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<h3 id=\"9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？\"><a href=\"#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？\" class=\"headerlink\" title=\"9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？\"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p>\n<p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed6d249f54e242fe9dc267f03fa156d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>（1）<strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p>\n<p>（2）<strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。</p>\n<p>（3）<strong>Idle/Prepare</strong>：仅供内部使用。</p>\n<p>（4）<strong>Poll（轮询阶段）</strong>：</p>\n<ul>\n<li>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li>\n<li>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li>\n</ul>\n<p>（5）<strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p>\n<p>（6）<strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p>\n<p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setImmediate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p>\n<ul>\n<li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li>\n<li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li>\n<li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li>\n</ul>\n<p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span>\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>__filename<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'immediate'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p>\n<p>上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea27044a0124facaab3e4a8da89d709~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timer21'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise1'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p>\n<p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timer1'</span><span class=\"token punctuation\">)</span>\n Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise1'</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nprocess<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nextTick'</span><span class=\"token punctuation\">)</span>\n process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nextTick'</span><span class=\"token punctuation\">)</span>\n   process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n     console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nextTick'</span><span class=\"token punctuation\">)</span>\n     process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n       console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nextTick'</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p>\n<h3 id=\"10-事件触发的过程是怎样的\"><a href=\"#10-事件触发的过程是怎样的\" class=\"headerlink\" title=\"10. 事件触发的过程是怎样的\"></a>10. 事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p>\n<ul>\n<li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li>\n<li>传播到事件触发处时触发注册的事件</li>\n<li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>\n</ul>\n<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个 *<em><code>body</code>*</em> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 以下会先打印冒泡然后是捕获</span>\nnode<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'冒泡'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">)</span>\nnode<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'捕获 '</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通常使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>\n<ul>\n<li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li>\n<li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>\n<li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>\n</ul>\n<p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>\n<p><code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">node<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">stopImmediatePropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'冒泡'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 点击 node 只会执行上面的函数，该函数不会执行</span>\nnode<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'捕获 '</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">)</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"九、浏览器垃圾回收机制\"><a href=\"#九、浏览器垃圾回收机制\" class=\"headerlink\" title=\"九、浏览器垃圾回收机制\"></a>九、浏览器垃圾回收机制</h2><h3 id=\"1-V8的垃圾回收机制是怎样的\"><a href=\"#1-V8的垃圾回收机制是怎样的\" class=\"headerlink\" title=\"1. V8的垃圾回收机制是怎样的\"></a>1. V8的垃圾回收机制是怎样的</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>\n<p><strong>（1）新生代算法</strong></p>\n<p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>\n<p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>\n<p><strong>（2）老生代算法</strong></p>\n<p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p>\n<p>先来说下什么情况下对象会出现在老生代空间中：</p>\n<ul>\n<li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>\n<li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li>\n</ul>\n<p>老生代中的空间很复杂，有如下几个空间</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">enum</span> AllocationSpace <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// TODO(v8:7464): Actually map this space's memory as read-only.</span>\n  <span class=\"token constant\">RO_SPACE</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\">// 不变的对象空间</span>\n  <span class=\"token constant\">NEW_SPACE</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 新生代用于 GC 复制算法的空间</span>\n  <span class=\"token constant\">OLD_SPACE</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 老生代常驻对象空间</span>\n  <span class=\"token constant\">CODE_SPACE</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 老生代代码对象空间</span>\n  <span class=\"token constant\">MAP_SPACE</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 老生代 map 对象</span>\n  <span class=\"token constant\">LO_SPACE</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\">// 老生代大空间对象</span>\n  <span class=\"token constant\">NEW_LO_SPACE</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 新生代大空间对象</span>\n  <span class=\"token constant\">FIRST_SPACE</span> <span class=\"token operator\">=</span> <span class=\"token constant\">RO_SPACE</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">LAST_SPACE</span> <span class=\"token operator\">=</span> <span class=\"token constant\">NEW_LO_SPACE</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">FIRST_GROWABLE_PAGED_SPACE</span> <span class=\"token operator\">=</span> <span class=\"token constant\">OLD_SPACE</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">LAST_GROWABLE_PAGED_SPACE</span> <span class=\"token operator\">=</span> <span class=\"token constant\">MAP_SPACE</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在老生代中，以下情况会先启动标记清除算法：</p>\n<ul>\n<li>某一个空间没有分块的时候</li>\n<li>空间中被对象超过一定限制</li>\n<li>空间不能保证新生代中的对象移动到老生代中</li>\n</ul>\n<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。</p>\n<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>\n<h3 id=\"2-哪些操作会造成内存泄漏？\"><a href=\"#2-哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"2. 哪些操作会造成内存泄漏？\"></a>2. 哪些操作会造成内存泄漏？</h3><ul>\n<li>第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>\n<li>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\n<li>第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>\n<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\n</ul>\n","text":"计算机网络一、HTTP协议1. GET和POST的请求的区别Post 和 Get 是 HTTP 请求的两种方法，其区别如下： 应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求...","link":"","photos":[],"count_time":{"symbolsCount":"87k","symbolsTime":"1:19"},"categories":[{"name":"知识点","slug":"知识点","count":18,"path":"api/categories/知识点.json"}],"tags":[{"name":"面试","slug":"面试","count":13,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">计算机网络</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81HTTP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">一、HTTP协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-GET%E5%92%8CPOST%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1. GET和POST的请求的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-POST%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2. POST和PUT请求的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4\"><span class=\"toc-text\">3. 常见的HTTP请求头和响应头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-HTTP%E7%8A%B6%E6%80%81%E7%A0%81304%E6%98%AF%E5%A4%9A%E5%A5%BD%E8%BF%98%E6%98%AF%E5%B0%91%E5%A5%BD\"><span class=\"toc-text\">4. HTTP状态码304是多好还是少好</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">5. 常见的HTTP请求方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-OPTIONS%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">6. OPTIONS请求方法及使用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-HTTP-1-0-%E5%92%8C-HTTP-1-1-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">8. HTTP 1.1 和 HTTP 2.0 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">9. HTTP和HTTPS协议的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-GET%E6%96%B9%E6%B3%95URL%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">10. GET方法URL长度限制的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-Google-com-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">12. 对keep-alive的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8CHTTP%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%A1%A8%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">13. 页面有多张图片，HTTP是怎样的加载表现？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-HTTP2%E7%9A%84%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">14. HTTP2的头部压缩算法是怎样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">15. HTTP请求报文的是什么样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">16. HTTP响应报文的是什么样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">17. HTTP协议的优点和缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E8%AF%B4%E4%B8%80%E4%B8%8BHTTP-3-0\"><span class=\"toc-text\">18. 说一下HTTP 3.0</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%A7%E8%83%BD%E6%80%8E%E4%B9%88%E6%A0%B7\"><span class=\"toc-text\">19. HTTP协议的性能怎么样</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-URL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">20. URL有哪些组成部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">21. 与缓存相关的HTTP请求头有哪些</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81HTTPS%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">二、HTTPS协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE%EF%BC%9F\"><span class=\"toc-text\">1. 什么是HTTPS协议？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-TLS-SSL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2. TLS&#x2F;SSL的工作原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0hash\"><span class=\"toc-text\">（1）散列函数hash</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">（2）对称加密</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">（3）非对称加密</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">3. 数字证书是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-HTTPS%E9%80%9A%E4%BF%A1%EF%BC%88%E6%8F%A1%E6%89%8B%EF%BC%89%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">4. HTTPS通信（握手）过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-HTTPS%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">5. HTTPS的特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">6. HTTPS是如何保证安全的？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">三、HTTP状态码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2XX-Success-%E6%88%90%E5%8A%9F%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">1. 2XX (Success 成功状态码)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89200-OK\"><span class=\"toc-text\">（1）200 OK</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89204-No-Content\"><span class=\"toc-text\">（2）204 No Content</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89206-Partial-Content\"><span class=\"toc-text\">（3）206 Partial Content</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3XX-Redirection-%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">2. 3XX (Redirection 重定向状态码)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89301-Moved-Permanently\"><span class=\"toc-text\">（1）301 Moved Permanently</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89302-Found\"><span class=\"toc-text\">（2）302 Found</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89303-See-Other\"><span class=\"toc-text\">（3）303 See Other</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%884%EF%BC%89304-Not-Modified\"><span class=\"toc-text\">（4）304 Not Modified</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%885%EF%BC%89307-Temporary-Redirect\"><span class=\"toc-text\">（5）307 Temporary Redirect</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4XX-Client-Error-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">3. 4XX (Client Error 客户端错误状态码)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89400-Bad-Request\"><span class=\"toc-text\">（1）400 Bad Request</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89401-Unauthorized\"><span class=\"toc-text\">（2）401 Unauthorized</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89403-Forbidden\"><span class=\"toc-text\">（3）403 Forbidden</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%884%EF%BC%89404-Not-Found\"><span class=\"toc-text\">（4）404 Not Found</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%885%EF%BC%89405-Method-Not-Allowed\"><span class=\"toc-text\">（5）405 Method Not Allowed</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5XX-Server-Error-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">4. 5XX (Server Error 服务器错误状态码)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89500-Internal-Server-Error\"><span class=\"toc-text\">（1）500 Internal Server Error</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89502-Bad-Gateway\"><span class=\"toc-text\">（2）502 Bad Gateway</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89503-Service-Unavailable\"><span class=\"toc-text\">（3）503 Service Unavailable</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%884%EF%BC%89504-Gateway-Timeout\"><span class=\"toc-text\">（4）504 Gateway Timeout</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5. 总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%90%8C%E6%A0%B7%E6%98%AF%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%8C307%EF%BC%8C303%EF%BC%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">6. 同样是重定向，307，303，302的区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81DNS%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">四、DNS协议介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-DNS-%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1. DNS 协议是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-DNS%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%EF%BC%9F\"><span class=\"toc-text\">2. DNS同时使用TCP和UDP协议？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-DNS%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">3. DNS完整的查询过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2%E4%B8%8E%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">4. 迭代查询与递归查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-DNS-%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87\"><span class=\"toc-text\">5. DNS 记录和报文</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">五、网络模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">1. OSI七层模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82\"><span class=\"toc-text\">（1）应用层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E8%A1%A8%E7%A4%BA%E5%B1%82\"><span class=\"toc-text\">（2）表示层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89%E4%BC%9A%E8%AF%9D%E5%B1%82\"><span class=\"toc-text\">（3）会话层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%884%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82\"><span class=\"toc-text\">（4）传输层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%885%EF%BC%89%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">（5）网络层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%886%EF%BC%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82\"><span class=\"toc-text\">（6）数据链路层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%887%EF%BC%89%E7%89%A9%E7%90%86%E5%B1%82\"><span class=\"toc-text\">（7）物理层</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-TCP-IP%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">2. TCP&#x2F;IP五层协议</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81TCP%E4%B8%8EUDP\"><span class=\"toc-text\">六、TCP与UDP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-TCP-%E5%92%8C-UDP%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1. TCP 和 UDP的概念及特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2. TCP和UDP的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-TCP%E5%92%8CUDP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">3. TCP和UDP的使用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-UDP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E9%9D%A0%EF%BC%9F\"><span class=\"toc-text\">4. UDP协议为什么不可靠？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-TCP%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">5. TCP的重传机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">6. TCP的拥塞控制机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">7. TCP的流量控制机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">8. TCP的可靠传输机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">9. TCP的三次握手和四次挥手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">（1）三次握手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">（2）四次挥手</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-TCP%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86\"><span class=\"toc-text\">10. TCP粘包是怎么回事，如何处理?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E4%B8%BA%E4%BB%80%E4%B9%88udp%E4%B8%8D%E4%BC%9A%E7%B2%98%E5%8C%85%EF%BC%9F\"><span class=\"toc-text\">11. 为什么udp不会粘包？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81WebSocket\"><span class=\"toc-text\">七、WebSocket</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%AF%B9-WebSocket-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">1. 对 WebSocket 的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81SSE-%E5%92%8C-WebSocket-%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">浏览器原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">一、浏览器安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">1.  什么是 XSS 攻击？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">（1）概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">（2）攻击类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">2. 如何防御 XSS 攻击？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">3. 什么是 CSRF 攻击？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">（1）概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B-1\"><span class=\"toc-text\">（2）攻击类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">4. 如何防御 CSRF 攻击？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">5. 什么是中间人攻击？如何防范中间人攻击？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">6. 有哪些可能引起前端安全的问题?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F\"><span class=\"toc-text\">7. 网络劫持有哪几种，如何防范？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">二、进程与线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1. 进程与线程的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2. 进程和线程的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">3. 浏览器渲染进程的线程有哪些</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4. 进程之前的通信方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">5. 僵尸进程和孤儿进程是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F-%E5%A6%82%E6%9E%9C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">6. 死锁产生的原因？ 如果解决死锁的问题？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">7. 如何实现浏览器内多个标签页之间的通信?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E5%AF%B9Service-Worker%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">8. 对Service Worker的理解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">三、浏览器缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">1. 对浏览器的缓存机制的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">2. 浏览器资源缓存的位置有哪些？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3. 协商缓存和强缓存的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E5%BC%BA%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">（1）强缓存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">（2）协商缓存</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%9F\"><span class=\"toc-text\">4. 为什么需要浏览器缓存？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%82%B9%E5%87%BB%E5%88%B7%E6%96%B0%E6%8C%89%E9%92%AE%E6%88%96%E8%80%85%E6%8C%89-F5%E3%80%81%E6%8C%89-Ctrl-F5-%EF%BC%88%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%EF%BC%89%E3%80%81%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9B%9E%E8%BD%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90\"><span class=\"toc-text\">四、浏览器组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">1. 对浏览器的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">2. 对浏览器内核的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">3. 常见的浏览器内核比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">4. 常见浏览器所用内核</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">5. 浏览器的主要组成部分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">五、浏览器渲染原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">1. 浏览器的渲染过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2. 浏览器渲染优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0-JS-%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">3. 渲染过程中遇到 JS 文件如何处理？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%E7%9A%84%E9%A2%84%E8%A7%A3%E6%9E%90%EF%BC%9F\"><span class=\"toc-text\">4. 什么是文档的预解析？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-CSS-%E5%A6%82%E4%BD%95%E9%98%BB%E5%A1%9E%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90%EF%BC%9F\"><span class=\"toc-text\">5. CSS 如何阻塞文档解析？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%EF%BC%9F\"><span class=\"toc-text\">6. 如何优化关键渲染路径？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%EF%BC%9F\"><span class=\"toc-text\">7. 什么情况会阻塞渲染？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">六、浏览器本地存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1. 浏览器本地存储方式及使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89Cookie\"><span class=\"toc-text\">（1）Cookie</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89LocalStorage\"><span class=\"toc-text\">（2）LocalStorage</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89SessionStorage\"><span class=\"toc-text\">（3）SessionStorage</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Cookie%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">2. Cookie有哪些字段，作用分别是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Cookie%E3%80%81LocalStorage%E3%80%81SessionStorage%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3. Cookie、LocalStorage、SessionStorage区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%89%8D%E7%AB%AF%E5%82%A8%E5%AD%98%E7%9A%84%E2%BD%85%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">4. 前端储存的⽅式有哪些？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-IndexedDB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">5. IndexedDB有哪些特点？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">七、浏览器同源策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">1. 什么是同源策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E8%B6%8A%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2. 如何解决跨越问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89CORS\"><span class=\"toc-text\">（1）CORS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91OPTIONS%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">减少OPTIONS请求次数：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#CORS%E4%B8%ADCookie%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">CORS中Cookie相关问题：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89JSONP\"><span class=\"toc-text\">（2）JSONP</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89postMessage-%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">（3）postMessage 跨域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%884%EF%BC%89nginx%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">（4）nginx代理跨域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%885%EF%BC%89nodejs-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">（5）nodejs 中间件代理跨域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%886%EF%BC%89document-domain-iframe%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">（6）document.domain + iframe跨域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%887%EF%BC%89location-hash-iframe%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">（7）location.hash + iframe跨域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%888%EF%BC%89window-name-iframe%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">（8）window.name + iframe跨域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%889%EF%BC%89WebSocket%E5%8D%8F%E8%AE%AE%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">（9）WebSocket协议跨域</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3. 正向代理和反向代理的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Nginx%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4. Nginx的概念及其工作原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">八、浏览器事件机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%9F\"><span class=\"toc-text\">1. 事件是什么？事件模型？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1\"><span class=\"toc-text\">2. 如何阻止事件冒泡</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">3. 对事件委托的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">（1）事件委托的概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">（2）事件委托的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89%E5%B1%80%E9%99%90%E6%80%A7\"><span class=\"toc-text\">（3）局限性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">4. 事件委托的使用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">5. 同步和异步的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">6. 对事件循环的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">7. 宏任务和微任务分别有哪些</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E6%A0%88\"><span class=\"toc-text\">8. 什么是执行栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-Node-%E4%B8%AD%E7%9A%84-Event-Loop-%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9Fprocess-nextTick-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F\"><span class=\"toc-text\">9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">10. 事件触发的过程是怎样的</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">九、浏览器垃圾回收机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">1. V8的垃圾回收机制是怎样的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F\"><span class=\"toc-text\">2. 哪些操作会造成内存泄漏？</span></a></li></ol></li></ol>","author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}},"mapped":true,"prev_post":{"title":"性能优化面试题","uid":"d1e27f3ed5a223dfa20286d938d4cd8c","slug":"性能优化面试题","date":"2022-04-10T12:21:21.000Z","updated":"2022-04-10T12:21:47.389Z","comments":true,"path":"api/articles/性能优化面试题.json","keywords":null,"cover":[],"text":"一、CDN1. CDN的概念CDN（Content Delivery Network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"知识点","slug":"知识点","count":18,"path":"api/categories/知识点.json"}],"tags":[{"name":"面试","slug":"面试","count":13,"path":"api/tags/面试.json"}],"author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}}},"next_post":{"title":"JavaScript面试题","uid":"f9ba258d0c41d5b94c171702acf48433","slug":"JavaScript面试题","date":"2022-04-10T12:17:20.000Z","updated":"2022-04-10T12:19:49.477Z","comments":true,"path":"api/articles/JavaScript面试题.json","keywords":null,"cover":[],"text":"一、数据类型1. JavaScript有哪些数据类型，它们的区别？JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。 其中 Symbol 和 BigInt 是ES6 中...","link":"","photos":[],"count_time":{"symbolsCount":"78k","symbolsTime":"1:11"},"categories":[{"name":"知识点","slug":"知识点","count":18,"path":"api/categories/知识点.json"}],"tags":[{"name":"面试","slug":"面试","count":13,"path":"api/tags/面试.json"}],"author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}}}}