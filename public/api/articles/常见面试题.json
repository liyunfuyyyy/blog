{"title":"常见面试题","uid":"6b84c0d3e410fe11d0fe91aaed5aa6b2","slug":"常见面试题","date":"2022-04-10T12:13:17.000Z","updated":"2022-04-10T12:14:09.277Z","comments":true,"path":"api/articles/常见面试题.json","keywords":null,"cover":[],"content":"<h2 id=\"1-为什么-0-1-0-2-0-3\"><a href=\"#1-为什么-0-1-0-2-0-3\" class=\"headerlink\" title=\"1. 为什么 0.1+0.2!==0.3\"></a>1. 为什么 0.1+0.2!==0.3</h2><p><strong>计算机使用二进制存储数据</strong></p>\n<ul>\n<li>整数转换二进制没有误差，如 9 转换为二进制是 1001</li>\n<li>而小数可能无法用二进制准确表达，如 0.2 转换为 0.20000001</li>\n<li>可以用<code>math.js</code> 库解决</li>\n</ul>\n<h2 id=\"2-Ajax-Fetch-Axios-三者有什么区别\"><a href=\"#2-Ajax-Fetch-Axios-三者有什么区别\" class=\"headerlink\" title=\"2. Ajax-Fetch-Axios 三者有什么区别\"></a>2. Ajax-Fetch-Axios 三者有什么区别</h2><p><strong>三者都用于网络请求，但是不同维度</strong></p>\n<ul>\n<li>Ajax 是一种技术统称</li>\n<li>Fetch 是一个具体的 API，支持 Promise</li>\n<li>Axios 是第三方库</li>\n<li><strong>lib 和 API 的区别</strong></li>\n</ul>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">ajax</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> successFn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">const</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  xhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  xhr<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onreadystateChange</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 这里的函数异步执行</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">==</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">successFn</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>responseText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n  xhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">ajax</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> res<span class=\"token punctuation\">.</span>json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3-节流和防抖\"><a href=\"#3-节流和防抖\" class=\"headerlink\" title=\"3. 节流和防抖\"></a>3. 节流和防抖</h2><ul>\n<li>节流：限制执行频率，有节奏的执行</li>\n<li>防抖：限制执行次数，多次密集的触发只触发一次</li>\n<li>节流关注<code>过程</code> ，防抖关注<code>结果</code></li>\n<li>实际工作中可用<code>lodash</code></li>\n</ul>\n<p><strong>防抖</strong> 输入框</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">debounce</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> delay <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">let</span> timer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span> <span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    timer <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 透传this和参数</span>\n      timer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> delay<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>节流</strong> banner，拖拽</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> delay <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">let</span> timer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    timer <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      timer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> delay<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"4-px-em-rem-vw-vh-有什么区别\"><a href=\"#4-px-em-rem-vw-vh-有什么区别\" class=\"headerlink\" title=\"4. px % em rem vw vh 有什么区别\"></a>4. px % em rem vw vh 有什么区别</h2><ul>\n<li><code>px</code> 基本单位，绝对单位(其他都是相对单位)</li>\n<li><code>%</code> 相对于父元素的宽度比例</li>\n<li><code>em</code> 相对于当前元素的<code>font-size</code></li>\n<li><code>rem</code> 相对于根节点的<code>font-size</code></li>\n<li><code>vw``vh</code> 屏幕宽度的<code>1%</code>屏幕高度的<code>1%</code></li>\n<li><code>vmin</code> 两者的最小值，<code>vmax</code> 两者的最大值</li>\n</ul>\n<h2 id=\"5-箭头函数\"><a href=\"#5-箭头函数\" class=\"headerlink\" title=\"5. 箭头函数\"></a>5. 箭头函数</h2><p><strong>缺点</strong></p>\n<ul>\n<li>没有<code>arguments</code></li>\n<li>无法通过<code>apply</code> <code>call</code> <code>bind</code> 改变 this</li>\n<li>某些箭头函数代码难以阅读</li>\n</ul>\n<p><strong>不适用的场景</strong></p>\n<ol>\n<li>对象方法不能用箭头函数</li>\n</ol>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"haha\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">getName</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 无打印</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>原型方法</li>\n</ol>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"haha\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">getName</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 无打印</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol start=\"3\">\n<li>构造函数</li>\n</ol>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Foo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> city<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>city <span class=\"token operator\">=</span> city<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"张三\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"成都\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//Foo is not a constructor</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol start=\"4\">\n<li>动态上下文的回调函数</li>\n</ol>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> btn1 <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"btn1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbtn1 <span class=\"token operator\">=</span> <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token string\">\"clicked\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol start=\"5\">\n<li>Vue 生命周期和 method</li>\n</ol>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&#123; data()&#123; return &#123;name:&#39;张三&#39;&#125; &#125;, methods:&#123; getName:()&#x3D;&gt;&#123; return this.name &#125; &#125;,\nmounted:()&#x3D;&gt;&#123; console.log(&#39;msg&#39;,this.name) &#125; &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"6-请描述-TCP-三次握手和四次挥手\"><a href=\"#6-请描述-TCP-三次握手和四次挥手\" class=\"headerlink\" title=\"6. 请描述 TCP 三次握手和四次挥手\"></a>6. 请描述 TCP 三次握手和四次挥手</h2><p><strong>三次握手</strong> - 建立连接</p>\n<ul>\n<li>client 发包，server 接收，server：有 client 要找我</li>\n<li>server 发包，client 接收，client：server 已经收到消息</li>\n<li>client 发包，server 接收，server：client 要准备发送了</li>\n</ul>\n<p><strong>四次挥手</strong> - 断开连接</p>\n<ul>\n<li>client 发包，server 接收，server：知道 client 要断开了</li>\n<li>server 发包，client 接收，server：我知道了，等我传输完</li>\n<li>server 发包，client 接收，server：东西发送完了，可以关闭连接</li>\n<li>client 发包，server 接收，server：收到可以关闭消息，关闭</li>\n</ul>\n<h2 id=\"7-for…in-和-for…of-有什么区别\"><a href=\"#7-for…in-和-for…of-有什么区别\" class=\"headerlink\" title=\"7. for…in 和 for…of 有什么区别\"></a>7. for…in 和 for…of 有什么区别</h2><p><strong>答案</strong></p>\n<ul>\n<li><code>for...in</code> 用于<code>可枚举</code>数据，如对象、数组、字符串，得到 key</li>\n<li><code>for...of</code>用于<code>可迭代</code>数据，如数组、字符串、Map、Set，得到 value</li>\n</ul>\n<p><strong>key 和 value</strong></p>\n<ul>\n<li><code>for...in</code> 遍历得到 key</li>\n<li><code>for...of</code> 遍历得到 value</li>\n</ul>\n<p><strong>适用于不同的数据对象</strong></p>\n<ul>\n<li>遍历对象：<code>for...in</code> 可以，<code>for...of</code> 不可以</li>\n<li>遍历 Map Set：<code>for...in</code> 不可以，<code>for...of</code> 可以</li>\n<li>遍历 generator：<code>for...in</code> 不可以，<code>for...of</code> 可以</li>\n</ul>\n<h2 id=\"8-for-await-…of-有什么用\"><a href=\"#8-for-await-…of-有什么用\" class=\"headerlink\" title=\"8. for await …of 有什么用\"></a>8. for await …of 有什么用</h2><ul>\n<li><code>for await ...of</code> 用于异步，遍历多个 Promise</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">const</span> p1<span class=\"token operator\">=</span><span class=\"token function\">createPromise</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> p2<span class=\"token operator\">=</span><span class=\"token function\">createPromise</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> p3<span class=\"token operator\">=</span><span class=\"token function\">createPromise</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">const</span> list<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>p1<span class=\"token punctuation\">,</span>p2<span class=\"token punctuation\">,</span>p3<span class=\"token punctuation\">]</span>\n  <span class=\"token comment\">// 第一种访问方式</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span><span class=\"token operator\">=></span>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 第二种访问方式</span>\n  <span class=\"token keyword\">for</span> <span class=\"token keyword\">await</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> res <span class=\"token keyword\">of</span> list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>一个一个打印</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> num <span class=\"token keyword\">of</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">createPromise</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"9-offsetHeight-scrollHeight-clientHeight-区别\"><a href=\"#9-offsetHeight-scrollHeight-clientHeight-区别\" class=\"headerlink\" title=\"9. offsetHeight scrollHeight clientHeight 区别\"></a>9. offsetHeight scrollHeight clientHeight 区别</h2><p><strong>计算规则</strong></p>\n<ul>\n<li><code>offsetHeight offsetWidth</code> ：border + padding + content</li>\n<li><code>clientHeight clientWidth</code> ：padding + content</li>\n<li><code>scrollHeight scrollWidth</code> ：padding + 实际内容尺寸</li>\n</ul>\n<h2 id=\"10-HTMLCollection-和-NodeList-区别\"><a href=\"#10-HTMLCollection-和-NodeList-区别\" class=\"headerlink\" title=\"10. HTMLCollection 和 NodeList 区别\"></a>10. HTMLCollection 和 NodeList 区别</h2><ul>\n<li>NodeList 是一个静态集合，其不受 DOM 树元素变化的影响；相当于 DOM 树快照，节点数量和类型的快照，就是对节点增删，NodeList 感受不到，但是对节点内部内容修改，是可以感受到的，比如<code>innerHTML</code></li>\n<li>HTMLCollection 是动态绑定的，是一个动态集合，DOM 树发生变化，HTMLCollection 也会随之变化，节点的增删是敏感的</li>\n<li>只有 NodeList 对象有包含属性节点和文本节点</li>\n<li>HTMLCollection 元素可以通过<code>name</code> <code>id</code> 或<code>index</code> 索引来获取，NodeList 只能通过<code>index</code> 索引来获取</li>\n<li>HTMLCollection 和 NodeList 本身无法使用数组的方法：<code>pop()</code> <code>push()</code> <code>join()</code> 等，除非把他转为一个数组</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> nodelist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelectorAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"div\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nnodelist<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnodelist<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"11-JS-严格模式有什么特点\"><a href=\"#11-JS-严格模式有什么特点\" class=\"headerlink\" title=\"11. JS 严格模式有什么特点\"></a>11. JS 严格模式有什么特点</h2><p><strong>开启严格模式</strong></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//全局开启</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//某个函数开启</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>特点</strong></p>\n<ul>\n<li>不允许使用未声明的变量</li>\n<li>不允许删除变量或对象、函数</li>\n<li>不允许变量重名</li>\n<li>不允许使用八进制</li>\n<li>不允许使用转义字符</li>\n<li>不允许对只读属性赋值</li>\n<li>不允许对一个使用 getter()方法读取的属性进行赋值</li>\n<li>不允许删除一个不允许删除的属性</li>\n<li>变量名不能使用<code>eval</code> <code>arguments</code> 字符串</li>\n<li>不能使用 with 语句</li>\n<li>在作用域 eval()创建的变量不能被调用</li>\n<li>函数在浏览器全局变量中被简单调用，非严格模式下<code>this</code> 指向<code>window</code> 在<code>use strict</code> 指明严格模式的情况下就是<code>undefined</code></li>\n</ul>\n<h2 id=\"12-HTTP-跨域请求时为何发送-options-请求\"><a href=\"#12-HTTP-跨域请求时为何发送-options-请求\" class=\"headerlink\" title=\"12. HTTP 跨域请求时为何发送 options 请求\"></a>12. HTTP 跨域请求时为何发送 options 请求</h2><p><strong>答案</strong></p>\n<ul>\n<li>options 请求，是跨域请求之前的预检查</li>\n<li>浏览器自动发起的，无需我们干预</li>\n<li>不影响实际的功能</li>\n<li>预检查服务端是否支持某种请求方法 如 delete patch post 等</li>\n</ul>\n<p><strong>JSONP 原理：A 网页定义全局函数，请求 B 网页，B 返回一个函数调用，由于在 script 中，所以当作函数执行</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647415319786-6073108d-c760-4d45-a6ed-baadb4b78cda.png\" alt=\"img\"></p>\n<p><strong>cors</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647415417964-cf694c47-27c7-4e07-9e94-1e3d43b9d04e.png\" alt=\"img\"></p>\n<h2 id=\"13-JS-内存垃圾回收用什么算法\"><a href=\"#13-JS-内存垃圾回收用什么算法\" class=\"headerlink\" title=\"13. JS 内存垃圾回收用什么算法\"></a>13. JS 内存垃圾回收用什么算法</h2><p><strong>什么是垃圾回收</strong></p>\n<ul>\n<li>回收那些函数执行完成了，再也用不到的对象和数据</li>\n</ul>\n<p><strong>引用计数（以前）</strong></p>\n<ul>\n<li>所谓引用计数是指语言引擎有一张“引用表”，保存了内存里面所有的资源(通常是各种值)的引用次数，如果一个值的引用次数是 0，就标识这个值不再用到了，因此可以将这块内存释放</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647475929157-cd7f0fea-23c5-4a3a-a77d-29a408751804.png\" alt=\"img\"></p>\n<p><strong>标记清除（现代）算法</strong></p>\n<ul>\n<li>标记阶段<ul>\n<li>遍历所有对象找标记活动的对象</li>\n</ul>\n</li>\n<li>清扫阶段：遍历所有对象清除没有标记的对象，同时会清除第一阶段所作的标记，便于之后可以进行正常的工作</li>\n</ul>\n<h2 id=\"14-闭包是内存泄漏吗\"><a href=\"#14-闭包是内存泄漏吗\" class=\"headerlink\" title=\"14. 闭包是内存泄漏吗\"></a>14. 闭包是内存泄漏吗</h2><ul>\n<li>内存泄漏是非预期的结果</li>\n<li>闭包存在内存中是预期的结果，不算内存泄漏</li>\n<li>闭包数据不可以被回收</li>\n</ul>\n<h2 id=\"15-JS-内存泄漏如何检测，场景有哪些\"><a href=\"#15-JS-内存泄漏如何检测，场景有哪些\" class=\"headerlink\" title=\"15. JS 内存泄漏如何检测，场景有哪些\"></a>15. JS 内存泄漏如何检测，场景有哪些</h2><p><strong>检测</strong></p>\n<ul>\n<li>使用浏览器开发者工具的 Performance</li>\n<li>勾选 memory，触发垃圾回收</li>\n<li>开始检测，触发页面事件</li>\n</ul>\n<p><strong>场景</strong></p>\n<ul>\n<li>被全局遍历、函数引用、组件销毁时未清除</li>\n<li>被全局事件、定时器引用，组件销毁时未清除</li>\n<li>被自定义事件引用，组件销毁时未清除</li>\n</ul>\n<p><strong>扩展</strong></p>\n<ul>\n<li>如果用 Obj 或者 map、set 定义，函数执行完，引用 obj 还在，而 weakmap 和 weakset 是弱引用，函数执行完就清除了 obj，所以 weakmap 只能使用 get 去尝试访问有没有数据</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647477212923-d57d7314-7b42-40a1-aa22-041bf43c8289.png\" alt=\"img\"></p>\n<h2 id=\"16-浏览器和-nodejs-的事件循环有什么区别\"><a href=\"#16-浏览器和-nodejs-的事件循环有什么区别\" class=\"headerlink\" title=\"16. 浏览器和 nodejs 的事件循环有什么区别\"></a>16. 浏览器和 nodejs 的事件循环有什么区别</h2><p><strong>答案</strong></p>\n<ul>\n<li>浏览器和 nodejs 的 event loop 流程基本相同</li>\n<li>nodejs 宏任务和微任务分类型，有优先级</li>\n</ul>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>推荐使用<code>setImmediate</code> 代替<code>process.nextTick</code></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647477791279-ad580ac8-418e-4c72-9ca6-906907a8bead.png\" alt=\"img\"></p>\n<p><strong>nodejs 异步</strong></p>\n<ul>\n<li>nodejs 同样使用 ES 语法，也是单线程，也需要异步</li>\n<li>异步任务也分：宏任务 + 微任务</li>\n<li>但是它的宏任务和微任务分不同类型，有不同优先级</li>\n<li><strong>宏任务优先级</strong><ul>\n<li><code>timers</code></li>\n<li><code>I/O callbacks</code></li>\n<li><code>idls prepare</code></li>\n<li><code>poll</code></li>\n<li><code>check</code></li>\n<li><code>close callbacks</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>nodejs event loop</strong></p>\n<ul>\n<li>执行同步任务</li>\n<li>执行微任务(process.nextTick 优先级更高)</li>\n<li>按顺序执行 6 个类型的宏任务(每个结束时都执行当前的微任务)</li>\n</ul>\n<h2 id=\"17-VDOM-真的很快吗\"><a href=\"#17-VDOM-真的很快吗\" class=\"headerlink\" title=\"17. VDOM 真的很快吗\"></a>17. VDOM 真的很快吗</h2><p><strong>答案</strong></p>\n<ul>\n<li>vdom 并不快，JS 直接操作 DOM 才是最快的</li>\n<li>但“数据驱动视图”要有合适的技术方案，不能全部 DOM 重建</li>\n<li>vdom 就是目前最合适的技术方案(并不是因为它块，而是合适)</li>\n</ul>\n<h2 id=\"18-遍历一个数组用-for-和-forEach-哪个更快\"><a href=\"#18-遍历一个数组用-for-和-forEach-哪个更快\" class=\"headerlink\" title=\"18. 遍历一个数组用 for 和 forEach 哪个更快\"></a>18. 遍历一个数组用 for 和 forEach 哪个更快</h2><p><strong>答案</strong></p>\n<ul>\n<li>for 更快</li>\n<li>forEach 每次都要创建一个函数来调用，而 for 不会创建函数</li>\n<li>函数需要独立的作用域，会有额外的开销</li>\n</ul>\n<h2 id=\"19-nodejs-如何开启线程，进程如何通讯\"><a href=\"#19-nodejs-如何开启线程，进程如何通讯\" class=\"headerlink\" title=\"19. nodejs 如何开启线程，进程如何通讯\"></a>19. nodejs 如何开启线程，进程如何通讯</h2><p><strong>答案</strong></p>\n<ul>\n<li>开启子进程<code>child_process.fork</code> 和<code>cluster.fork</code></li>\n<li>使用<code>send</code> 和<code>on</code> 传递消息</li>\n</ul>\n<p><strong>进程 process vs 线程 Thread</strong></p>\n<ul>\n<li>进程：OS 进行资源分配和调度的最小单位，有独立内存空间</li>\n<li>线程：OS 进行运算调度的最小单位，共享进程内存空间</li>\n<li>JS 是单线程的，但可以开启多进程执行，如 WebWorker</li>\n</ul>\n<p><strong>为何需要多进程</strong></p>\n<ul>\n<li>多核 CPU，更适合处理多进程</li>\n<li>内存较大，多个进程才能更好的利用(单进程有内存上限)</li>\n<li>总之，“压榨”机器资源，更快，更节省</li>\n</ul>\n<p><strong>nodejs 开启多进程</strong></p>\n<ul>\n<li>主进程</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fork <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"child_process\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fork<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url <span class=\"token operator\">===</span> <span class=\"token string\">\"/get-sum\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"主进程 id\"</span><span class=\"token punctuation\">,</span> process<span class=\"token punctuation\">.</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 开启子进程</span>\n    <span class=\"token keyword\">const</span> computeProcess <span class=\"token operator\">=</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./compute.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    computeProcess<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"开始计算\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    computeProcess<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"主进程接受到的信息：\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sum is \"</span> <span class=\"token operator\">+</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    computeProcess<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"close\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子进程因报错而退出\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      computeProcess<span class=\"token punctuation\">.</span><span class=\"token function\">kill</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"error\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"localhost: 3000\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>子进程</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @description 子进程，计算\n * @author 双越老师\n */</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getSum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\nprocess<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子进程 id\"</span><span class=\"token punctuation\">,</span> process<span class=\"token punctuation\">.</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子进程接受到的信息: \"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> sum <span class=\"token operator\">=</span> <span class=\"token function\">getSum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 发送消息给主进程</span>\n  process<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"20-请描述-JS-Bridge-原理\"><a href=\"#20-请描述-JS-Bridge-原理\" class=\"headerlink\" title=\"20. 请描述 JS Bridge 原理\"></a>20. 请描述 JS Bridge 原理</h2><p><strong>什么是 JS Bridge</strong></p>\n<p>在 Hybrid 模式下，H5 经常需要使用 Native 的功能，Native 需要向 web 端发送推送更新状态，而 JS 是运行在单独的 JS Context 中，与原生运行环境相隔离，所以需要有一种机制实现 Native 和 web 端的双向通信，这就是 JSBridge</p>\n<ul>\n<li>JS 无法直接调用 native API</li>\n<li>需要一些特定的格式来调用</li>\n<li>这些格式统称 JS-Bridge 例如微信 JSSDK</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647482982390-8916359d-5bef-47f8-b497-3699b633e034.png\" alt=\"img\"></p>\n<h2 id=\"21-requestIdleCallback-和-requestAnimationFrame-区别\"><a href=\"#21-requestIdleCallback-和-requestAnimationFrame-区别\" class=\"headerlink\" title=\"21. requestIdleCallback 和 requestAnimationFrame 区别\"></a>21. requestIdleCallback 和 requestAnimationFrame 区别</h2><p><strong>区别</strong></p>\n<ul>\n<li><code>requestAnimationFrame</code> 每次渲染完都会执行，高优</li>\n<li><code>requestIdleCallback</code> 空闲时才执行，低优</li>\n</ul>\n<p><strong>它们是宏任务还是微任务</strong></p>\n<ul>\n<li>两者都是宏任务</li>\n<li>要等待 DOM 渲染完才执行，肯定是宏任务</li>\n</ul>\n<h2 id=\"22-Vue-每个生命周期都做了什么\"><a href=\"#22-Vue-每个生命周期都做了什么\" class=\"headerlink\" title=\"22. Vue 每个生命周期都做了什么\"></a>22. Vue 每个生命周期都做了什么</h2><p><strong>beforeCreate</strong></p>\n<ul>\n<li>创建一个空白的 Vue 实例</li>\n<li>data method 尚未被初始化，不可使用</li>\n</ul>\n<p><strong>created</strong></p>\n<ul>\n<li>Vue 实例初始化完成，完成响应式绑定</li>\n<li>data method 都已经初始化完成，可调用</li>\n<li>尚未开始渲染模板</li>\n</ul>\n<p><strong>beforeMount</strong></p>\n<ul>\n<li>编译模板，调用 render 生成 vdom</li>\n<li>还没有开始渲染 DOM</li>\n</ul>\n<p><strong>mounted</strong></p>\n<ul>\n<li>完成 DOM 渲染</li>\n<li>组件创建完成</li>\n<li>开始由“创建阶段”进入“运行阶段”</li>\n</ul>\n<p><strong>beforeUpdate</strong></p>\n<ul>\n<li>data 发生变化之后</li>\n<li>准备更新 DOM（尚未更新 DOM）</li>\n</ul>\n<p><strong>updated</strong></p>\n<ul>\n<li>data 发生变化，且 DOM 更新完成</li>\n<li>（不要再 updated 中修改 data，可能会导致死循环）</li>\n</ul>\n<p><strong>beforeUnmount</strong></p>\n<ul>\n<li>组件进入销毁阶段（尚未销毁，可正常使用）</li>\n<li>可移动、解绑一些全局事件、自定义事件</li>\n</ul>\n<p><strong>unmounted</strong></p>\n<ul>\n<li>组件被销毁</li>\n<li>所有子组件也被销毁了</li>\n</ul>\n<p><strong>keep-alive 组件</strong></p>\n<ul>\n<li>onActivated 缓存组件被激活</li>\n<li>onDeactivated 缓存组件被隐藏</li>\n</ul>\n<h2 id=\"连环问-vue-什么时候操作-DOM-比较合适\"><a href=\"#连环问-vue-什么时候操作-DOM-比较合适\" class=\"headerlink\" title=\"连环问 vue 什么时候操作 DOM 比较合适\"></a>连环问 vue 什么时候操作 DOM 比较合适</h2><ul>\n<li>mounted 和 updated 都不能保证子组件全部挂载完成</li>\n<li>使用$nextTick 渲染 DOM</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647484709351-01352c82-2dbb-41d8-8ddb-6eedc9df277f.png\" alt=\"img\"></p>\n<h2 id=\"连环问-Ajax-应该在哪个生命周期\"><a href=\"#连环问-Ajax-应该在哪个生命周期\" class=\"headerlink\" title=\"连环问 Ajax 应该在哪个生命周期\"></a>连环问 Ajax 应该在哪个生命周期</h2><ul>\n<li>有两个选择：created 和 mounted</li>\n<li>推荐：mounted</li>\n</ul>\n<h2 id=\"连环问-Vue3-Composition-API-生命周期有何区别\"><a href=\"#连环问-Vue3-Composition-API-生命周期有何区别\" class=\"headerlink\" title=\"连环问 Vue3 Composition API 生命周期有何区别\"></a>连环问 Vue3 Composition API 生命周期有何区别</h2><ul>\n<li>用 setup 代替了 beforeCreate 和 created</li>\n<li>使用 Hooks 函数的形式，比如 mounted 改为 onMounted</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647484892946-e1b28e67-df7f-407d-8ca4-1cf3ef9df10c.png\" alt=\"img\"></p>\n<h2 id=\"23-Vue2-Vue3-React-三者-diff-算法有何区别\"><a href=\"#23-Vue2-Vue3-React-三者-diff-算法有何区别\" class=\"headerlink\" title=\"23. Vue2 Vue3 React 三者 diff 算法有何区别\"></a>23. Vue2 Vue3 React 三者 diff 算法有何区别</h2><p><strong>相同点</strong></p>\n<ul>\n<li>只比较同一层级，不跨级比较</li>\n<li>tag 不同则删除重建</li>\n<li>子节点通过 key 区分</li>\n</ul>\n<p><strong>区别</strong></p>\n<ul>\n<li>React diff - 仅右移</li>\n<li>Vue2 双端比较 - 四个指针相互比较</li>\n<li>Vue3 最长递增子序列</li>\n</ul>\n<h2 id=\"连环问-Vue-React-为何循环时必须使用-key\"><a href=\"#连环问-Vue-React-为何循环时必须使用-key\" class=\"headerlink\" title=\"连环问 Vue React 为何循环时必须使用 key\"></a>连环问 Vue React 为何循环时必须使用 key</h2><ul>\n<li>vdom diff 算法会根据 key 判断元素是否要删除</li>\n<li>匹配了 key，则只移动元素 - 性能较好</li>\n<li>未匹配 key，则删除重建 - 性能较差</li>\n</ul>\n<h2 id=\"24-Vue-router-和-MemoryHistory-是什么\"><a href=\"#24-Vue-router-和-MemoryHistory-是什么\" class=\"headerlink\" title=\"24. Vue-router 和 MemoryHistory 是什么\"></a>24. Vue-router 和 MemoryHistory 是什么</h2><p><strong>Vue-router 三种模式</strong></p>\n<ul>\n<li>hash<ul>\n<li>通过<code>location.hash</code> 实现的</li>\n</ul>\n</li>\n<li>WebHistory<ul>\n<li>通过<code>history.pushState</code> <code>window.onpopState</code> 实现</li>\n</ul>\n</li>\n<li>MemoryHistory<ul>\n<li>跳转页面 路由不变</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"25-移动端-H5-click-有-300ms-延迟，该如何解决\"><a href=\"#25-移动端-H5-click-有-300ms-延迟，该如何解决\" class=\"headerlink\" title=\"25. 移动端 H5 click 有 300ms 延迟，该如何解决\"></a>25. 移动端 H5 click 有 300ms 延迟，该如何解决</h2><p><strong>初期解决方案 FastClick</strong></p>\n<ul>\n<li>原理：监听 touchend 事件（touchstart touchend 会先于 click 触发）</li>\n<li>使用<strong>自定义 DOM</strong>事件模拟一个 click 事件</li>\n<li>把默认的 click 事件(300ms 之后触发)禁止掉</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/1356933/1647491547551-48854d9f-a142-47a4-98eb-8243eafcdf52.png\" alt=\"img\"></p>\n<p><strong>现代浏览器的改进</strong></p>\n<ul>\n<li>只要浏览器里面有<code>width=device-width</code>就不会有 300ms 延迟</li>\n<li>手机认为你已经做了响应式了，不需要 300ms 延迟了</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/1356933/1647491677034-bcd5ce31-1b7d-442f-8c26-664b577d26c3.png\" alt=\"img\"></p>\n<h2 id=\"26-网络请求中，token-和-cookie-有什么区别\"><a href=\"#26-网络请求中，token-和-cookie-有什么区别\" class=\"headerlink\" title=\"26. 网络请求中，token 和 cookie 有什么区别\"></a>26. 网络请求中，token 和 cookie 有什么区别</h2><ul>\n<li><code>cookie</code> :HTTP 标准，跨域限制，配合 session 使用</li>\n<li><code>token</code> ：无标准，无跨域限制，用于 JWT</li>\n</ul>\n<p><strong>现代浏览器开始禁止第三方 cookie 使用 samsite</strong></p>\n<ul>\n<li>samsite：stick/lax/none 严格模式，松散模式，没有限制</li>\n</ul>\n<p><strong>cookie 和 session</strong></p>\n<ul>\n<li>cookie 用于登录验证，存储用户标识</li>\n<li>session 在服务端，存储用户详细信息，和 cookie 信息一一对应</li>\n<li>cookie + session 是常见登录验证解决方案</li>\n</ul>\n<p><strong>token vs cookie</strong></p>\n<ul>\n<li>cookie 是 HTTP 规范，而 token 是自定义传递</li>\n<li>cookie 会默认被浏览器传递，而 token 需自己传递</li>\n<li>token 默认没有跨域限制</li>\n</ul>\n<p><strong>JWT（JSON Web Token）</strong></p>\n<ul>\n<li>前端发起登录，后端验证成功之后，返回一个加密的 token</li>\n<li>前端自行存储这个 token(其中包含了用户信息)</li>\n<li>以后访问服务端就带上这个 token</li>\n</ul>\n<h2 id=\"27-session-和-JWT-哪个更好\"><a href=\"#27-session-和-JWT-哪个更好\" class=\"headerlink\" title=\"27. session 和 JWT 哪个更好\"></a>27. session 和 JWT 哪个更好</h2><p><strong>答案</strong></p>\n<ul>\n<li>如有严格管理用户信息的需求(保密，快速封禁)推荐 session</li>\n<li>如没有特殊要求，则使用 JWT</li>\n</ul>\n<p><strong>session 优点</strong></p>\n<ul>\n<li>原理简单，易于学习</li>\n<li>用户信息存储在服务端，可快速封禁某个用户</li>\n</ul>\n<p><strong>session 缺点</strong></p>\n<ul>\n<li>占用服务器内存，硬件成本高</li>\n<li>多进程，多服务器，不好同步 - 需使用第三方缓存，如 redis</li>\n<li>不同 session 存储在不同进程中，需要使用 redis 统一管理 session</li>\n<li>默认有跨域限制</li>\n</ul>\n<p><strong>JWT 优点</strong></p>\n<ul>\n<li>不占用服务端内存</li>\n<li>多进程，多服务器不受影响</li>\n<li>没有跨域限制</li>\n</ul>\n<p><strong>JWT 缺点</strong></p>\n<ul>\n<li>用户信息存储在客户端，无法快速封禁某用户</li>\n<li>万一服务端密钥被泄漏，则用户信息全部丢失</li>\n<li>token 体积一般大于 cookie，会增加请求的数据量</li>\n</ul>\n<h2 id=\"28-如何实现-SSO-单点登录\"><a href=\"#28-如何实现-SSO-单点登录\" class=\"headerlink\" title=\"28. 如何实现 SSO 单点登录\"></a>28. 如何实现 SSO 单点登录</h2><p><strong>基于 cookie</strong></p>\n<ul>\n<li>cookie 默认不可跨域共享，但某些情况下可设置为共享</li>\n<li>主域名相同，如<a href=\"http://www.baidu.com/\">www.baidu.com</a> image.baidu.com</li>\n<li>设置 cookie domain 为主域名，即可共享 cookie</li>\n</ul>\n<p><strong>SSO</strong></p>\n<ul>\n<li>浏览器访问 A，A 重定向 SSO 网站，登陆后返回 ticket</li>\n<li>浏览器访问 B，B 重定向 SSO 网站，登录后返回 ticket</li>\n<li>当客户端登陆过 A 之后，去访问 B，B 就拿到 ticket 去找 SSO 校验</li>\n</ul>\n<p><strong>OAuth 2.0</strong></p>\n<ul>\n<li>第三方登录</li>\n</ul>\n<h2 id=\"29-HTTP-协议和-UDP-协议有什么区别\"><a href=\"#29-HTTP-协议和-UDP-协议有什么区别\" class=\"headerlink\" title=\"29. HTTP 协议和 UDP 协议有什么区别\"></a>29. HTTP 协议和 UDP 协议有什么区别</h2><p><strong>答案</strong></p>\n<ul>\n<li>HTTP 是应用层，TCP UDP 是传输层</li>\n<li>TCP 有连接，有断开，稳定传输</li>\n<li>UDP 无连接，无断开，不稳定传输，但效率高</li>\n</ul>\n<p><strong>网络协议</strong></p>\n<ul>\n<li>HTTP 协议在应用层</li>\n<li>TCP UDP 协议在传输层</li>\n</ul>\n<p><strong>TCP 协议</strong></p>\n<ul>\n<li>有连接(三次握手)</li>\n<li>有断开(四次挥手)</li>\n<li>稳定传输</li>\n</ul>\n<p><strong>UDP 协议</strong></p>\n<ul>\n<li>无连接，无断开</li>\n<li>不稳定传输，但效率高</li>\n<li>如视频会议，语音通话</li>\n</ul>\n<h2 id=\"30-HTTP-协议-1-0-1-1-2-0-有什么区别\"><a href=\"#30-HTTP-协议-1-0-1-1-2-0-有什么区别\" class=\"headerlink\" title=\"30. HTTP 协议 1.0 1.1 2.0 有什么区别\"></a>30. HTTP 协议 1.0 1.1 2.0 有什么区别</h2><p><strong>HTTP1.0</strong></p>\n<ul>\n<li>最基本的 HTTP 协议</li>\n<li>支持基本的 GET POST 方法</li>\n</ul>\n<p><strong>HTTP1.1</strong></p>\n<ul>\n<li>增加了缓存策略<code>cache-control</code> <code>e-tag</code> 等</li>\n<li>支持长连接<code>Connection:keep-alive</code> 一次 TCP 连接多次请求</li>\n<li>支持断点续传，状态码 206</li>\n<li>支持新的方法 PUT DELETE 等，可用于 Restful API</li>\n</ul>\n<p><strong>HTTP2.0</strong></p>\n<ul>\n<li>可压缩 header，减少体积</li>\n<li>多路复用，一次 TCP 连接中可以多个 HTTP 请求</li>\n<li>服务端推送，websocket</li>\n</ul>\n<h2 id=\"31-什么是-HTTPS-中间人攻击，如何预防\"><a href=\"#31-什么是-HTTPS-中间人攻击，如何预防\" class=\"headerlink\" title=\"31. 什么是 HTTPS 中间人攻击，如何预防\"></a>31. 什么是 HTTPS 中间人攻击，如何预防</h2><p><strong>HTTPS 加密传输</strong></p>\n<ul>\n<li>http 明文传输</li>\n<li>httos 加密传输 HTTP + TLS/SSL</li>\n</ul>\n<p>当使用对称加密时用的同一套密钥，会被黑客劫持解密出来</p>\n<p>非对称加密，公钥加密，私钥解密，但是如果有中间黑客，把自己的公钥给客户端，客户端发送的时候再劫持用自己的私钥解开</p>\n<p>先使用非对称加密建立连接，然后使用对称加密传输数据</p>\n<p><strong>预防</strong> ：服务器使用 CA 证书，浏览器就能知道这个公钥是不是合法的</p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647495776353-1fc37c70-70a3-42f6-933f-3af0e06e1792.png\" alt=\"img\"></p>\n<h2 id=\"32-script-标签的-defer-和-async-有什么区别\"><a href=\"#32-script-标签的-defer-和-async-有什么区别\" class=\"headerlink\" title=\"32. script 标签的 defer 和 async 有什么区别\"></a>32. script 标签的 defer 和 async 有什么区别</h2><p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647495910968-4306deed-8de1-4d7f-afb8-1a4d6fdb85b7.png\" alt=\"img\"></p>\n<ul>\n<li>defer 并行加载，延迟执行</li>\n<li>async 并行加载，加载完立刻执行，阻塞 HTML</li>\n</ul>\n<h2 id=\"33-prefetch-和-dns-prefetch-有什么区别\"><a href=\"#33-prefetch-和-dns-prefetch-有什么区别\" class=\"headerlink\" title=\"33. prefetch 和 dns-prefetch 有什么区别\"></a>33. prefetch 和 dns-prefetch 有什么区别</h2><p><strong>答案</strong></p>\n<ul>\n<li>prefetch 是资源预获取（和 preload 有关）</li>\n<li>dns-prefetch 是 DNS 预查询（和 preconnect 相关）</li>\n</ul>\n<p><strong>preload 和 prefetch</strong></p>\n<ul>\n<li>preload 资源再当前页面使用，会<code>优先</code>加载</li>\n<li>prefetch 资源在未来页面使用，<code>空闲时</code>加载</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647496293543-4b59745b-83e8-4a48-9364-e922549a4039.png\" alt=\"img\"></p>\n<p><strong>dns-prefetch 和 preconnect</strong></p>\n<ul>\n<li>dns-prefetch 即 DNS 预查询</li>\n<li>preconnect 即 DNS 预连接</li>\n</ul>\n<h2 id=\"34-你知道哪些前端攻击，该如何预防\"><a href=\"#34-你知道哪些前端攻击，该如何预防\" class=\"headerlink\" title=\"34. 你知道哪些前端攻击，该如何预防\"></a>34. 你知道哪些前端攻击，该如何预防</h2><p><strong>XSS</strong></p>\n<ul>\n<li>Scross Site Script 跨站脚本攻击</li>\n<li>手段：黑客将 JS 代码插入到网页内容中，渲染时执行 JS 代码</li>\n<li>预防：特殊字符替换(前端或者后端)</li>\n<li>只要 vue 和 react 不用 v-html 或 dangerouselySetInnerHTML 就可以预防</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647497073944-4262957b-b9f0-4bf4-8bf4-0edfdc1d0aa0.png\" alt=\"img\"></p>\n<p><strong>CSRF</strong></p>\n<ul>\n<li>Cross Site Request Forgery 跨站请求伪造</li>\n<li>手段：黑客诱导用户去访问另一个网站的接口，伪造请求</li>\n<li>预防：严格的跨域限制 + 验证码机制</li>\n</ul>\n<p><strong>CSRF 详细过程</strong></p>\n<ul>\n<li>用户登陆了 A 网站，有了 cookie</li>\n<li>黑客诱导用户到 B 网站，并发起 A 网站的请求</li>\n<li>A 网站的 API 发现有 cookie，以为是用户自己操作的</li>\n</ul>\n<p><strong>点击劫持</strong></p>\n<ul>\n<li>Click Jacking</li>\n<li>手段：诱导界面上蒙一个透明的 iframe，诱导用户点击</li>\n<li>预防：让 iframe 不能跨域加载</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647497559975-76f42309-4600-4e5e-8acd-28ca82864548.png\" alt=\"img\"></p>\n<p><strong>DDos</strong></p>\n<ul>\n<li>Distribute denial-of-service 分布式拒绝服务</li>\n<li>手段：分布式的，大规模的流量访问，使服务器瘫痪</li>\n<li>预防：软件层不好做，需硬件预防(如阿里云 WAF)</li>\n</ul>\n<p><strong>SQL 注入</strong></p>\n<ul>\n<li>手段：黑客提交内容时写入 SQL 语句，破坏数据库</li>\n<li>预防：处理输入的内容，替换特殊字符</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647498240471-d8003c37-24d1-4caf-b537-bbc8c583c69e.png\" alt=\"img\"></p>\n<h2 id=\"35-WebSocket-和-HTTP-区别\"><a href=\"#35-WebSocket-和-HTTP-区别\" class=\"headerlink\" title=\"35. WebSocket 和 HTTP 区别\"></a>35. WebSocket 和 HTTP 区别</h2><p><strong>答案</strong></p>\n<ul>\n<li>websocket 协议名是 ws://，可双端发送请求</li>\n<li>websocket 没有跨域限制</li>\n<li>通过 send 和 onmessage 通讯(http 通过 req 和 res)</li>\n</ul>\n<p><strong>WebSocket</strong></p>\n<ul>\n<li>支持端对端通讯</li>\n<li>可以有 client 发起，也可以由 server 发起</li>\n<li>用于：消息通知，直播间讨论区，聊天室，协同编辑</li>\n<li>ws 可升级为 wss(像 https)</li>\n<li>实际项目中推荐<code>socket.io</code> 实现</li>\n<li>客户端</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647498649695-c35ed899-3ff1-4ccd-b42d-4d07ac77915f.png\" alt=\"img\"></p>\n<ul>\n<li>服务端</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647498675330-cb2c979d-2ea0-4cff-81c0-2efdc9b77997.png\" alt=\"img\"></p>\n<p><strong>WebSocket 连接过程</strong></p>\n<ul>\n<li>先发起一个 HTTP 请求</li>\n<li>成功之后再升级到 WebSocket 协议，再通讯</li>\n</ul>\n<h2 id=\"36-WebSocket-和-HTTP-长轮询的区别\"><a href=\"#36-WebSocket-和-HTTP-长轮询的区别\" class=\"headerlink\" title=\"36. WebSocket 和 HTTP 长轮询的区别\"></a>36. WebSocket 和 HTTP 长轮询的区别</h2><ul>\n<li>HTTP 长轮询：客户端发送请求，服务端阻塞，不回立即返回</li>\n<li>WebSocket：客户端可发送请求，服务端也可发起请求</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>HTTP 长轮询，需处理 timeout，即 timeout 之后重新发送请求</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647523786488-0fd9cd8d-13d7-4e32-b362-f5e356671353.png\" alt=\"img\"></p>\n<h2 id=\"37-描述从输入-url-到页面展示的完整过程\"><a href=\"#37-描述从输入-url-到页面展示的完整过程\" class=\"headerlink\" title=\"37. 描述从输入 url 到页面展示的完整过程\"></a>37. 描述从输入 url 到页面展示的完整过程</h2><ol>\n<li>网络请求：DNS 解析，HTTP 请求</li>\n<li>解析：DOM 树，CSSDOM 树，Render Tree</li>\n<li>渲染：计算、绘制、同时执行 JS</li>\n</ol>\n<p><strong>网络请求</strong></p>\n<ol>\n<li>DNS 查询(得到 IP)，建立 TCP 连接(三次握手)</li>\n<li>浏览器发送 HTTP 请求</li>\n<li>收到请求响应，得到 HTML 源代码</li>\n<li>解析 HTML 过程中，遇到静态资源还会继续发起网络请求</li>\n<li>JS CSS 图片 视频等</li>\n<li>注意：静态资源可能有强缓存，此时不必请求</li>\n</ol>\n<p><strong>结构化</strong></p>\n<ol>\n<li>字符串-&gt;结构化数据</li>\n<li>HTML 构建 DOM 树</li>\n<li>CSS 构建 CSSDOM 树(style tree)</li>\n<li>两者结合，形成 render tree</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647524219949-f5ec446e-a4c3-46e5-b20b-0c85476e2e67.png\" alt=\"img\"></p>\n<p><strong>渲染：Render Tree 绘制到页面</strong></p>\n<ul>\n<li>计算各个 DOM 的尺寸、定位，最后绘制到页面</li>\n<li>遇到 JS 可能会执行(参考 defer async)</li>\n<li>异步 CSS、图片加载，可能会触发重新渲染</li>\n</ul>\n<h2 id=\"38-网页重绘-repain-和重排-reflow-有什么区别\"><a href=\"#38-网页重绘-repain-和重排-reflow-有什么区别\" class=\"headerlink\" title=\"38. 网页重绘 repain 和重排 reflow 有什么区别\"></a>38. 网页重绘 repain 和重排 reflow 有什么区别</h2><p><strong>动态网页，随时都会重绘，重排</strong></p>\n<ul>\n<li>网页动画</li>\n<li>Modal Dialog 弹窗</li>\n<li>增加/删除一个元素，显示/隐藏一个元素</li>\n</ul>\n<p><strong>重绘 repain</strong></p>\n<ul>\n<li>元素外观改变，如颜色、背景色</li>\n<li>但元素的尺寸、定位不变，不会影响其他元素的位置</li>\n</ul>\n<p><strong>重排 reflow</strong></p>\n<ul>\n<li>重新计算尺寸和布局，可能会影响其他元素的位置</li>\n<li>如元素高度增减，可能使相邻元素位置不变</li>\n</ul>\n<p><strong>区别</strong></p>\n<ul>\n<li>重排比重绘影响要大，消耗也更大</li>\n<li>所以，要尽量避免无意义的重排</li>\n</ul>\n<p><strong>优化</strong></p>\n<ul>\n<li>集中修改样式，或直接切换 css class</li>\n<li>修改之前先设置<code>display:none</code> 脱离标准文档流</li>\n<li>使用 BFC 特性，不影响其他元素位置</li>\n<li>频繁触发使用节流和防抖</li>\n<li>使用 createDocumentFragment 批量操作 DOM</li>\n<li>优化动画，使用 CSS3 和 requestAnimationFrame</li>\n</ul>\n<p><strong>触发 BFC 的条件</strong></p>\n<ul>\n<li>根节点&lt;html&gt;</li>\n<li><code>float:left/right</code></li>\n<li><code>overflow:auto/hidden</code></li>\n<li><code>display:inline-block/table/table-row/table-cell</code></li>\n<li><code>display:flex/grid</code> 的直接子元素</li>\n<li><code>position:absolute/fixed</code></li>\n</ul>\n<h2 id=\"39-如何实现网页多标签-tab-通讯\"><a href=\"#39-如何实现网页多标签-tab-通讯\" class=\"headerlink\" title=\"39. 如何实现网页多标签 tab 通讯\"></a>39. 如何实现网页多标签 tab 通讯</h2><p><strong>答案</strong></p>\n<ul>\n<li>WebSocket 需要服务器，成本较高</li>\n<li>localStorage 简单易用，推荐</li>\n<li>SharedWorker 调试不方便，不兼容 IE11</li>\n</ul>\n<p><strong>使用 websocket 通讯</strong></p>\n<ul>\n<li>无跨域限制</li>\n<li>需要服务端支持，成本高</li>\n</ul>\n<p><strong>使用 localStorage 通讯</strong></p>\n<ul>\n<li>同域的 A 和 B 两个页面</li>\n<li>A 页面设置 localStorage</li>\n<li>B 页面可监听到 localStorage 值的修改</li>\n</ul>\n<p><strong>通过 SharedWorker 通讯</strong></p>\n<ul>\n<li>SharedWorker 使 WebWorker 的一种</li>\n<li>WebWorker 可开启进程执行 JS，但不能操作 DOM</li>\n<li>SharedWorker 可单独开启一个进程，用于同域页面通讯</li>\n</ul>\n<h2 id=\"40-网页和-iframe-之间的通讯\"><a href=\"#40-网页和-iframe-之间的通讯\" class=\"headerlink\" title=\"40. 网页和 iframe 之间的通讯\"></a>40. 网页和 iframe 之间的通讯</h2><p><strong>答案</strong></p>\n<ul>\n<li>使用<code>postMessage</code>通讯</li>\n<li>注意跨域的限制和判断</li>\n</ul>\n<h2 id=\"41-H5-页面如何进行首屏优化\"><a href=\"#41-H5-页面如何进行首屏优化\" class=\"headerlink\" title=\"41. H5 页面如何进行首屏优化\"></a>41. H5 页面如何进行首屏优化</h2><p><strong>答案</strong></p>\n<ul>\n<li>路由懒加载</li>\n<li>服务端渲染 SSR</li>\n<li>App 预取</li>\n<li>分页</li>\n<li>图片懒加载</li>\n<li>Hybrid</li>\n</ul>\n<p><strong>重点</strong></p>\n<ul>\n<li>服务端 SSR 是 H5 的终极优化方案(但成本也高)</li>\n<li>移动端 H5 要结合 App 能力去优化</li>\n<li>严格来说 hybrid 不是 H5，但这里回答出来没有问题</li>\n<li>性能优化要配合分析、统计、评分等，做了事情要有结果</li>\n<li>性能优化也要配合体验，如骨架屏，loading 动画等</li>\n<li>不同的形式，有不同的优化方式，要积极和面试官沟通</li>\n</ul>\n<p><strong>路由懒加载</strong></p>\n<ul>\n<li>适用于 SPA(不适用 MPA)</li>\n<li>路由拆分，优先保证首页加载</li>\n</ul>\n<p><strong>服务端渲染 SSR</strong></p>\n<ul>\n<li>传统的前后端分离(SPA)渲染页面的过程复杂</li>\n<li>SSR 渲染页面过程简单，所以性能好</li>\n<li>如果是纯 H5 页面，SSR 是性能优化的终极方案</li>\n</ul>\n<p><strong>App 预取</strong></p>\n<ul>\n<li>如果 H5 在 App WebVIew 中展示，可使用 App 预取</li>\n<li>用户访问列表页时，App 预加载文章首屏内容</li>\n<li>用户进入 H5 页，直接从 App 中获取内容，瞬间展示首屏</li>\n</ul>\n<p><strong>分页</strong></p>\n<ul>\n<li>针对列表页</li>\n<li>默认只展示第一页内容</li>\n<li>上滑加载更多</li>\n</ul>\n<p><strong>图片懒加载 lazyload</strong></p>\n<ul>\n<li>针对详情页</li>\n<li>默认只展示文本内容，然后触发图片懒加载</li>\n<li>注意：提前设置图片尺寸，尽量只重绘不重排</li>\n</ul>\n<p><strong>Hybrid</strong></p>\n<ul>\n<li>提前将 HTML JS CSS 下载到 App 内部</li>\n<li>在 App webview 中使用 file://协议加载页面卡片</li>\n<li>再用 Ajax 获取内容并展示(也可结合 App 获取)</li>\n</ul>\n<h2 id=\"42-后端一次性返回-10W-条数据，你该如何渲染\"><a href=\"#42-后端一次性返回-10W-条数据，你该如何渲染\" class=\"headerlink\" title=\"42. 后端一次性返回 10W 条数据，你该如何渲染\"></a>42. 后端一次性返回 10W 条数据，你该如何渲染</h2><p><strong>设计不合理</strong></p>\n<ul>\n<li>后端返回 10w 条数据，本身技术方案设计就不合理</li>\n<li>主动和面试官沟通此事(这也许是面试官所期待的)</li>\n<li>如果面试官非要这么做，那再继续寻找解决方案</li>\n</ul>\n<p><strong>浏览器能否处理 10w 条数据</strong></p>\n<ul>\n<li>JS 没问题</li>\n<li>渲染到 DOM 会非常卡顿</li>\n</ul>\n<p><strong>自定义中间层</strong></p>\n<ul>\n<li>自定义 nodejs 中间层，获取并拆分这 10w 条数据</li>\n<li>前端对接 nodejs 中间层，而不是服务端</li>\n<li>成本比较高</li>\n</ul>\n<p><strong>虚拟列表</strong></p>\n<ul>\n<li>只渲染可视区域 DOM</li>\n<li>其他隐藏区域不显示，只用&lt;div&gt;撑起高度</li>\n<li>随着浏览器滚动，创建和销毁 DOM</li>\n<li><strong>借用第三方 lib</strong> <code>Vue-virtual-scroll-list</code> <code>React-virtualized</code></li>\n</ul>\n<h2 id=\"43-文本超出省略，用哪个-CSS-样式\"><a href=\"#43-文本超出省略，用哪个-CSS-样式\" class=\"headerlink\" title=\"43. 文本超出省略，用哪个 CSS 样式\"></a>43. 文本超出省略，用哪个 CSS 样式</h2><ul>\n<li>单行文本</li>\n</ul>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\"><span class=\"token selector\">#box</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> 1px solid #ccc<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> 100px<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">white-space</span><span class=\"token punctuation\">:</span> nowrap<span class=\"token punctuation\">;</span> // 不换行\n  <span class=\"token property\">overflow</span><span class=\"token punctuation\">:</span> hidden<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">text-overflow</span><span class=\"token punctuation\">:</span> ellipsis<span class=\"token punctuation\">;</span> // 超出省略\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>多行文本</li>\n</ul>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\"><span class=\"token selector\">#box</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> 1px solid #ccc<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> 100px<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">overflow</span><span class=\"token punctuation\">:</span> hidden<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> -webkit-box<span class=\"token punctuation\">;</span> //将对象作为弹性伸缩盒子模型显示\n  <span class=\"token property\">-webkit-box-orient</span><span class=\"token punctuation\">:</span> vertical<span class=\"token punctuation\">;</span> // 设置子元素排列方式\n  <span class=\"token property\">-webkit-line-clamp</span><span class=\"token punctuation\">:</span> 3<span class=\"token punctuation\">;</span> //显示几行，超出的省略\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"44-前端常用的设计模式和使用场景\"><a href=\"#44-前端常用的设计模式和使用场景\" class=\"headerlink\" title=\"44. 前端常用的设计模式和使用场景\"></a>44. 前端常用的设计模式和使用场景</h2><p><strong>题目</strong></p>\n<ul>\n<li>工厂模式</li>\n<li>单例模式</li>\n<li>代理模式</li>\n<li>观察者模式</li>\n<li>发布订阅模式</li>\n<li>装饰器模式</li>\n</ul>\n<p><strong>设计原则</strong></p>\n<ul>\n<li>最重要的思想：开放封闭原则</li>\n<li>对扩展开放</li>\n<li>对修改封闭</li>\n</ul>\n<p><strong>工厂模式</strong></p>\n<ul>\n<li>用一个工厂函数，来创建实例，隐藏 new</li>\n<li>如 jQuery $函数</li>\n<li>如 React createElement 函数</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647568226606-a1c4975b-957c-460c-af51-178faf06c213.png\" alt=\"img\"></p>\n<p><strong>单例模式</strong></p>\n<ul>\n<li>全局唯一的实例(无法生成第二个)</li>\n<li>如 Vuex Redux 和 store</li>\n<li>如全局唯一的 dialog modal</li>\n<li><strong>注意</strong>：JS 是单线程的，创建单例很简单，Java 是支持多线程的，创建单例要考虑锁死线程，否则多个线程同时创建，单例就重复了(多线程共享进程内容)</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569555578-69f648cc-fa91-4d97-a9e2-0d670bc286d0.png\" alt=\"img\"></p>\n<p><strong>代理模式</strong></p>\n<ul>\n<li>使用者不能直接访问对象，而是访问一个代理层</li>\n<li>在代理层可以监听 get set 做很多事情</li>\n<li>如 ES6 Proxy 实现 vue3 响应式</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569164500-e735f65a-b0a5-4766-bd6b-b8ab36c5c16a.png\" alt=\"img\"></p>\n<p><strong>观察者模式</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569198351-56e5028d-932b-4a88-b5e0-6ac64f3b0cfd.png\" alt=\"img\"></p>\n<p><strong>发布订阅</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569218415-755ed174-0a81-48ac-87c2-fb83817131de.png\" alt=\"img\"></p>\n<p><strong>装饰着模式</strong></p>\n<ul>\n<li>原功能不变，增加一些新功能(AOP 面向切面编程)</li>\n<li>ES 和 Typescript 的 Decorator 语法</li>\n<li>类装饰器，方法装饰器</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569390424-14473530-ecba-40c4-8a43-2531f1451a77.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569415335-f53f2659-34e4-4e94-a06a-7b88c6111b53.png\" alt=\"img\"></p>\n<h2 id=\"45-观察者模式和发布订阅模式的区别\"><a href=\"#45-观察者模式和发布订阅模式的区别\" class=\"headerlink\" title=\"45. 观察者模式和发布订阅模式的区别\"></a>45. 观察者模式和发布订阅模式的区别</h2><p><strong>观察者模式</strong></p>\n<ul>\n<li>Subject 和 Observer 直接绑定，没有中间媒介</li>\n<li>如 addEventListener 绑定事件</li>\n</ul>\n<p><strong>发布订阅</strong></p>\n<ul>\n<li>Publisher 和 Observer 互不相识，需要中间媒介 Event channel</li>\n<li>如 EventBus 自定义事件</li>\n</ul>\n<h2 id=\"46-你在实际工作中做过哪些-Vue-优化\"><a href=\"#46-你在实际工作中做过哪些-Vue-优化\" class=\"headerlink\" title=\"46. 你在实际工作中做过哪些 Vue 优化\"></a>46. 你在实际工作中做过哪些 Vue 优化</h2><p><strong>答案</strong></p>\n<ul>\n<li>v-if 和 v-show</li>\n<li>v-for 使用 key</li>\n<li>computed 缓存数据</li>\n<li>keep-alive 缓存组件</li>\n<li>异步组件 路由懒加载</li>\n<li>SSR</li>\n</ul>\n<p><strong>v-if 和 v-show</strong></p>\n<ul>\n<li>v-if 彻底销毁组件</li>\n<li>v-show 使用 css 隐藏组件</li>\n<li>大部分情况下使用 v-if 更好，不要过渡优化</li>\n</ul>\n<p><strong>v-for 使用 key</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569937881-efaa5003-a78b-4e25-b39d-5048b0fc1863.png\" alt=\"img\"></p>\n<p><strong>使用 computed 缓存</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647569968220-21945ce8-3d9c-4205-b10e-2e2b3be347b3.png\" alt=\"img\"></p>\n<p><strong>keep-alive 缓存组件</strong></p>\n<ul>\n<li>频繁切换的组件，如 tabs</li>\n<li>不要乱用，缓存太多会占用内存，且不好 debug</li>\n</ul>\n<p><strong>异步组件</strong></p>\n<ul>\n<li>针对体积较大的组件，如编辑器、复杂表格、复杂表单等</li>\n<li>拆包，需要时异步加载，不需要时不加载</li>\n<li>减少主包的体积，首页会加载更快</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647570150427-fbd947cf-d45f-4e31-b261-5d1bb90db6d6.png\" alt=\"img\"></p>\n<p><strong>路由懒加载</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647570217627-6e999273-b12f-4e39-a28b-540cc6342683.png\" alt=\"img\"></p>\n<p><strong>服务端渲染 SSR</strong></p>\n<ul>\n<li>可使用 Nuxt.js</li>\n<li>按需优化，使用 SSR 的成本比较高</li>\n</ul>\n<h2 id=\"47-你使用-Vue-遇到过哪些坑\"><a href=\"#47-你使用-Vue-遇到过哪些坑\" class=\"headerlink\" title=\"47. 你使用 Vue 遇到过哪些坑\"></a>47. 你使用 Vue 遇到过哪些坑</h2><p><strong>内存泄漏</strong></p>\n<ul>\n<li>由于全局变量、全局事件、全局定时器绑定之后没有销毁造成内容泄漏</li>\n<li>自定义事件未销毁</li>\n</ul>\n<p><strong>Vue2 响应式的缺陷（Vue3 不再有）</strong></p>\n<ul>\n<li>data 新增属性用 Vue.set</li>\n<li>data 删除属性用 Vue.delete</li>\n<li>无法直接修改数据 arr[index]=value</li>\n</ul>\n<p><strong>路由切换时 scroll 到顶部</strong></p>\n<ul>\n<li>SPA 的通病，不仅是 Vue</li>\n<li>如，列表页，滚动到第二屏，点击进入详情页</li>\n<li>再返回到列表页(此时组件重新渲染)就 scroll 到顶部</li>\n<li><strong>解决方案</strong><ul>\n<li>在列表页缓存数据和 scrollTop 值</li>\n<li>当再次返回列表时，渲染组件，执行 scrollTo(xxx)</li>\n<li>终极方案：MPA + APP WebView</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"48-实际工作中，做过哪些-React-优化\"><a href=\"#48-实际工作中，做过哪些-React-优化\" class=\"headerlink\" title=\"48. 实际工作中，做过哪些 React 优化\"></a>48. 实际工作中，做过哪些 React 优化</h2><p><strong>答案</strong></p>\n<ul>\n<li>模拟 v-show</li>\n<li>循环使用 key</li>\n<li>Fragment 减少层级</li>\n<li>JSX 不要定义函数</li>\n<li>构造函数 bind this</li>\n<li>shouldComponentUpdate</li>\n<li>useMemo</li>\n<li>异步组件</li>\n<li>路由懒加载</li>\n<li>SSR</li>\n</ul>\n<p><strong>修改 CSS 模拟 v-show</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571029995-c875e5cf-4479-4395-81a5-56f768688c39.png\" alt=\"img\"></p>\n<p><strong>循环使用 key</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571056055-25844a08-1ff5-40bc-8499-493ffd829362.png\" alt=\"img\"></p>\n<p><strong>使用 Fragment 减少层级</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571072248-f6f406af-35b0-4716-8d96-999e573eef2b.png\" alt=\"img\"></p>\n<p><strong>JSX 中不要定义函数</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571094019-b2b0ec48-0e1c-4c36-aa8d-2c37ec99d154.png\" alt=\"img\"></p>\n<p><strong>要在构造函数中 bind this</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647571143063-17591928-c721-4c44-8a20-195c9d2b35ca.png\" alt=\"img\"></p>\n<p><strong>使用 shouldComponentUpdate</strong></p>\n<ul>\n<li>使用<code>shouldComponentUpdate</code> 判断组件是否要更新</li>\n<li>或者使用<code>React.PureComponent</code></li>\n<li>函数组件使用<code>React.memo</code></li>\n</ul>\n<p><strong>Hooks 缓存数据</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579459564-42b2cd64-6201-49fb-bf7f-d5a7e568e437.png\" alt=\"img\"></p>\n<p><strong>其他</strong></p>\n<ul>\n<li>异步组件</li>\n<li>路由懒加载</li>\n<li>SSR-Next.js</li>\n</ul>\n<h2 id=\"49-你使用-React-时遇到哪些坑\"><a href=\"#49-你使用-React-时遇到哪些坑\" class=\"headerlink\" title=\"49. 你使用 React 时遇到哪些坑\"></a>49. 你使用 React 时遇到哪些坑</h2><p><strong>自定义组件的名称首字母要大写</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579721226-1a356f0d-4e21-4191-b69b-9925d0c4032f.png\" alt=\"img\"></p>\n<p><strong>JS 关键字的冲突</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579783625-e88ed79b-b7fb-4a6e-b411-d84a4617c7e9.png\" alt=\"img\"></p>\n<p><strong>JSX 数据类型</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579799446-6ce34219-5917-456c-9a21-b67012262d8f.png\" alt=\"img\"></p>\n<p><strong>setState 是异步更新的</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647579840808-3b68aef5-e693-471b-ad0d-20dffc0cc07d.png\" alt=\"img\"></p>\n<h2 id=\"50-如何统一监听-Vue-组件报错\"><a href=\"#50-如何统一监听-Vue-组件报错\" class=\"headerlink\" title=\"50. 如何统一监听 Vue 组件报错\"></a>50. 如何统一监听 Vue 组件报错</h2><p><strong>答案</strong></p>\n<ul>\n<li><code>errorCaptured</code> 监听下级组件错误，返回 false 阻止向上传播</li>\n<li><code>errorHandler</code>监听全局 Vue 组件的错误</li>\n<li><code>window.onerror</code> 监听其他 JS 错误，如异步</li>\n</ul>\n<p><strong>window.onerror</strong></p>\n<ul>\n<li>全局监听所有 JS 错误</li>\n<li>但它是 JS 级别的，识别不了 Vue 组件信息</li>\n<li>捕捉一些 Vue 监听不到的错误</li>\n</ul>\n<h2 id=\"51-如何统一监听-React-组件的报错\"><a href=\"#51-如何统一监听-React-组件的报错\" class=\"headerlink\" title=\"51. 如何统一监听 React 组件的报错\"></a>51. 如何统一监听 React 组件的报错</h2><p><strong>答案</strong></p>\n<ul>\n<li>ErrorBoundary 监听组件渲染报错</li>\n<li>事件报错使用 try-catch 或 window.onerror</li>\n<li>异步报错使用 window.onerror</li>\n</ul>\n<p><strong>ErrorBoundary 组件</strong></p>\n<ul>\n<li>监听所有下级组件报错，可降级展示 UI</li>\n<li>只监听组件渲染时报错，不监听 DOM 事件、异步错误</li>\n<li><code>production</code> 环境生效，<code>dev</code>会直接抛出错误</li>\n</ul>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ErrorBoundary</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React</span><span class=\"token punctuation\">.</span>Component <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n      error<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 存储当前的报错信息</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 更新 state 使下一次渲染能够显示降级后的 UI</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"getDerivedStateFromError...\"</span><span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">&#123;</span> error <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token function\">componentDidCatch</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">,</span> errorInfo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 统计上报错误信息</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"componentDidCatch...\"</span><span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">,</span> errorInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">// 提示错误</span>\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>报错了<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">// 没有错误，就渲染子组件</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> ErrorBoundary<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"52-如果一个-H5-很慢，你该如何排查性能问题\"><a href=\"#52-如果一个-H5-很慢，你该如何排查性能问题\" class=\"headerlink\" title=\"52. 如果一个 H5 很慢，你该如何排查性能问题\"></a>52. 如果一个 H5 很慢，你该如何排查性能问题</h2><p><strong>答案</strong></p>\n<ul>\n<li>分析性能指标，找到慢的原因</li>\n<li>对症下药，解决问题</li>\n<li>持续跟进，持续优化</li>\n</ul>\n<p><strong>前端性能指标</strong></p>\n<ul>\n<li>First Paint(FP) 第一次无内容的渲染</li>\n<li>First Contentful Paint(FCP) 第一次有内容的渲染</li>\n<li>DomContentLoaded(DCL) DOM 内容加载完成</li>\n<li>Largest Contentfull Paint(LCP) 最大的一种渲染</li>\n<li>Load(L)</li>\n</ul>\n<p><strong>工具</strong></p>\n<ul>\n<li>Chrome devTools</li>\n<li>light house</li>\n</ul>\n<p><strong>如果是网页加载慢</strong></p>\n<ul>\n<li>优化服务器硬件配置，使用 CDN</li>\n<li>路由懒加载，大组件异步加载 - 减少主包的体积</li>\n<li>优化 HTTP 缓存策略</li>\n</ul>\n<p><strong>如果是网页喧染满</strong></p>\n<ul>\n<li>优化服务端接口(如 Ajax 获取数据慢)</li>\n<li>继续分析，优化前端组件内部的逻辑(参考 Vue React 优化)</li>\n<li>服务端渲染 SSR</li>\n</ul>\n<p><strong>持续跟进</strong></p>\n<ul>\n<li>性能优化是一个循序渐进的过程，不像 bug 一次性解决</li>\n<li>持续跟进统计结果，再逐步分析性能瓶颈，持续优化</li>\n<li>可使用第三方统计服务，如阿里云 ARMS，百度统计</li>\n</ul>\n<h2 id=\"53-令人失眠的-promise-then-执行顺序问题\"><a href=\"#53-令人失眠的-promise-then-执行顺序问题\" class=\"headerlink\" title=\"53. 令人失眠的 promise-then 执行顺序问题\"></a>53. 令人失眠的 promise-then 执行顺序问题</h2><p><strong>then 交替执行</strong></p>\n<ul>\n<li>如果有多个<code>fulfilled promise</code>实例，同时执行 then 链式调用</li>\n<li>then 会交替执行</li>\n<li>这是编译器的优化，防止一个<code>promise</code>占据太久时间</li>\n</ul>\n<p><strong>then 中返回 promise 实例</strong></p>\n<ul>\n<li>相当于多出一个 promise 实例</li>\n<li>也会遵守“交替执行”</li>\n<li>(但会直接声明一个 promise 实例，结果有些差异)</li>\n</ul>\n<p><strong>慢半拍</strong></p>\n<ul>\n<li>then 中返回 promise 实例，会出现<code>慢半拍</code> 的效果</li>\n<li>第一拍，promise 需要由 pending 变为 fulfilled</li>\n<li>第二拍，then 函数挂载到 MicroTaskQueue(参考 Event Loop)</li>\n</ul>\n<h2 id=\"54-setState-是微任务还是宏任务\"><a href=\"#54-setState-是微任务还是宏任务\" class=\"headerlink\" title=\"54. setState 是微任务还是宏任务\"></a>54. setState 是微任务还是宏任务</h2><p><strong>答案</strong></p>\n<ul>\n<li>setState 是同步执行，state 是同步更新</li>\n<li>即，在微任务 Promise.then 开始之前，state 已经计算完了</li>\n<li>同步，不是微任务或宏任务</li>\n</ul>\n<p><strong>setState 本质是同步</strong></p>\n<ul>\n<li>setState 是同步，只不过让 React 做成了异步的样子</li>\n<li>因为要考虑性能，多次 state 修改，只进行一次 DOM 渲染</li>\n<li>日常说的<code>异步</code>是不严谨的，但沟通成本低</li>\n</ul>\n<h2 id=\"55-对象属性类型的问题\"><a href=\"#55-对象属性类型的问题\" class=\"headerlink\" title=\"55. 对象属性类型的问题\"></a>55. 对象属性类型的问题</h2><p><strong>JS 对象 key 的数据类型</strong></p>\n<ul>\n<li>只能是<code>字符串</code>和<code>Symbol</code> 类型</li>\n<li>其他类型会被转换为字符串</li>\n<li>就是将类型<code>toString()</code>之后作为 key</li>\n</ul>\n<p><strong>Symbol 无论内部一样，外面都是不一样的</strong></p>\n<ul>\n<li>所以一样的字符串 Symbol 都是不一样的不回覆盖</li>\n</ul>\n<p><strong>Map 和 WeakMap 的 key 就不会出现这种情况</strong></p>\n<ul>\n<li>Map 的 key 可以是各种类型</li>\n<li>WeakMap 的 key 只能是引用类型，不能是值类型</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/1647654516971-f88b4de3-14a4-4d73-a2f4-c59d13964865.png\" alt=\"img\"></p>\n<ul>\n<li>第一个由于 类型转换为<code>123</code> 则覆盖前面，结果<code>c</code></li>\n<li>第二个，Symbol 定义的总是不一样，所以不覆盖，结果<code>b</code></li>\n<li>第三个，对象 toString 之后都是<code>[object Object]</code> 字符串，覆盖，结果<code>c</code></li>\n</ul>\n<h2 id=\"56-何时使用-SSR，何时不用\"><a href=\"#56-何时使用-SSR，何时不用\" class=\"headerlink\" title=\"56. 何时使用 SSR，何时不用\"></a>56. 何时使用 SSR，何时不用</h2><p><strong>SSR 的优势</strong></p>\n<p>服务端直出 html</p>\n<ul>\n<li>性能好</li>\n<li>对 SEO 优化</li>\n</ul>\n<p><strong>SSR 的劣势</strong></p>\n<p>前后端同构，开发成本高(学习、测试、运维等)</p>\n<p><strong>是否需要 SSR</strong></p>\n<ul>\n<li>你的项目是否需要 SSR ——管理后台就不需要</li>\n<li>你的项目是否在一极致的性能优化，或者是否有可能处于弱网环境 ——管理后台不需要</li>\n</ul>\n<p>如果急需要 SSR 的优势和价值，那就去承担 SSR 的成本，如果不需要这些优势，那 SSR 就成了一个累赘</p>\n<p><strong>SSR 的应用场景</strong></p>\n<p>C 端，以阅读为主的单页面，如新闻页，运营宣传广告页面，官网等，1.需要快 2. 需要 SEO</p>\n<h2 id=\"57-如何做-Code-Review\"><a href=\"#57-如何做-Code-Review\" class=\"headerlink\" title=\"57. 如何做 Code-Review\"></a>57. 如何做 Code-Review</h2><p><strong>如何做 Code-Review</strong></p>\n<ul>\n<li>代码规范(eslint 不能全面检查，如变量命名，代码语义)</li>\n<li>重复的代码要抽离，复用</li>\n<li>单个函数内容过长，需要拆分</li>\n<li>算法复杂度是否可用，是否可继续优化</li>\n<li>是否有安全漏洞</li>\n<li>扩展性如何(不用为了扩展而扩展，不封闭即可)</li>\n<li>是否有现有的功能重复了</li>\n<li>是否有完整的单元测试</li>\n<li>组件设计是否合理</li>\n</ul>\n<p><strong>Code review 的时机</strong></p>\n<ul>\n<li>提交 PR 时，通过代码 diff 进行 Code review</li>\n<li>每周例行一次集体 Code review</li>\n</ul>\n<p><strong>持续优化</strong></p>\n<ul>\n<li>每次 Code review 的问题要记录下</li>\n<li>归纳整理，形成自己的 diamagnetic 规范体系</li>\n<li>新加入的成员要提前学习，提高规避</li>\n</ul>\n<p><strong>之前没有做过 Code review 怎么办</strong></p>\n<ul>\n<li>作为一个跳槽的理由(要求进步，想去流程规范的团队)</li>\n</ul>\n<h2 id=\"58-如何学习一门新语言，要考虑哪些方面\"><a href=\"#58-如何学习一门新语言，要考虑哪些方面\" class=\"headerlink\" title=\"58. 如何学习一门新语言，要考虑哪些方面\"></a>58. 如何学习一门新语言，要考虑哪些方面</h2><p><strong>考虑内容</strong></p>\n<ul>\n<li>它的优势和应用场景</li>\n<li>语法(常量、变量、数据类型，运算符，函数等)</li>\n<li>内置模块和 API</li>\n<li>常用的第三方框架和库</li>\n<li>开发环境和调试工具</li>\n<li>线上环境和发布过程</li>\n</ul>\n<h2 id=\"59-你认为自己还有什么不足之处\"><a href=\"#59-你认为自己还有什么不足之处\" class=\"headerlink\" title=\"59. 你认为自己还有什么不足之处\"></a>59. 你认为自己还有什么不足之处</h2><p><strong>答案模板</strong></p>\n<ul>\n<li>我觉得自己在 xxx 方面存在不足</li>\n<li>但我已经意识到，并开始学习 xxx</li>\n<li>我估计会在 xxx 时间把这块补齐</li>\n</ul>\n<p><strong>不足不要乱说</strong></p>\n<ul>\n<li>范围限定在技术方面</li>\n<li>非核心技术栈</li>\n<li>容易弥补的，后面容易翻身</li>\n</ul>\n<p><strong>反转话题</strong></p>\n","text":"1. 为什么 0.1+0.2!==0.3计算机使用二进制存储数据 整数转换二进制没有误差，如 9 转换为二进制是 1001 而小数可能无法用二进制准确表达，如 0.2 转换为 0.20000001 可以用math.js 库解决 2. Ajax-Fetch-Axios 三者有什么区...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"知识点","slug":"知识点","count":18,"path":"api/categories/知识点.json"}],"tags":[{"name":"面试","slug":"面试","count":13,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3\"><span class=\"toc-text\">1. 为什么 0.1+0.2!&#x3D;&#x3D;0.3</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Ajax-Fetch-Axios-%E4%B8%89%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2. Ajax-Fetch-Axios 三者有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96\"><span class=\"toc-text\">3. 节流和防抖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-px-em-rem-vw-vh-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4. px % em rem vw vh 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5. 箭头函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E8%AF%B7%E6%8F%8F%E8%BF%B0-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">6. 请描述 TCP 三次握手和四次挥手</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">7. for…in 和 for…of 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-for-await-%E2%80%A6of-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">8. for await …of 有什么用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-offsetHeight-scrollHeight-clientHeight-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">9. offsetHeight scrollHeight clientHeight 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-HTMLCollection-%E5%92%8C-NodeList-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">10. HTMLCollection 和 NodeList 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-JS-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">11. JS 严格模式有什么特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-HTTP-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%97%B6%E4%B8%BA%E4%BD%95%E5%8F%91%E9%80%81-options-%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">12. HTTP 跨域请求时为何发送 options 请求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-JS-%E5%86%85%E5%AD%98%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%94%A8%E4%BB%80%E4%B9%88%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">13. JS 内存垃圾回收用什么算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E9%97%AD%E5%8C%85%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97\"><span class=\"toc-text\">14. 闭包是内存泄漏吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-JS-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%EF%BC%8C%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">15. JS 内存泄漏如何检测，场景有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C-nodejs-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">16. 浏览器和 nodejs 的事件循环有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-VDOM-%E7%9C%9F%E7%9A%84%E5%BE%88%E5%BF%AB%E5%90%97\"><span class=\"toc-text\">17. VDOM 真的很快吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%94%A8-for-%E5%92%8C-forEach-%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%BF%AB\"><span class=\"toc-text\">18. 遍历一个数组用 for 和 forEach 哪个更快</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-nodejs-%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%9A%E8%AE%AF\"><span class=\"toc-text\">19. nodejs 如何开启线程，进程如何通讯</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-%E8%AF%B7%E6%8F%8F%E8%BF%B0-JS-Bridge-%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">20. 请描述 JS Bridge 原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-requestIdleCallback-%E5%92%8C-requestAnimationFrame-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">21. requestIdleCallback 和 requestAnimationFrame 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-Vue-%E6%AF%8F%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">22. Vue 每个生命周期都做了什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%8E%AF%E9%97%AE-vue-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%93%8D%E4%BD%9C-DOM-%E6%AF%94%E8%BE%83%E5%90%88%E9%80%82\"><span class=\"toc-text\">连环问 vue 什么时候操作 DOM 比较合适</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%8E%AF%E9%97%AE-Ajax-%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">连环问 Ajax 应该在哪个生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%8E%AF%E9%97%AE-Vue3-Composition-API-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">连环问 Vue3 Composition API 生命周期有何区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23-Vue2-Vue3-React-%E4%B8%89%E8%80%85-diff-%E7%AE%97%E6%B3%95%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">23. Vue2 Vue3 React 三者 diff 算法有何区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%8E%AF%E9%97%AE-Vue-React-%E4%B8%BA%E4%BD%95%E5%BE%AA%E7%8E%AF%E6%97%B6%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-key\"><span class=\"toc-text\">连环问 Vue React 为何循环时必须使用 key</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-Vue-router-%E5%92%8C-MemoryHistory-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">24. Vue-router 和 MemoryHistory 是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-%E7%A7%BB%E5%8A%A8%E7%AB%AF-H5-click-%E6%9C%89-300ms-%E5%BB%B6%E8%BF%9F%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">25. 移动端 H5 click 有 300ms 延迟，该如何解决</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%AD%EF%BC%8Ctoken-%E5%92%8C-cookie-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">26. 网络请求中，token 和 cookie 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27-session-%E5%92%8C-JWT-%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%A5%BD\"><span class=\"toc-text\">27. session 和 JWT 哪个更好</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-SSO-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95\"><span class=\"toc-text\">28. 如何实现 SSO 单点登录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#29-HTTP-%E5%8D%8F%E8%AE%AE%E5%92%8C-UDP-%E5%8D%8F%E8%AE%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">29. HTTP 协议和 UDP 协议有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#30-HTTP-%E5%8D%8F%E8%AE%AE-1-0-1-1-2-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">30. HTTP 协议 1.0 1.1 2.0 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#31-%E4%BB%80%E4%B9%88%E6%98%AF-HTTPS-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2\"><span class=\"toc-text\">31. 什么是 HTTPS 中间人攻击，如何预防</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32-script-%E6%A0%87%E7%AD%BE%E7%9A%84-defer-%E5%92%8C-async-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">32. script 标签的 defer 和 async 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#33-prefetch-%E5%92%8C-dns-prefetch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">33. prefetch 和 dns-prefetch 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#34-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2\"><span class=\"toc-text\">34. 你知道哪些前端攻击，该如何预防</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#35-WebSocket-%E5%92%8C-HTTP-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">35. WebSocket 和 HTTP 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#36-WebSocket-%E5%92%8C-HTTP-%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">36. WebSocket 和 HTTP 长轮询的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#37-%E6%8F%8F%E8%BF%B0%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">37. 描述从输入 url 到页面展示的完整过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#38-%E7%BD%91%E9%A1%B5%E9%87%8D%E7%BB%98-repain-%E5%92%8C%E9%87%8D%E6%8E%92-reflow-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">38. 网页重绘 repain 和重排 reflow 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#39-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%A4%9A%E6%A0%87%E7%AD%BE-tab-%E9%80%9A%E8%AE%AF\"><span class=\"toc-text\">39. 如何实现网页多标签 tab 通讯</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#40-%E7%BD%91%E9%A1%B5%E5%92%8C-iframe-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF\"><span class=\"toc-text\">40. 网页和 iframe 之间的通讯</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-H5-%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">41. H5 页面如何进行首屏优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#42-%E5%90%8E%E7%AB%AF%E4%B8%80%E6%AC%A1%E6%80%A7%E8%BF%94%E5%9B%9E-10W-%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%A0%E8%AF%A5%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">42. 后端一次性返回 10W 条数据，你该如何渲染</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#43-%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E7%9C%81%E7%95%A5%EF%BC%8C%E7%94%A8%E5%93%AA%E4%B8%AA-CSS-%E6%A0%B7%E5%BC%8F\"><span class=\"toc-text\">43. 文本超出省略，用哪个 CSS 样式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#44-%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">44. 前端常用的设计模式和使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">45. 观察者模式和发布订阅模式的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#46-%E4%BD%A0%E5%9C%A8%E5%AE%9E%E9%99%85%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-Vue-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">46. 你在实际工作中做过哪些 Vue 优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#47-%E4%BD%A0%E4%BD%BF%E7%94%A8-Vue-%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E5%9D%91\"><span class=\"toc-text\">47. 你使用 Vue 遇到过哪些坑</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-%E5%AE%9E%E9%99%85%E5%B7%A5%E4%BD%9C%E4%B8%AD%EF%BC%8C%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-React-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">48. 实际工作中，做过哪些 React 优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-%E4%BD%A0%E4%BD%BF%E7%94%A8-React-%E6%97%B6%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E5%9D%91\"><span class=\"toc-text\">49. 你使用 React 时遇到哪些坑</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#50-%E5%A6%82%E4%BD%95%E7%BB%9F%E4%B8%80%E7%9B%91%E5%90%AC-Vue-%E7%BB%84%E4%BB%B6%E6%8A%A5%E9%94%99\"><span class=\"toc-text\">50. 如何统一监听 Vue 组件报错</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-%E5%A6%82%E4%BD%95%E7%BB%9F%E4%B8%80%E7%9B%91%E5%90%AC-React-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8A%A5%E9%94%99\"><span class=\"toc-text\">51. 如何统一监听 React 组件的报错</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#52-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA-H5-%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">52. 如果一个 H5 很慢，你该如何排查性能问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#53-%E4%BB%A4%E4%BA%BA%E5%A4%B1%E7%9C%A0%E7%9A%84-promise-then-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">53. 令人失眠的 promise-then 执行顺序问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#54-setState-%E6%98%AF%E5%BE%AE%E4%BB%BB%E5%8A%A1%E8%BF%98%E6%98%AF%E5%AE%8F%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">54. setState 是微任务还是宏任务</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#55-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">55. 对象属性类型的问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#56-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-SSR%EF%BC%8C%E4%BD%95%E6%97%B6%E4%B8%8D%E7%94%A8\"><span class=\"toc-text\">56. 何时使用 SSR，何时不用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#57-%E5%A6%82%E4%BD%95%E5%81%9A-Code-Review\"><span class=\"toc-text\">57. 如何做 Code-Review</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#58-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E8%AF%AD%E8%A8%80%EF%BC%8C%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2\"><span class=\"toc-text\">58. 如何学习一门新语言，要考虑哪些方面</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#59-%E4%BD%A0%E8%AE%A4%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84\"><span class=\"toc-text\">59. 你认为自己还有什么不足之处</span></a></li></ol>","author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}},"mapped":true,"prev_post":{"title":"TS面试题","uid":"2e2a8a1eab8c08452e6963881a3d432f","slug":"TS面试题","date":"2022-04-10T12:15:36.000Z","updated":"2022-04-10T12:16:07.874Z","comments":true,"path":"api/articles/TS面试题.json","keywords":null,"cover":null,"text":"第一题type User = &#123; id: number; kind: string; &#125;; function makeCustomer&lt;T extends User>(u: T): T &#123; // Error（TS 编译器版本：v4.4.2） /...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[{"name":"知识点","slug":"知识点","count":18,"path":"api/categories/知识点.json"}],"tags":[{"name":"面试","slug":"面试","count":13,"path":"api/tags/面试.json"}],"author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}}},"next_post":{"title":"Webpack配置及打包vue","uid":"1cfec3e13a62702637234d5f7c53b3fc","slug":"Webpack配置及打包vue","date":"2022-04-10T12:08:54.000Z","updated":"2022-04-10T12:10:54.107Z","comments":true,"path":"api/articles/Webpack配置及打包vue.json","keywords":null,"cover":[],"text":" 安装webpack``webpack-cli npm install webpack webpack-cli -D 配置入口出口 // webpack.config.js module.exports = &#123; mode: 'development', entry: '...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"知识点","slug":"知识点","count":18,"path":"api/categories/知识点.json"}],"tags":[{"name":"工程化","slug":"工程化","count":1,"path":"api/tags/工程化.json"},{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"}],"author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}}}}