{"title":"JSX如何\"摇身一变\"成为DOM的","uid":"b9b69e275d0ea3fd4374ffde1f72e980","slug":"JSX如何变成DOM","date":"2022-02-27T09:46:50.000Z","updated":"2022-05-28T11:06:46.460Z","comments":true,"path":"api/articles/JSX如何变成DOM.json","keywords":null,"cover":[],"content":"<h2 id=\"JSX代码如何变成DOM\"><a href=\"#JSX代码如何变成DOM\" class=\"headerlink\" title=\"JSX代码如何变成DOM\"></a>JSX代码如何变成DOM</h2><h3 id=\"抛出问题\"><a href=\"#抛出问题\" class=\"headerlink\" title=\"抛出问题\"></a>抛出问题</h3><ul>\n<li><p>  JSX的本质是什么，它和JS之间到底是什么关系？</p>\n</li>\n<li><p>  为什么要用JSX？不用会有什么后果？</p>\n</li>\n<li><p>  JSX背后的功能模块是什么，这个功能模块都做了那些事</p>\n</li>\n</ul>\n<h3 id=\"尝试解答\"><a href=\"#尝试解答\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h3><ul>\n<li>  JSX的本质是JS的拓展，但是浏览器不能天然支持JSX，所以需要Babel将它编译为React.createElement()的调用，语法糖返回一个叫<code>React Element</code>的JS对象</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b3770e68e64c12abc1e7a84e0dbce7~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<ul>\n<li>  既然最后编译为React.createElement()的调用，为什么不直接使用React.createElement()呢？</li>\n<li>答：<ul>\n<li>  由于实现同样的功能的情况下，JSX代码层次分明，语言简练，而React.createElement()代码繁重</li>\n<li>  JSX语法糖允许前端开发者使用我们最为熟悉的类HTML标签语法来创建虚拟DOM，在降低学习成本的同时，也提升了研发效率和研发体验</li>\n</ul>\n</li>\n</ul>\n<p>\\</p>\n<ul>\n<li>  <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ab7dbc78f714dfaac62a91ce3a08553~tplv-k3u1fbpfcp-zoom-1.image\"></li>\n</ul>\n<p>\\</p>\n<h2 id=\"createElement解析\"><a href=\"#createElement解析\" class=\"headerlink\" title=\"createElement解析\"></a>createElement解析</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n  React的创建元素方法\n *&#x2F;\n\nfunction createElement(type, config, children) &#123;\n  &#x2F;&#x2F; propName用于储存后面需要用到的元素属性\n  var propName;\n  &#x2F;&#x2F; props用于储存元素属性的键值对集合\n  var props &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; key、ref、self、source均为React元素的属性\n  var key &#x3D; null;\n  var ref &#x3D; null;\n  var self &#x3D; null;\n  var source &#x3D; null;\n\n  &#x2F;&#x2F; config 对象中存储的是元素的属性\n  if (config !&#x3D; null) &#123;\n    &#x2F;&#x2F; 进来之后的第一件事，依次对ref、key、self和source属性赋值\n    if (hasValidRef(config)) &#123;\n      ref &#x3D; config.ref;\n\n      &#123;\n        warnIfStringRefCannotBeAutoConverted(config);\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 此处将key 值字符串化\n    if (hasValidKey(config)) &#123;\n      key &#x3D; &#39;&#39; + config.key;\n    &#125;\n\n    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;\n    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source; &#x2F;&#x2F; Remaining properties are added to a new props object\n\n    &#x2F;&#x2F; 接着就是要把config里面的属性都一个一个挪到props对象里面\n    for (propName in config) &#123;\n      if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;\n        props[propName] &#x3D; config[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; childrenLength 指的是当前元素的子元素的个数，减去的2是type和config两个参数占用的长度\n  var childrenLength &#x3D; arguments.length - 2;\n\n  &#x2F;&#x2F; 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;\n    &#x2F;&#x2F; 直接把这个值赋值给props.children\n    props.children &#x3D; children;\n  &#125; else if (childrenLength &gt; 1) &#123;\n    &#x2F;&#x2F; 处理嵌套多个子元素的情况\n    &#x2F;&#x2F; 声明一个数组，把所有剩余对象参数都遍历传入，最后把数组赋值给props.children对象\n    var childArray &#x3D; Array(childrenLength);\n\n    for (var i &#x3D; 0; i &lt; childrenLength; i++) &#123;\n      childArray[i] &#x3D; arguments[i + 2];\n    &#125;\n\n    &#123;\n      if (Object.freeze) &#123;\n        Object.freeze(childArray);\n      &#125;\n    &#125;\n\n    props.children &#x3D; childArray;\n  &#125; &#x2F;&#x2F; Resolve default props\n\n  &#x2F;&#x2F; 处理defaultProps\n  if (type &amp;&amp; type.defaultProps) &#123;\n    var defaultProps &#x3D; type.defaultProps;\n\n    for (propName in defaultProps) &#123;\n      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;\n        props[propName] &#x3D; defaultProps[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#123;\n    if (key || ref) &#123;\n      var displayName &#x3D; typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39; ? type.displayName || type.name || &#39;Unknown&#39; : type;\n\n      if (key) &#123;\n        defineKeyPropWarningGetter(props, displayName);\n      &#125;\n\n      if (ref) &#123;\n        defineRefPropWarningGetter(props, displayName);\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"参数说明：\"><a href=\"#参数说明：\" class=\"headerlink\" title=\"参数说明：\"></a>参数说明：</h3><ul>\n<li><p>  <code>type</code>:用于标识节点的类型，它可以是HTML标签字符串，也可以是React组件类型</p>\n</li>\n<li><p>  <code>config</code>: 以对象形式传入，组件所有的属性都会以键值对的形式存储在<code>config</code>对象中</p>\n</li>\n<li><p>  <code>children</code>: 以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的”子节点””子元素”</p>\n</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>DOM结构</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;ul className&#x3D;&quot;list&quot; id&#x3D;&quot;lis&quot;&gt;\n  &lt;li key&#x3D;&#123;1&#125;&gt;&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&#123;2&#125;&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>React.createElement语法糖</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">React.createElement(&quot;ul&quot;, &#123;\n  &#x2F;&#x2F; 传入属性键值对\n  className: &quot;list&quot;,\n  id: &quot;lis&quot;\n  &#x2F;&#x2F; 从第三个入参开始往后，传入的参数都是children\n&#125;, React.createElement(&quot;li&quot;, &#123;\n  key: 1\n&#125;), React, createElement(&quot;li&quot;, &#123;\n  key: 2\n&#125;))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ol>\n<li><p> 处理key、ref、self、source四个属性值</p>\n</li>\n<li><p> 遍历config，筛选出可以提进props里的属性</p>\n</li>\n<li><p> 提取子元素，推入props.children</p>\n</li>\n<li><p> 格式化defaultProps</p>\n</li>\n<li><p> 将以上数据作为入参，发起ReactElement调用</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>createElement就像是开发者和ReactElement调用之间的一个“转换器”，在开发者出接收相对简单的参数，然年后将这些参数按照ReactElement的预期做一层格式化，最终通过调用ReactElement来实现元素的创建</p>\n<h2 id=\"ReactElement解析\"><a href=\"#ReactElement解析\" class=\"headerlink\" title=\"ReactElement解析\"></a>ReactElement解析</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">var ReactElement &#x3D; function (type, key, ref, self, source, owner, props) &#123;\n  var element &#x3D; &#123;\n    &#x2F;&#x2F; 用来标识该对象是一个ReactElement\n    $$typeof: REACT_ELEMENT_TYPE,\n    &#x2F;&#x2F; 内置属性赋值\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    &#x2F;&#x2F; 记录创建该元素的组件\n    _owner: owner\n  &#125;;\n\n  return element;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>ReactElement只做了一件事情，就是组装，把传入的参数按照一定的规范，组装进element对象里，并把它返回给React.createElement，最终React.createElement又把它交回到开发者手中</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465b9816b7be49cca27a49305f04ea60~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"render初识\"><a href=\"#render初识\" class=\"headerlink\" title=\"render初识\"></a>render初识</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">function render(element, container, callback) &#123;\n  if (!isValidContainer(container)) &#123;\n    &#123;\n      throw Error( &quot;Target container is not a DOM element.&quot; );\n    &#125;\n  &#125;\n\n  &#123;\n    var isModernRoot &#x3D; isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer &#x3D;&#x3D;&#x3D; undefined;\n\n    if (isModernRoot) &#123;\n      error(&#39;You are calling ReactDOM.render() on a container that was previously &#39; + &#39;passed to ReactDOM.createRoot(). This is not supported. &#39; + &#39;Did you mean to call root.render(element)?&#39;);\n    &#125;\n  &#125;\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><ul>\n<li><p>  <code>element</code>:需要渲染的元素(ReactElement)</p>\n</li>\n<li><p>  <code>container</code>:元素挂载的目标容器(一个真实DOM)</p>\n</li>\n<li><p>  <code>callback</code>: 回调函数，可选参数，可以用来处理渲染结束后的逻辑</p>\n</li>\n</ul>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://raw.githubusercontent.com/liyunfuyyyy/img-url/master/image-20220227181403603.png\" alt=\"image-20220227181403603\"></p>\n","text":"JSX代码如何变成DOM抛出问题 JSX的本质是什么，它和JS之间到底是什么关系？ 为什么要用JSX？不用会有什么后果？ JSX背后的功能模块是什么，这个功能模块都做了那些事 尝试解答 JSX的本质是JS的拓展，但是浏览器不能天然支持JSX，所以需要Babel将它编译为React...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"React源码","slug":"React源码","count":1,"path":"api/categories/React源码.json"}],"tags":[{"name":"React","slug":"React","count":1,"path":"api/tags/React.json"},{"name":"源码","slug":"源码","count":1,"path":"api/tags/源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JSX%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90DOM\"><span class=\"toc-text\">JSX代码如何变成DOM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%9B%E5%87%BA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">抛出问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%9D%E8%AF%95%E8%A7%A3%E7%AD%94\"><span class=\"toc-text\">尝试解答</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createElement%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">createElement解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%EF%BC%9A\"><span class=\"toc-text\">参数说明：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReactElement%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">ReactElement解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#render%E5%88%9D%E8%AF%86\"><span class=\"toc-text\">render初识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">参数说明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}},"mapped":true,"prev_post":{"title":"MongoDB的CRUD","uid":"2dd921bc2e0b67b467ed4b61518bdc3d","slug":"MongoDB的CRUD","date":"2022-03-05T02:54:11.000Z","updated":"2022-05-28T11:06:46.461Z","comments":true,"path":"api/articles/MongoDB的CRUD.json","keywords":null,"cover":[],"text":"MongoDB初见 Docker中MongoDB数据的备份与恢复#备份 docker exec -it 镜像名 mongodump -h 地址 -u root -p example -o 备份到的地址 docker exec -it some-mongo mongodump -h...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"实战","slug":"实战","count":5,"path":"api/categories/实战.json"}],"tags":[{"name":"MongoDB","slug":"MongoDB","count":1,"path":"api/tags/MongoDB.json"},{"name":"数据库","slug":"数据库","count":3,"path":"api/tags/数据库.json"},{"name":"Mongoose","slug":"Mongoose","count":1,"path":"api/tags/Mongoose.json"}],"author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}}},"next_post":{"title":"flex布局","uid":"bdee22d1805781f30b666804c7635df8","slug":"flex布局","date":"2022-02-12T13:46:33.000Z","updated":"2022-05-28T11:06:46.464Z","comments":true,"path":"api/articles/flex布局.json","keywords":null,"cover":[],"text":"flex容器属性改变主轴方向flex-directionflex-direction: row默认 flex-direction: row-reverse flex-direction: column flex-direction: column-reverse 换行flex-w...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"CSS","slug":"CSS","count":1,"path":"api/tags/CSS.json"},{"name":"布局","slug":"布局","count":2,"path":"api/tags/布局.json"}],"author":{"name":"LIYUNFU","slug":"blog-author","avatar":"https://p26-passport.byteacctimg.com/img/user-avatar/c52fbf24fbba8a052c8dd93e8b978eac~300x300.image","link":"/","description":"一个正在重塑知识的切图仔 <br /> @ <b>公众号:伯nulee</b>","socials":{"github":"https://gitee.com/LUNIONT","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/2277843824292183","customs":{}}}}}