[{"id":"962830b6bd2196f70a73107af4c3efd5","title":"Flutter01环境配置","content":"安装flutterflutter3 还不支持交叉编译\n学了一段时间的flutter准备从0开始记录flutter3的学习过程\n安装SDK进入https://docs.flutter.dev/get-started/install/windows 下载压缩包，将压缩包解压到C盘根目录下，不要解压到Program files或Program Files(x86)这两个高权限目录下。\n\n配置环境变量将flutter目录下bin的地址填入环境变量path中，重启电脑或注销。\n\n查看是否配置成功命令行键入flutter查看是否配置成功\n报错\n\n使用git clone -b stable https://github.com/flutter/flutter.git重新克隆下来，将原先的删除\n安装Dart SDK键入flutter等待dart sdk下载完成\n\n\\\n安装其他键入flutter doctor查看还有以下几种没有解决的，下面我们一步一步来解决。\n\n安装chrome进入https://www.google.com/chrome/ 下载安装即可\n安装visual studio 2022进入https://visualstudio.microsoft.com/zh-hans/downloads/ 下载社区版即可，勾选使用C++的桌面开发点击安装，等待安装完成。\n\n安装Andriod Studio进入https://developer.android.com/studio 下载，勾选Andriod Virtual Device，一路默认勾选，等待安装完成，如出现红色，尝试科学上网。\n\n安装Andriod SDK选择SDK Manager，勾选Andriod SDK Command-line Tools，如果是需要的话可以将下面勾选的HAXM一起安装，\n\n\n安装安卓虚拟机选择Virtual Device Manager，选择Pixel 5，下一步，选择推荐的安卓版本R下一步 等待安装成功。\n\n\n\n查看是否配置成功运行flutter doctor\n\n其他问题解决Visual Studio报错这个错是由于2022这个版本出现的错误，可以进入https://github.com/flutter/flutter/issues/102451 查看，只有临时解决方案，根据指引下载vswhere.exe发放入指定目录下，再使用flutter doctor测试。\n\n添加flutter国内镜像源给flutter添加国内的镜像，添加到环境变量中\n\n\n\\\n解决信号灯超时时间已到(网络问题)https://stackoverflow.com/questions/71063780/how-is-http-host-availability-in-flutter-2-10 根据回答，修改maven地址。\n\n测试：非常棒，可以愉快开发了。\n\n","slug":"flutter01","date":"2022-05-28T11:49:05.000Z","categories_index":"","tags_index":"flutter,多端","author_index":"LIYUNFU"},{"id":"52748ea8c7aacb653b9bc3a082a7560f","title":"基于koa-generator搭建通用服务端","content":"安装koa-generator全局安装koa-generatornpm i koa-generator -g\n\n初始化项目koa2 goudong-server \n\n进入并安装依赖cd goudong-server \nnpm install\n\n\n\n改造项目环境\n在根目录下新建src目录\n\n将public 、routes 、views 、app.js拖入src目录\n\n修改bin/www中的var app = require(&#39;../app&#39;);为var app = require(&#39;../src/app&#39;);\n\n改造后目录\n\n```shell|- bin  |- www|-node_modules|-src  |-public  |-routes  |-views  |-app.js|-package.json\n\n- 在&#96;src&#96;目录下创建四个目录&#96;controller&#96; 、&#96;db&#96; 、&#96;middleware&#96;、&#96;models&#96;\n\n\n\n\n\n## 实现登录功能\n\n### 配置开发环境\n\n#### 安装&#96;koa-generic-session&#96;依赖\n\n&#96;&#96;&#96;shell\nni koa-generic-session \n\n使用const session = require('koa-generic-session')\n\n//session配置\napp.keys = ['liyunfuAAA'] //密钥用于加密\napp.use(session(&#123;\n  //配置cookie\n  cookie: &#123;\n    path: '/',\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000\n  &#125;\n&#125;))\n\n\n\n跨域安装koa2-cors依赖ni koa2-cors\n\n使用const cors = require('koa2-cors')\n\n//cors配置\napp.use(cors(&#123;\n  origin: 'http://localhost:8080',  //前端origin\n  credentials: true //允许跨域带cookie\n&#125;))\n\n连接数据库安装mongooseni mongoose\n\n在db目录下新建db.js/**\n * @description mongoose 连接数据库\n * @author liyunfu\n */\nconst mongoose = require('mongoose')\n\nconst DB_URL = 'mongodb://root:example@47.99.147.11.27017/jingdong?authSource=admin'\n\n// 开始连接\nmongoose.connect(DB_URL, &#123;\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n&#125;)\n\n// 连接对象\nconst db = mongoose.connection\n\ndb.on('error', err => &#123;\n  console.error('mongoose connect error', err)\n&#125;)\ndb.once('open', () => &#123;\n  console.log('mongoose 连接成功')\n&#125;)\n\nmodule.exports = mongoose\n\n\n\n设计Schema和Model\n在models目录下新建User.js\n/**\n * @description user Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true,\n    unique: true\n  &#125;,\n  password: String\n&#125;, &#123; timestamps: true &#125;)\n\nconst User = mongoose.model('user', Schema)\n\nmodule.exports = User\n在models下新建Address.js\n/**\n * @description Address Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  city: String,\n  department: String,\n  houseNumber: String,\n  name: String,\n  phone: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Address = mongoose.model('address', Schema)\n\nmodule.exports = Address\n在models下新建Shop.js\n/**\n * @description Shop Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  expressLimit: &#123;\n    type: Number,\n    default: 0\n  &#125;,\n  expressPrice: Number,\n  slogan: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Shop = mongoose.model('shop', Schema)\n\nmodule.exports = Shop\n在models下新建Product.js\n/**\n * @description Product Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  ShopId: &#123;\n    type: String,\n    require: true\n  &#125;,\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  price: Number,\n  oldPrice: Number,\n  tabs: [String]  //示例 tabs:['all','seckill']\n&#125;, &#123; timestamps: true &#125;)\n\nconst Product = mongoose.model('product', Schema)\n\nmodule.exports = Product\n在models下新建Order.js \n/**\n * @description Order Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  shopId: String,\n  shopName: String,\n\n  idCanceled: &#123;\n    type: Boolean,\n    default: false\n  &#125;,\n  address: &#123;\n    username: String,\n    city: String,\n    department: String,\n    houseNumber: String,\n    name: String,\n    phone: String\n  &#125;,\n  products: [\n    &#123;\n      product: &#123;\n        shopId: &#123;\n          type: String,\n          require: true\n        &#125;,\n        name: String,\n        imgUrl: String,\n        sales: Number,\n        price: Number,\n        oldPrice: Number,\n        tabs: [String]\n      &#125;,\n      orderSales: Number\n    &#125;\n  ]\n&#125;, &#123; timestamps: true &#125;)\n\nconst Order = mongoose.model('order', Schema)\n\nmodule.exports = Order\n在models 下新建index.js \n/**\n * @description Model 入口文件\n * @author liyunfu\n */\nconst Address = require('./Address')\nconst Order = require('./Order')\nconst Product = require('./Product')\nconst Shop = require('./Shop')\nconst User = require(\"./User\")\n\nmodule.exports = &#123;\n  Address,\n  Order,\n  Product,\n  Shop,\n  User\n&#125;\n\n标准化请求成功与失败的响应信息\n在res-model 下新建ErrorModel.js\n/**\n * @description 错误返回的数据结构\n * @author liyunfu\n */\n\nclass ErrorModel &#123;\n  constructor(errno = -1, message = 'error') &#123;\n    this.errno = errno\n    this.message = message\n  &#125;\n&#125;\n\nmodule.exports = ErrorModel\n在res-model 下新建SuccessModel.js\n/**\n * @description 成功返回的数据类型\n * @author liyunfu\n */\n\nclass SuccessModel &#123;\n  constructor(data) &#123;\n    this.errno = 0\n    if (data !== null) &#123;\n      this.data = data\n    &#125;\n  &#125;\n&#125;\n\nmodule.exports = SuccessModel\n在res-model 下新建入口文件index.js\n/**\n * @description 返回数据类型 入口文件\n * @author liyunfu\n */\nconst SuccessModel = require('./SuccessModel')\nconst ErrorModel = require('./ErrorModel')\n\nmodule.exports = &#123; SuccessModel, ErrorModel &#125;\n\n编写登录验证中间件\n在middleware 下新建loginCheck.js\n/**\n * @description 登录验证中间件\n * @author liyunfu\n */\n\nconst &#123; ErrorModel &#125; = require('../res-model/index')\n\nmodule.exports = async (ctx, next) => &#123;\n  const session = ctx.session\n\n  if (session &amp;&amp; session.userInfo) &#123;\n    await next()\n    return\n  &#125;\n  ctx.body = new ErrorModel(10003, '中间件登录验证失败')\n&#125;\n\n用户操作接口\n在controller 下新建 user.js\n/**\n * @description user controller\n * @author liyunfu\n */\n\nconst &#123; User &#125; = require('../models/index')\n\n/**\n * 注册方法\n * @param &#123;Object&#125; userInfo 用户信息\n * @returns \n */\nasync function register(userInfo = &#123;&#125;) &#123;\n  // 注意验证一下username unique\n  const newUser = await User.create(userInfo)\n  return newUser\n&#125;\n\nasync function login(username, password) &#123;\n  const user = await User.findOne(&#123; username, password &#125;)\n  if (user != null) &#123;\n    // 登录成功\n    return true\n  &#125;\n  return false\n&#125;\n\nmodule.exports = &#123;\n  register, login\n&#125;\n在routes 下新建users.js\nconst router = require('koa-router')()\n\n\nconst &#123; register, login &#125; = require('../controller/user')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user')\n\n// 注册\nrouter.post('/register', async function (ctx, next) &#123;\n  const userInfo = ctx.request.body\n  try &#123;\n    await register(userInfo)\n    // 返回成功\n    ctx.body = new SuccessModel()\n  &#125; catch (ex) &#123;\n    console.log(ex)\n    // 返回失败\n    ctx.body = new ErrorModel(10001, `注册失败 - $&#123;ex.message&#125;`)\n  &#125;\n&#125;)\n\n// 登录\nrouter.post('/login', async (ctx, next) => &#123;\n  const &#123; username, password &#125; = ctx.request.body\n  // 查询单个用户\n  const res = await login(username, password)\n\n  if (res) &#123;\n    // 登录成功\n    ctx.session.userInfo = &#123; username &#125;  //设置session\n\n    ctx.body = new SuccessModel()\n  &#125; else &#123;\n    ctx.body = new ErrorModel(10002, `登录验证失败`)\n  &#125;\n&#125;)\n\nrouter.get('/info', loginCheck, async function (ctx, next) &#123;\n  // 加了loginCheck之后，因为保证了必须登录\n  const session = ctx.session\n  ctx.body = new SuccessModel(session.userInfo)\n&#125;)\nmodule.exports = router\n\n地址操作接口\n在controller 下新建address.js\n/**\n * @description address controller\n * @author liyunfu\n */\n\nconst &#123; Address &#125; = require('../models/index')\n\n/**\n * 创建地址 \n * @param &#123;string&#125; username 用户名\n * @param &#123;Object&#125; data 地址的详细信息\n * @returns \n */\nasync function createAddress(username, data) &#123;\n  const address = await Address.create(&#123; username, ...data &#125;)\n\n  return address\n&#125;\n\n/**\n * 获取地址列表\n * @param &#123;string&#125; username 用户名\n * @returns \n */\nasync function getAddressList(username) &#123;\n  const list = await Address.find(&#123; username &#125;).sort(&#123; updatedAt: -1 &#125;)\n  return list\n&#125;\n\n/**\n * 获取单个收获地址\n * @param &#123;string&#125; id id\n * @returns \n */\nasync function getAddressById(id) &#123;\n  const address = await Address.findById(id)\n  return address\n&#125;\n\nasync function updateAddress(id, username, data) &#123;\n  const address = await Address.findOneAndUpdate(\n    &#123;\n      // 查询条件\n      _id: id,\n      username,\n    &#125;,\n    &#123;\n      username, ...data\n    &#125;,\n    &#123;\n      new: true  //返回更新之后的最新数据，默认时false，返回更新之前的数据\n    &#125;\n  )\n  return address\n&#125;\n\nmodule.exports = &#123;\n  createAddress,\n  getAddressList,\n  getAddressById,\n  updateAddress\n&#125;\n在routes 下新建address.js\n/**\n * @description address router\n * @author liyunfu\n */\n\nconst router = require('koa-router')()\nconst &#123; createAddress, getAddressList, getAddressById, updateAddress &#125; = require('../controller/address')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user/address')\n\n// 创建收货地址\nrouter.post('/', loginCheck, async (ctx, next) => &#123;\n  // 获取用户信息\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  const data = ctx.request.body\n\n  // 创建数据\n  try &#123;\n    const newAddress = await createAddress(username, data)\n    ctx.body = new SuccessModel(newAddress)\n  &#125; catch (error) &#123;\n    console.log(error)\n    ctx.body = new ErrorModel(10004, '创建收货地址失败')\n  &#125;\n&#125;)\n\n// 获取收货地址列表\nrouter.get('/', loginCheck, async (ctx, next) => &#123;\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 获取列表\n  const list = await getAddressList(username)\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 获取单个收获地址\nrouter.get('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const address = await getAddressById(id)\n\n  ctx.body = new SuccessModel(address)\n&#125;)\n\n// 更新收货地址\nrouter.patch('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const data = ctx.request.body\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  // 更新\n  const newAddress = await updateAddress(id, username, data)\n  ctx.body = new SuccessModel(newAddress)\n&#125;)\n\nmodule.exports = router\n\n商店商品接口\n在controller 下新建shop.js\n/**\n * @description shop controller\n * @author liyunfu\n */\n\nconst &#123; &#125; = require('../models/index')\n\n// 热门商店列表\nasync function getHotList() &#123;\n  const list = await Shop.find().sort(&#123; _id: -1 &#125;) //逆序\n  return list\n&#125;\n\n// 根据id获取单个商店信息\nasync function getShopInfo(id) &#123;\n  const shop = await Shop.findById(id)\n  return shop\n&#125;\n\n// 根据商店id获取商品\nasync function getProductByShopId(id, tab = '') &#123;\n  const pList = await Product.find(&#123;\n    shopId: id,\n    tabs: &#123;\n      $in: tab  //匹配tabs\n    &#125;\n  &#125;).sort(&#123; _id: -1 &#125;)  //逆序\n  return pList\n&#125;\n\nmodule.exports = &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125;\n在routes下新建shop.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel &#125; = require('../res-model/SuccessModel')\n\nconst &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125; = require('../controller/shop')\n\nrouter.prefix('/api/shop')\n\n// 热门商店（首页商店列表）\nrouter.get('/hot-list', async function (ctx, next) &#123;\n  const list = await getHotList()\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 根据 id 查询单个商店信息\nrouter.get('/:id', async function (ctx, next) &#123;\n  const id = ctx.params.id  //商店id\n  const shop = await getShopInfo(id)\n  ctx.body = new SuccessModel(shop)\n&#125;)\n\nrouter.get('/:id/product', async function (ctx, next) &#123;\n  const id = ctx.params.id\n  const tab = ctx.query.tab || 'all'\n  const products = await getProductByShopId(id, tab)\n  ctx.body = new SuccessModel(products)\n&#125;)\n\n订单接口\n在controller 下新建order.js\n/**\n * @description order controller\n * @author liyunfu\n */\n\nconst &#123; Order, Product, Address &#125; = require('../models/index')\n\n// 创建订单(要从Address，Product里拷贝数据，比较麻烦)\nasync function createOrder(username, data = &#123;&#125;) &#123;\n  console.log(username, data)\n  // 结构data(前端传来的订单信息)\n  const &#123;\n    addressId,\n    shopId,\n    shopName,\n    isCanceled = false,\n    products = []\n  &#125; = data\n\n  // 根据addressId获取地址信息\n  const address = await Address.findById(addressId)\n\n  // 获取商品列表\n  const pIds = products.map(p => p.id)\n  const productList = await Product.find(&#123;\n    // 条件1：商品id\n    _id: &#123;\n      $in: pIds\n    &#125;,\n    // 条件2：商店id\n    shopId\n  &#125;)\n\n  // 给商品列表增加销售数量(订单里，每个商品都有销量)\n  const productListWithSales = productList.map(p => &#123;\n    // 商品id\n    const id = p._id.toString()\n\n    // 找到商品销量\n    const filterProducts = products.filter(item => item.id === id)\n    if (filterProducts.length === 0) &#123;\n      // 没有找到匹配的数量 报错\n      throw new Error('未找到匹配的销量数据')\n    &#125;\n\n    return &#123;\n      orderSales: filterProducts[0].num,\n      product: p\n    &#125;\n  &#125;)\n\n  // 创建订单\n  const newOrder = await Order.create(&#123;\n    username,\n    address,\n    shopId,\n    shopName,\n    isCanceled,\n    products: productListWithSales\n  &#125;)\n  return newOrder\n&#125;\n\n// 获取订单列表\nasync function getOrderList(username) &#123;\n  console.log('username', username)\n  const list = await Order.find(&#123; username &#125;).sort(&#123; _id: -1 &#125;)\n  console.log('list', 'list')\n  return list\n&#125;\n\nmodule.exports = &#123;\n  createOrder,\n  getOrderList\n&#125;\n在routes 下新建order.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\nconst &#123; createOrder, getOrderList &#125; = require('../controller/order')\n\nrouter.prefix('/api/order')\n\n// 创建订单\nrouter.post('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证 可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 订单数据\n  const data = ctx.request.body\n\n  try &#123;\n    const newOrder = await createOrder(username, data)\n    ctx.body = new SuccessModel(newOrder)\n  &#125; catch (ex) &#123;\n    console.error(ex)\n    ctx.body = new ErrorModel(10005, '订单创建失败')\n  &#125;\n&#125;)\n\n// 获取订单列表\nrouter.get('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证，可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  const list = await getOrderList(username)\n\n  ctx.body = new SuccessModel(list)\n&#125;)\n\nmodule.exports = router\n\n改为适合部署到Vercel的项目\n在根目录下新建vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    &#125;\n  ]\n&#125;\n在根目录下新建index.js 将原bin/www内容移到此处\n\n修改package.json\n\"start\": \"node index.js\",\n\"dev\": \"./node_modules/.bin/nodemon index.js\",\n\"prd\": \"pm2 start index.js\",\n\n改造项目，实现跨域\n修改根目录下vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\",\n      \"headers\": &#123;\n        \"Access-Control-Allow-Credentials\": \"true\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,OPTIONS,PATCH,DELETE,POST,PUT\",\n        \"Access-Control-Allow-Headers\": \"X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version\"\n      &#125;\n    &#125;\n  ]\n&#125;\n\n​      \n","slug":"基于koa-generator搭建通用服务端","date":"2022-03-05T02:51:22.000Z","categories_index":"实战","tags_index":"实战,koa","author_index":"LIYUNFU"},{"id":"7bb7fcd214fc2de4ef1142bae196581d","title":"标准化大厂编码规范解决方案","content":"升级最新的vuenpm i vue@3.2.8 vue-router@4.0.11 vuex@4.0.2\n\nESLint规则// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象\n// 文档：https://eslint.bootcss.com/docs/user-guide/configuring\nmodule.exports = &#123;\n  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下\n  root: true,\n  // env 表示启用 ESLint 检测的环境\n  env: &#123;\n    // 在 node 环境下启动 ESLint 检测\n    node: true\n  &#125;,\n  // ESLint 中基础配置需要继承的配置\n  extends: [\"plugin:vue/vue3-essential\", \"@vue/standard\"],\n  // 解析器\n  parserOptions: &#123;\n    parser: \"babel-eslint\"\n  &#125;,\n  // 需要修改的启用规则及其各自的错误级别\n  /**\n   * 错误级别分为三种：\n   * \"off\" 或 0 - 关闭规则\n   * \"warn\" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n   * \"error\" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n   */\n  rules: &#123;\n    \"no-console\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    \"no-debugger\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    'space-before-function-paren': 0  //函数参数前括号没有空格\n  &#125;\n&#125;;\n\nPrettier配置.prettierrc\n&#123;\n  // 不尾随分号\n  \"semi\": false,\n  // 使用单引号\n  \"singleQuote\": true,\n  // 多行逗号分割的语法中，最后一行不加逗号\n  \"trailingComma\": \"none\"\n&#125;\n\n修改VSCode的TabSize\n配置大厂git提交规范全局安装Commitizennpm install -g commitizen@4.2.4\n\n安装并配置 cz-customizable 插件安装npm i cz-customizable@6.3.0 --save-dev\n\n添加以下配置到 package.json 中\"config\": &#123;\n  \"commitizen\": &#123;\n    \"path\": \"node_modules/cz-customizable\"\n  &#125;\n&#125;\n\n项目根目录下创建 .cz-config.js 自定义提示文件module.exports = &#123;\n  // 可选类型\n  types: [\n    &#123; value: 'feat', name: 'feat:     新功能' &#125;,\n    &#123; value: 'fix', name: 'fix:      修复' &#125;,\n    &#123; value: 'docs', name: 'docs:     文档变更' &#125;,\n    &#123; value: 'style', name: 'style:    代码格式(不影响代码运行的变动)' &#125;,\n    &#123;\n      value: 'refactor',\n      name: 'refactor: 重构(既不是增加feature，也不是修复bug)'\n    &#125;,\n    &#123; value: 'perf', name: 'perf:     性能优化' &#125;,\n    &#123; value: 'test', name: 'test:     增加测试' &#125;,\n    &#123; value: 'chore', name: 'chore:    构建过程或辅助工具的变动' &#125;,\n    &#123; value: 'revert', name: 'revert:   回退' &#125;,\n    &#123; value: 'build', name: 'build:    打包' &#125;\n  ],\n  // 消息步骤\n  messages: &#123;\n    type: '请选择提交类型:',\n    customScope: '请输入修改范围(可选):',\n    subject: '请简要描述提交(必填):',\n    body: '请输入详细描述(可选):',\n    footer: '请输入要关闭的issue(可选):',\n    confirmCommit: '确认使用以上信息提交？(y/n/e/h)'\n  &#125;,\n  // 跳过问题\n  skipQuestions: ['body', 'footer'],\n  // subject文字长度默认是72\n  subjectLimit: 72\n&#125;\n\n使用 git cz 代替 git commit使用 husky + commitlint 检查提交描述是否符合规范要求commitlint安装依赖：npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4\n\n根目录下创建 commitlint.config.js 文件module.exports = &#123;\n  // 继承的规则\n  extends: ['@commitlint/config-conventional'],\n  // 定义规则类型\n  rules: &#123;\n    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    'type-enum': [\n      2,\n      'always',\n      [\n        'feat', // 新功能 feature\n        'fix', // 修复 bug\n        'docs', // 文档注释\n        'style', // 代码格式(不影响代码运行的变动)\n        'refactor', // 重构(既不增加新功能，也不是修复bug)\n        'perf', // 性能优化\n        'test', // 增加测试\n        'chore', // 构建过程或辅助工具的变动\n        'revert', // 回退\n        'build' // 打包\n      ]\n    ],\n    // subject 大小写不做校验\n    'subject-case': [0]\n  &#125;\n&#125;\n\n注意：确保保存为 UTF-8 的编码格式，否则可能会出现以下错误：\n\nhusky安装依赖：npm install husky@7.0.1 --save-dev\n\n启动 hooks ， 生成 .husky 文件夹npx husky install\n\n在 package.json 中生成 prepare 指令\n执行 prepare 指令npm run prepare\n\n执行成功，提示\n添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx –no-install commitlint –edit “$1” 指令npx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"'\n\n此时的 .husky 的文件结构\n至此， 不符合规范的 commit 将不再可提交\n通过 pre-commit 检测提交时代码规范我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint –ext .js,.vue src 指令来去进行相关检测：\n\n 执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; 添加 commit 时的 hook （npx eslint --ext .js,.vue src 会在执行到该 hook 时运行） \n 该操作会生成对应文件 pre-commit： \n\n\nlint-staged 自动修复格式错误lint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送lint-staged 无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了\n修改 package.json 配置\"lint-staged\": &#123;\n    \"src/**/*.&#123;js,vue&#125;\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  &#125;\n\n修改 .husky/pre-commit 文件#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\nnpx lint-staged\n","slug":"标准化大厂编码规范解决方案","date":"2022-02-10T08:33:17.000Z","categories_index":"规范","tags_index":"git,规范","author_index":"LIYUNFU"},{"id":"4edaeadfac9de456799e43869dc8071d","title":"nestjs全解[windows版]","content":"前期准备基于docker配置数据库环境\n进入docker官网下载docker desktop\nhttps://www.docker.com/get-started/\n使用docker-compose简化运行方式\n由于docker desktop安装时已经自带docker-compose，我们只需要在C:\\Users\\[yourname]\\.docker  C盘你的用户目录下的.docker 文件夹下添加docker-compose.yml 即可\nversion: \"3.8\"\n\nservices:\n  mysql:\n    image: mysql:8.0.23\n    command: --default-authentication-plugin=mysql_native_password\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: example\n    ports:\n      - 3306:3306\n\n  postgres:\n    image: postgres:13.1\n    restart: always\n    environment:\n      POSTGRES_PASSWORD: example\n    ports:\n      - 5432:5432\n\n  adminer:\n    image: adminer\n    restart: always\n    ports:\n      - 8080:8080\n\n\n其中adminer 为可视化数据库管理系统，当启动images时，可以在localhost:8080 访问页面，另外两个为数据库\n\n在C:\\Users\\[yourname]\\.docker 当前目录下，执行docker-compose up 会自动拉取并执行images\ndocker-compose up\n\nNest.js认识Nest.js安装\n全局安装@nestjs/cli 工具，并新建项目learn_nest \nnpm i -g @nestjs&#x2F;cli\n\nnest new learn_nest\n安装好之后的src 核心文件\nsrc\n|-- app.controller.spec.ts\n|-- app.controller.ts\n|-- app.module.ts\n|-- app.service.ts\n|-- main.ts\n核心文件概述\n\n\n\n核心文件\n概述\n\n\n\napp.controller.ts\n带有单个路由的基本控制器示例\n\n\napp.controller.spec.ts\n对于基本控制器的单元测试样例\n\n\napp.module.ts\n应用程序的跟模块\n\n\napp.service.ts\n带有单个方法的基本服务\n\n\nmain.ts\n应用程序入口文件\n\n\n\nmain.ts 认识\nimport &#123; NestFactory &#125; from '@nestjs/core';\nimport &#123; AppModule &#125; from './app.module';\n\nasync function bootstrap() &#123;\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n&#125;\nbootstrap();\n\n// 使用NestFactory来创建Nest应用实例，并监听3000端口\n\n控制器controller\n控制器负责处理传入的请求 和向客户端返回响应 \n控制器的目的是接收应用的特定请求。路由机制控制哪个控制器接收哪些请求，通常，每个控制器有多个路由，不同的路由可以执行不同的操作。\n为了创建一个基本的控制器，我们使用类和装饰器 。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射(将请求绑定到相应的控制器)\n\n路由示例\n/* event.controller.ts */\nimport &#123;Controller,Get&#125; from '@/nestjs/common'\n\n@Controller('event')\nexport class EventController&#123;\n    @Get('/list')\n    findAll():string&#123;\n        return 'this is event all'\n    &#125;\n&#125;\n\n上面示例就可以在postman中请求urllocalhost:3000/event/list 即可得到返回结果\n\nRequest示例\n/* event.controller.ts */\nimport &#123;Controller,Get&#125; from '@/nestjs/common'\nimport &#123;Request&#125; from 'express'\n\n@Controller('event')\nexport class EventController&#123;\n    @Get('/list')\n    findAll(@Req() request:Request):string&#123;\n        return 'this is event all'\n    &#125;\n&#125;\n\n\n常见底层装饰器对照表\n\n\n\n装饰器\n对象\n\n\n\n@Request() , @Req()\nreq\n\n\n@Response() , @Res()\nres\n\n\n@Next()\nnext\n\n\n@Session()\nreq.session\n\n\n@Param(key?:string)\nreq.params/req.params[key]\n\n\n@Body(key?:string)\nreq.body / req.body[key]\n\n\n@Query(key?:string)\nreq.query / req.query[key]\n\n\n@Header(name?:string)\nreq.headers / req.headers[key]\n\n\n@Ip()\nreq.ip\n\n\n@HostParam()\nreq.hosts\n\n\n\n资源路由@Put()  @Delete() @Patch()  @Get()  @Post @All()\n\n 路由通配符 (路由同样支持模式匹配，例如星号被用作通配符)\n\n状态码\n@Post()\n@HttpCode(204)\ncreate() &#123;\n  return 'This action adds a new cat';\n&#125;\n\n返回状态码204\n\nHeaders\n可以指定返回头\n@Post()\n@Header('Cache-Control', 'none')\ncreate() &#123;\n  return 'This action adds a new cat';\n&#125;\n重定向\n@Redirect()装饰器有两个参数，url 和statusCode ，如果省略，则statusCode 默认为302 \n@Get()\n@Redirect('https://nestjs.com', 301\n\n有时候想要动态指定重定向地址，可以返回一个标准的对象，重定向到v5版本\n@Get('docs')\n@Redirect('https://docs.nestjs.com', 302)\ngetDocs(@Query('version') version) &#123;\n  if (version &amp;&amp; version === '5') &#123;\n    return &#123; url: 'https://docs.nestjs.com/v5/' &#125;;\n  &#125;\n&#125;\n路由参数\n当你需要接收动态数据 作为请求的一部分时，如GET /event/1 来获取id为1的event\n@Get(':id')\nfindOne(@Param() params):string&#123;\n    console.log(params.id)\n    return `this is return $&#123;params.id&#125;`\n&#125;\n\n或\n@Get(':id')\nfindOne(@Param('id'):id):string&#123;\n    return `this is return $&#123;id&#125;`\n&#125;\n子域路由\n即要求传入的HTTP 主机匹配某个特定的值才会响应\n@Controller(&#123; host: ':account.example.com' &#125;)\nexport class AccountController &#123;\n  @Get()\n  getInfo(@HostParam('account') account: string) &#123;\n    return account;\n  &#125;\n请求负载(规定接收的客户端参数)\n创建create-event.dto.ts \nexport class CreateEventDto &#123;\n  name: string;\n  description: string;\n  when: string;\n  address: string;\n&#125;\n\n\n在event.controller.ts 中使用\n@Post()\nasync create(@Body() input: CreateEventDto) &#123;\n  return await this.repository.save(&#123;\n    ...input,\n    when: new Date(input.when),\n  &#125;);\n&#125;\n\n​    最后一步，需要在App.module.ts中添加自定义的controller\nimport &#123; Module &#125; from '@nestjs/common';\nimport &#123; CatsController &#125; from './cats/cats.controller';\n\n@Module(&#123;\n  controllers: [EventController],\n&#125;)\nexport class AppModule &#123;&#125;\n\n\n\n提供者Providers模块Module中间件 Middleware异常过滤管道pipes守卫拦截器自定义装饰器基本原理技术安全","slug":"nestjs全解","date":"2022-04-23T01:38:46.000Z","categories_index":"服务端","tags_index":"数据库,服务端,nestjs,node","author_index":"LIYUNFU"},{"id":"d7e719f5c11a6405545a398b1276387c","title":"函数式编程范式","content":"函数式编程范式什么是函数式编程函数式编程就是利用纯函数实现细粒度的函数，通过函数组合组合成功能更强大的函数\n\n函数式编程对运算过程进行抽象，面向对象编程对事物进行抽象\n函数式编程中的函数指的不是程序中的函数，而是数学中的函数即映射关系\n相同的输入始终要得到相同的输出\n\n为什么要学习函数式编程\n函数式编程是随着React的流行受到越来越多关注\nVue3也开始拥抱函数式编程\n函数式编程可以抛弃this\n打包过程中可以更好的利用tree shaking过滤无用代码\n方便测试、方便并行处理\n有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda\n\n函数是一等公民\n函数可以存储在变量中\n函数作为参数\n函数作为返回值\n\n高阶函数什么是高阶函数\n高阶函数(Higher-order function)\n\n\n可以把函数作为参数传递给另一个函数\n可以把函数作为另一个函数的返回结果\n\n\n函数作为参数\n\n\n高阶函数模拟forEach\n\n\n\nfunction forEach(arr,fn)&#123;\n    for(let i=0;i&lt;arr.length;i++)&#123;\n        fn(arr[i])\n    &#125;\n&#125;\n\n// 测试\nlet arr=[1,3,4,6,7]\nforEach(arr,function(item)&#123;\n    console.log(item)\n&#125;)\n\n\n\n高阶函数模拟filter\n\n\n\n// filter\nfunction filter(arr,fn)&#123;\n    let results=[]\n    for(let i=0;i&lt;arr.length;i++)&#123;\n        if(fn(arr[i]))&#123;\n            results.push(arr[i])\n        &#125;\n    &#125;\n    return results\n&#125;\n\n// 测试\nconsole.log(filter(arr,function(item)&#123;\n    return item%2===0\n&#125;))\n\n\n函数作为返回值\n\n\n高阶函数模拟once\n\n\n\nfunction once(fn)&#123;\n    let done=false\n    return function()&#123;\n        if(!done)&#123;\n            done=true\n            return fn.apply(this,arguments)\n        &#125;\n    &#125;\n&#125;\n\nlet pay=once(function(money)&#123;\n    console.log(`支付：$&#123;money&#125; RMB`)\n&#125;)\n\n// 只会支付一次\npay(5)\npay(5)\npay(5)\n\n使用高阶函数的意义\n抽象可以帮我们屏蔽细节，只需要关注我们的目标\n高阶函数是用来抽象通用的问题\n\n常用高阶函数\nforEach\n\nmap\n\nfilter\n\nevery\n\nsome\n\nfind/findIndex\n\nreduce\n\nsort\n\n\n高阶函数实现map\n\n\n\n// map\nconst map=(arr,fn)=>&#123;\n    let results=[]\n    for(const value of arr)&#123;\n        results.push(fn(value))\n    &#125;\n    return results\n&#125;\n\n// 测试\nconst arr=[1,2,3,4,5]\nconsole.log(map(arr,function(item)&#123;\n    return item*2\n&#125;))\n\n\n\n高阶函数实现every 判断数组的元素是否都匹配\n\n\n\n//every\nconst every=(arr,fn)=>&#123;\n    let result=true\n    for(const value of arr)&#123;\n        result=fn(value)\n        if(!result)&#123;\n            break\n        &#125;\n    &#125;\n    return result\n&#125;\n\n// 测试\nconsole.log(every(arr,function(item)&#123;\n    return item>0\n&#125;))\n\n\n\n高阶函数实现some检测数组的元素是否有一个满足条件\n\n\n\n// some\nconst some=(arr,fn)=>&#123;\n    let result=false\n    for(const value of arr)&#123;\n        result=fn(value)\n        if(result)&#123;\n            break\n        &#125;\n    &#125;\n    return result\n&#125;\n\nconsole.log(some(arr,function(item)&#123;\n    return item%2===0\n&#125;))\n\n闭包什么是闭包可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的对象\n\n闭包的本质：函数在执行的时候会放在一个执行栈上当函数执行完毕之后会从执行栈上移出，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\n\n闭包案例封装一个求次方的方法\n// 生成计算数字的多少次幂的函数\nfunction makePower (power)&#123;\n    return function(x)&#123;\n        return Math.pow(x,power)\n    &#125;\n&#125;\n\nlet pow2=makePower(2)\nlet pow3=makePower(3)\n\nconsole.log(pow2(4))\nconsole.log(pow3(4))\n\n封装一个根据基本工资和绩效工资求实际工资\nfunction makeSalary(x)&#123;\n    return function(y)&#123;\n        return x+y\n    &#125;\n&#125;\n\nlet salaryLevel1=makeSalary(1500)\nlet salaryLevel2=makeSalary(2000)\n\nconsole.log(salaryLevel1(2000))\nconsole.log(salaryLevel2(4000))\n\n纯函数什么是纯函数\n相同的输入永远会得到相同的输出，而且没有任何可观察的副作用\n数组的slice和splice分别是纯函数和不纯的函数\n\nlet numbers = [1, 2, 3, 4, 5]\n// 纯函数\nnumbers.slice(0, 3)\n// => [1, 2, 3]\nnumbers.slice(0, 3)\n// => [1, 2, 3]\nnumbers.slice(0, 3)\n// => [1, 2, 3]\n// 不纯的函数\nnumbers.splice(0, 3)\n// => [1, 2, 3]\nnumbers.splice(0, 3)\n// => [4, 5]\nnumbers.splice(0, 3)\n// => []\n\n纯函数的好处\n可缓存\n\n\n因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来\n模拟memoize记忆函数\n\n\n\n// 模拟memoize方法的实现\nfunction memoize(fn)&#123;\n    let cache=&#123;&#125;\n    return function()&#123;\n        // 转为字符串\n        let key=JSON.stringify(arguments)\n        cache[key]=cache[key]||fn.apply(fn,arguments)\n        return cache[key]\n    &#125;\n&#125;\n\nlet getAreaWithMemory=memoize(getArea)\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))\n\n\n可测试\n\n并行处理\n\n\n在多线程环境下并行操作共享的内存数据很可能会出现意外情况\n纯函数不需要访问共享的内容数据，所以在并行环境下可以任意运行纯函数(Web Worker)\n\n\n\n副作用副作用让一个函数变得不纯，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用\n柯里化什么是柯里化\n当一个函数有多个参数的时候先传递一部分参数调用它(这部分参数以后永远不变)\n然后返回一个新的函数接收剩余的参数，返回结果\n\nfunction checkAge(min)&#123;\n    return function(age)&#123;\n        return age>=min\n    &#125;\n&#125;\n\nconst checkAge18=checkAge(18)\nconsole.log(checkAge18(20))\n\nlodash中的柯里化\n_.curry(fn)\n\n\n功能：创建一个函数，该函数接收一个或多个fn的参数，如果fn所需要的参数都被提供则执行fn并返回执行的结果，否则继续返回该函数并等待接收剩余的参数\n参数：需要柯里化的函数\n返回值：柯里化后的函数\n\n\n\nimport _ from 'lodash'\n\nfunction getSum(a,b,c)&#123;\n    return a+b+c\n&#125;\n\nconst curried=_.curry(getSum)\n\nconsole.log(curried(1,2,3))\nconsole.log(curried(1)(2)(3))\nconsole.log(curried(1,2)(3))\n\n柯里化案例\n判断一个字符串中是否有空白字符\n\nconst _ = require('lodash')\nconst match = _.curry(function (reg, str) &#123;\nreturn str.match(reg)\n&#125;)\nconst haveSpace = match(/\\s+/g)\nconst haveNumber = match(/\\d+/g)\nconsole.log(haveSpace('hello world'))\nconsole.log(haveNumber('25$'))\nconst filter = _.curry(function (func, array) &#123;\nreturn array.filter(func)\n&#125;)\nconsole.log(filter(haveSpace, ['John Connor', 'John_Donne']))\nconst findSpace = filter(haveSpace)\nconsole.log(findSpace(['John Connor', 'John_Donne']))\n\n模拟_.curry()的实现function curry (func) &#123;\nreturn function curriedFn (...args) &#123;\n// 判断实参和形参的个数\nif (args.length &lt; func.length) &#123;\nreturn function () &#123;\nreturn curriedFn(...args.concat(Array.from(arguments)))\n&#125;\n&#125;\n// 实参和形参个数相同，调用 func，返回结果\nreturn func(...args)\n&#125;\n&#125;\n\n总结\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住某些固定参数的新函数\n这是一种对函数参数的缓存\n让函数变得更灵活，让函数的粒度更小\n可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能\n\n","slug":"函数式编程范式","date":"2022-04-10T12:42:12.000Z","categories_index":"大前端","tags_index":"大前端,JavaScript","author_index":"LIYUNFU"},{"id":"1cfec3e13a62702637234d5f7c53b3fc","title":"Webpack配置及打包vue","content":"\n 安装webpack``webpack-cli\n\nnpm install webpack webpack-cli -D\n\n\n 配置入口出口\n\n// webpack.config.js\nmodule.exports = &#123;\n  mode: 'development',\n  entry: './src/index.js',\n  output: &#123;\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, './dist')\n  &#125;\n&#125;\n\n\n 处理sass\n\n安装sass``sass-loader``postcss-loader``css-loader``style-loader\n\n\nnpm install sass sass-loader postcss-loader css-loader style-loader -D\n\n\n添加postcss.config.js\n\nmodule.exports = &#123;\n  plugins: [\n    require('postcss-preset-env')\n  ]\n&#125;\n\n\n添加rules\n\nmodule: &#123;\n  rules: [\n    &#123;\n      test: /.(s[ac]ss|css)$/,\n      use: [\n        &#123; loader: 'style-loader' &#125;,\n        &#123; loader: 'css-loader' &#125;,\n        &#123; loader: 'postcss-loader' &#125;,\n        &#123; loader: 'sass-loader' &#125;\n      ]\n    &#125;,\n  ]\n&#125;\n\n\n 处理图片等文件资源和字体\n\n\n  v5已经可以试用asset替代file-loader url-loader``raw-loader了\n  添加rules\n\nmodule: &#123;\n  rules: [\n    &#123;\n      test: /.(png|svg|jpg|jpeg|git)$/i,\n      type: \"asset\",\n      generator: &#123;\n        filename: \"img/[name].[hash:6][ext]\"\n      &#125;,\n      parser: &#123;\n        dataUrlCondition: &#123;\n          maxSize: 100 * 1024\n        &#125;\n      &#125;\n    &#125;,\n    &#123;\n      test: /.(woff2?|eot|ttf)$/,\n      type: \"asset/resource\",\n      generator: &#123;\n        filename: \"font/[name].[hash:6][ext]\"\n      &#125;\n    &#125;\n  ]\n&#125;,\n\n\n\n 自动清理dist目录\n\nnpm install clean-webpack-plugin -D\n\nconst &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')\n\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n\n\n 打包html\n\nnpm install html-webpack-plugin -D\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nplugins:[\n  new HtmlWebpackPlugin(&#123;\n        title: 'webpack案例',\n        template: './index.html'\n  &#125;),\n]\n\n\n 自定义模板需要数据填充，需要defineplugin 已内置\n\nnew DefinePlugin(&#123;\n      BASE_URL: &#39;&quot;.&#x2F;&quot;&#39;\n&#125;),\n\n\n\n 自动复制public的内容到dist\n\nnpm install copy-webpack-plugin -D\n\n    new CopyWebpackPlugin(&#123;\n      patterns: [\n        &#123;\n          from: 'public',\n          globOptions: &#123;\n            ignore: [\n              '**/.DS_Store',\n              '**/index.html'\n            ]\n          &#125;\n        &#125;\n      ]\n    &#125;)\n\n\n 支持ES6 安装babel\n\n\n\n\n\n 安装babel\n\n\n\nnpm install babel-loader @babel/core -D\n\n\n\n 安装预设\n\n\n\nnpm install @babel/preset-env\n\n\n\n 新增rules\n\n\n\n&#123;\n  test: /.m?js$/,\n  use: &#123;\n    loader: \"babel-loader\",\n    options: &#123;\n      presets: [\n        [\"@babel/preset-env\"]\n      ]\n    &#125;\n  &#125;\n&#125;\n\n\n\n 也可以在babel.config.js配置预设\n\n\n\nmodule.exports = &#123;\n  presets: [\n    [\"@babel/preset-env\"]\n  ]\n&#125;\n\n\\\n\\\n打包vue\\\n\n 添加@vue/compiler-sfc vue-loader\n\nni @vue/compiler-sfc vue-loader -D\n\nconst &#123; VueLoaderPlugin &#125; = require('vue-loader/dist/index')\n\n\n&#123;\n  test: /.vue$/,\n  loader: \"vue-loader\"\n&#125;\n\nnew VueLoaderPlugin()\n\n\n public/index.html\n\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\" />\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    &lt;title>hello&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;div id=\"app\">&lt;/div>\n  &lt;/body>\n&lt;/html>\n\n\n src/app.vue\n\n&lt;template>\n  &lt;div>\n    &lt;h1>aoo&lt;/h1>\n    &lt;p>hello&lt;/p>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\nexport default &#123;&#125;\n&lt;/script>\n\n&lt;style lang=\"scss\" scoped>&lt;/style>\n\n\n src/index.js\n\nimport &#123; createApp &#125; from 'vue/dist/vue.esm-bundler'\nimport App from './App.vue'\nimport './style.scss'\n\n// vue代码\ncreateApp(App).mount('#app')\n\n\n\\\n搭建本地服务器webpack-dev-server\n  安装\n\nnpm install webpack-dev-server -D\n\n\n  配置webpack.config.js\n\ndevServer: &#123;\n    static: &#123;\n      directory: path.join(__dirname, './')\n    &#125;,\n    compress: true,\n    hot: true,\n    //host: '0.0.0.0',  // 表示在同一个网段下所有主机\n    port: 8000,\n    open: true,\n    proxy: &#123;\n      \"/api\": &#123;\n        target: \"http://localhost:8888\",\n        pathRewrite: &#123;\n          \"^/api\": \"\"\n        &#125;,\n        secure: false,\n        changeOrigin: true   //修改源\n      &#125;\n    &#125;\n  &#125;,\n\n\n  配置package.json\n\n\"scripts\": &#123;\n    \"build\": \"webpack --watch\",\n    \"serve\": \"webpack serve\"\n  &#125;,\n\n\n  使用nr serve启动\\\n\n  开启HMR\n\n\n\n\n\n\n  修改webpack配置\n\n\n\n\n配置devServerdevServer: &#123;\n   static: &#123;\n     directory: path.join(__dirname, './')\n   &#125;,\n   compress: true,\n   hot: true,\n   //host: '0.0.0.0',  // 表示在同一个网段下所有主机\n   port: 8000,\n   open: true,\n   proxy: &#123;\n     \"/api\": &#123;\n       target: \"http://localhost:8888\",\n       pathRewrite: &#123;\n         \"^/api\": \"\"\n       &#125;,\n       secure: false,\n       changeOrigin: true   //修改源\n     &#125;\n   &#125;\n &#125;,\n\nresolve模块解析\n  extensions解析到文件时自动添加扩展名 即可以省略后缀引入\n  alias取别名\n\nresolve: &#123;\n    extensions: ['.js', '.json'],\n    alias: path.resolve(__dirname, './src/js')\n  &#125;\n\n\n\\\n分离不同环境的配置\n  webpack.comm.config.js\n\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst &#123; DefinePlugin &#125; = require(\"webpack\");\nconst &#123; VueLoaderPlugin &#125; = require('vue-loader/dist/index');\n\nmodule.exports = &#123;\n  target: \"web\",\n  entry: \"./src/main.js\",\n  output: &#123;\n    path: path.resolve(__dirname, \"../build\"),\n    filename: \"js/bundle.js\",\n  &#125;,\n  resolve: &#123;\n    extensions: [\".js\", \".json\", \".mjs\", \".vue\", \".ts\", \".jsx\", \".tsx\"],\n    alias: &#123;\n      \"@\": path.resolve(__dirname, \"../src\"),\n      \"js\": path.resolve(__dirname, \"../src/js\")\n    &#125;\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /.css$/,\n        use: [\"style-loader\", \"css-loader\", \"postcss-loader\"],\n      &#125;,\n      &#123;\n        test: /.less$/,\n        use: [\"style-loader\", \"css-loader\", \"less-loader\"],\n      &#125;,\n      // &#125;,\n      &#123;\n        test: /.(jpe?g|png|gif|svg)$/,\n        type: \"asset\",\n        generator: &#123;\n          filename: \"img/[name]_[hash:6][ext]\",\n        &#125;,\n        parser: &#123;\n          dataUrlCondition: &#123;\n            maxSize: 10 * 1024,\n          &#125;,\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.(eot|ttf|woff2?)$/,\n        type: \"asset/resource\",\n        generator: &#123;\n          filename: \"font/[name]_[hash:6][ext]\",\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.js$/,\n        loader: \"babel-loader\"\n      &#125;,\n      &#123;\n        test: /.vue$/,\n        loader: \"vue-loader\"\n      &#125;\n    ],\n  &#125;,\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      template: \"./public/index.html\",\n      title: \"哈哈哈哈\"\n    &#125;),\n    new DefinePlugin(&#123;\n      BASE_URL: \"'./'\",\n      __VUE_OPTIONS_API__: true,\n      __VUE_PROD_DEVTOOLS__: false\n    &#125;),\n    new VueLoaderPlugin()\n  ],\n&#125;;\n\n\n  webpack.dev.config.js\n\nconst &#123; merge &#125; = require('webpack-merge');\n\nconst commonConfig = require('./webpack.comm.config');\n\nmodule.exports = merge(commonConfig, &#123;\n  mode: \"development\",\n  devtool: \"source-map\",\n  devServer: &#123;\n    contentBase: \"./public\",\n    hot: true,\n    // host: \"0.0.0.0\",\n    port: 7777,\n    open: true,\n    // compress: true,\n    proxy: &#123;\n      \"/api\": &#123;\n        target: \"http://localhost:8888\",\n        pathRewrite: &#123;\n          \"^/api\": \"\"\n        &#125;,\n        secure: false,\n        changeOrigin: true\n      &#125;\n    &#125;\n  &#125;,\n&#125;)\n\n\n  webpack.prod.config.js\n\nconst &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst &#123;merge&#125; = require('webpack-merge');\n\nconst commonConfig = require('./webpack.comm.config');\n\nmodule.exports = merge(commonConfig, &#123;\n  mode: \"production\",\n  plugins: [\n    new CleanWebpackPlugin(),\n    new CopyWebpackPlugin(&#123;\n      patterns: [\n        &#123;\n          from: \"./public\",\n          globOptions: &#123;\n            ignore: [\n              \"**/index.html\"\n            ]\n          &#125;\n        &#125;\n      ]\n    &#125;),\n  ]\n&#125;)\n\n\n  package.json\n\n&quot;scripts&quot;: &#123;\n    &quot;build&quot;: &quot;webpack --config .&#x2F;config&#x2F;webpack.prod.config.js&quot;,\n    &quot;serve&quot;: &quot;webpack serve --config .&#x2F;config&#x2F;webpack.dev.config.js&quot;\n  &#125;,\n\n\\\n完整webpack配置\n  webpack.config.js\n\nconst path = require(\"path\");\nconst &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst &#123; DefinePlugin &#125; = require(\"webpack\");\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst &#123; VueLoaderPlugin &#125; = require('vue-loader/dist/index');\n\nmodule.exports = &#123;\n  target: \"web\",\n  mode: \"development\",\n  devtool: \"source-map\",\n  entry: \"./src/main.js\",\n  output: &#123;\n    path: path.resolve(__dirname, \"./build\"),\n    filename: \"js/bundle.js\",\n  &#125;,\n  devServer: &#123;\n    contentBase: \"./public\",\n    hot: true,\n    // host: \"0.0.0.0\",\n    port: 7777,\n    open: true,\n    // compress: true,\n    proxy: &#123;\n      \"/api\": &#123;\n        target: \"http://localhost:8888\",\n        pathRewrite: &#123;\n          \"^/api\": \"\"\n        &#125;,\n        secure: false,\n        changeOrigin: true\n      &#125;\n    &#125;\n  &#125;,\n  resolve: &#123;\n    extensions: [\".js\", \".json\", \".mjs\", \".vue\", \".ts\", \".jsx\", \".tsx\"],\n    alias: &#123;\n      \"@\": path.resolve(__dirname, \"./src\"),\n      \"js\": path.resolve(__dirname, \"./src/js\")\n    &#125;\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /.css$/,\n        use: [\"style-loader\", \"css-loader\", \"postcss-loader\"],\n      &#125;,\n      &#123;\n        test: /.less$/,\n        use: [\"style-loader\", \"css-loader\", \"less-loader\"],\n      &#125;,\n      // &#125;,\n      &#123;\n        test: /.(jpe?g|png|gif|svg)$/,\n        type: \"asset\",\n        generator: &#123;\n          filename: \"img/[name]_[hash:6][ext]\",\n        &#125;,\n        parser: &#123;\n          dataUrlCondition: &#123;\n            maxSize: 10 * 1024,\n          &#125;,\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.(eot|ttf|woff2?)$/,\n        type: \"asset/resource\",\n        generator: &#123;\n          filename: \"font/[name]_[hash:6][ext]\",\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.js$/,\n        loader: \"babel-loader\"\n      &#125;,\n      &#123;\n        test: /.vue$/,\n        loader: \"vue-loader\"\n      &#125;\n    ],\n  &#125;,\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin(&#123;\n      template: \"./public/index.html\",\n      title: \"哈哈哈哈\"\n    &#125;),\n    new DefinePlugin(&#123;\n      BASE_URL: \"'./'\",\n      __VUE_OPTIONS_API__: true,\n      __VUE_PROD_DEVTOOLS__: false\n    &#125;),\n    // new CopyWebpackPlugin(&#123;\n    //   patterns: [\n    //     &#123;\n    //       from: \"public\",\n    //       to: \"./\",\n    //       globOptions: &#123;\n    //         ignore: [\n    //           \"**/index.html\"\n    //         ]\n    //       &#125;\n    //     &#125;\n    //   ]\n    // &#125;),\n    new VueLoaderPlugin()\n  ],\n&#125;;\n","slug":"Webpack配置及打包vue","date":"2022-04-10T12:08:54.000Z","categories_index":"知识点","tags_index":"工程化,vue","author_index":"LIYUNFU"},{"id":"46e88b89849dba43d2b30cc4164d9a11","title":"TS基础入门","content":"类型number类型let num:number=10\nlet num:number=10.1\nlet num:number=0b110  // 二进制\nlet num:number=0o555  // 八进制\nlet num:number=0xf23  // 十六进制\n\n\n\nboolean类型let flag:boolean=true\n\n\n\nstring类型let message:string='hello world'\n\n\n\nArray类型const names:string[]=['alen','john','bob']\nconst names:Array&lt;string> =['alen','john','bob']\n\n\n\nObject类型const myInfo:object=&#123;\n  name:'john',\n  age:18\n&#125;\n\n\n我们不能从myinfo中获取数据，也不能设置数据，只用来描述一个对象\n\nSymbol类型const s1:symbol=Symbol('title')\nconst s2:symbol=Symbol('title')\n\nconst person=&#123;\n  [s1]:'程序员',\n  [s2]:'老师'\n&#125;\n\n\n\nnull和undefined类型let n:null=null\nlet u:undefined=undefined\n\n\n\nany类型\n在某些情况下，我们无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以用any类型\n\nlet a:any='why'\na=123\na=true\n\nconst arr:any[]=['why',18]\n\n\n\nunknown类型\n用于描述不确定的变量\n\nfunction foo():string&#123;&#125;\nfunction bar():number&#123;&#125;\n\nconst flag=true\nlet result:unknown\n\nif(flag)&#123;\n  result=foo()\n&#125;else&#123;\n  result=bar()\n&#125;\n\nif(typeof result==='string')&#123;\n  console.log(result)\n&#125;\n\n\n\nvoid类型\n指定一个函数没有返回值，可以把null和undefined赋值给void，也就是函数可以返回null或者undefined\n函数没有写任何类型，默认返回值的类型就是void\n\nfunction sum(num1:number,num2:number):void&#123;\n  console.log(num1+num2)\n&#125;\n\n\n\nnever类型\nnever表示永远不会发生值得类型\n使用never指定死循环或者抛出异常得函数得值类型\n\nfunction handleMessage(message:number|string)&#123;\n  switch(typeof message)&#123;\n    case 'string':\n      console.info('foo')\n      break\n    case 'number':\n      console.info('bar')\n      break\n    default:\n      const check:never=message\n  &#125;\n&#125;\n\n\n\ntuple类型\ntuple和数组得区别\n\n数组通常存放相同类型得元素，不同类型得元素是不推荐放在数组中\n元素每个类型都有自己特性得类型，根据索引值获取到得值可以确定对应得类型\n\nconst info:[string,number,number]=['john',18,10]\n\ntuple的应用场景\ntuple通常可以作为返回的值，在使用的时候会非常的方便\nfunction useState&lt;T>(state:T):[T,(newState:T)=>void]&#123;\n\tlet currentState=state\n  const changeState=(newState:T)=>&#123;\n    currentState=newState\n  &#125;\n\treturn [currentState,changeState]\n&#125;\n\nconst [counter,setCounter]=useState(10)\n\n函数的返回值类型function sum(num1:number , num2:number):number&#123;\n  return num1+num2\n&#125;\n\n\n\n匿名函数的参数类型\n匿名函数可以自动推断出参数的类型\n\nconst names=['abc','def','ghi']\nnames.forEach(item=>&#123;\n  console.info(item.toUpperCase())\n&#125;)\n\n\n\n对象类型function printCoordinate(point:&#123;x:number,y:number&#125;)&#123;\n  console.info('x坐标',point.x)\n  console.info('y坐标',point.y)\n&#125;\nprintCoordinate(&#123;x:10,y:30&#125;)\n\n\n\n可选类型function printCoordinate(point:&#123;x:number,y:number,z?:number&#125;)&#123;\n  console.info('x坐标',point.x)\n  console.info('y坐标',point.y)\n  if(point.z)&#123;\n    console.info('z坐标',point.z)\n  &#125;\n&#125;\nprintCoordinate(&#123;x:10,y:30&#125;)\nprintCoordinate(&#123;x:20,y:30,z:40&#125;)\n\n\n\n联合类型\n联合类型是由两个或多个其他类型组成的类型\n表示可以是这些类型中的任何一个值\n联合类型中的每一个类型被称之位联合成员\n\nfunction printId(id:number|string)&#123;\n  console.log('你的id是',id)\n&#125;\nprintId(10)\nprintId('abc')\n\n\n\n类型别名\n编写对象类型和联合类型有时需要多次在其他地方使用，可以起别名\n\ntype Point=&#123;\n  x:number,\n  y:number\n&#125;\nfunction printPoint(point:Point)&#123;\n  console.info(point.x,point.y)\n&#125;\n\nfunction sumPoint(point:Point)&#123;\n  console.info(point.x+point.y)\n&#125;\n\nprintPoint(&#123;x:20,y:30&#125;)\nsumPoint(&#123;x:20,y:20&#125;)\n\ntype ID=number|string\nfunction printId(id:ID)&#123;\n  console.info('你的id',id)\n&#125;\n\n\n\n断言类型断言as\n有时候TS无法获取具体的类型信息，这时我们就需要使用类型断言\nTS只允许类型断言转换为更具体 或不太具体 的类型版本\n\nconst el=document.getElementById('box') as HTMLImageElement\n\nel.src='图片地址'\n\n\n\n非空断言\n当我们编写可选参数的时候，执行TS的编译阶段会报错\n\n这是因为传入的message有可能是undefined\nfunction printMessage(message?:string)&#123;\n  console.info(message:toUpperCase())\n&#125;\nprintMessage('hello')\n\n\n但是，我们确定传入的参数是有值的，这个时候我们可以使用非空类型断言\n\n非空断言使用的是! 表示可以确定某个标识符是有值得，跳过TS在编译阶段对他得检测\nfunction printMessage(message?:string)&#123;\n  console.info(message!.toUpperCase())\n&#125;\n\n\n\nJS新特性可选链的使用\n可选链操作符?. \n\n作用是当对象的熟悉不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行\ntype Person=&#123;\n  name:string,\n  friend?:&#123;\n    name:string,\n    age?:number,\n    girlFriend?:&#123;\n      name:string\n    &#125;\n  &#125;\n&#125;\n\nconst info:Person=&#123;\n  name:'why',\n  friend:&#123;\n    name:'kobe',\n    girlFriend:&#123;\n      name:'lily'\n    &#125;\n  &#125;\n&#125;\n\nconsole.info(info.friend?.name)\nconsole.info(info.friend?.age)\nconsole.info(info.friend?.girlFirend?.name)\n\n??和!! 的作用\n！！操作符\n\n将一个其他类型转换成boolean类型\n类似与Boolean的方式\n\n\n？？操作符\n\n空值合并操作符是一个逻辑操作符，当操作符的1左侧是null或者undefined时，返回其右侧操作数，否则返回左侧操作数\n\nconst message=\"\"\nlet flag=!!message  // true\n\nconst message='123'\nconst result=message??'321'\n\n字面量字面量类型\n多个类型联合起来，可以达到类似enum的效果\n\ntype Direction = 'TOP'|'BOTTOM'|'LEFT'|'RIGHT'\nfunction changeDeriction(direction:Direction)&#123;\n  console.info('转向',align)\n&#125;\n\nchangeDeriction('LEFT')\n\n\n\n字面量推理const info=&#123;\n  url:'https://baidu.com/abc',\n  method:'GET'\n&#125;\nfunction request(url:string,method:'GET'|'POST')&#123;\n  console.info(url,method)\n&#125;\nrequest(info.url,info.method)\n\n\n因为函数参数需要的时GET 或POST 字面量，所以不能将string赋值进去，解决方法\n\n// 方案1\nrequest(info.url,info.method as 'GET')\n\n// 方案2\nconst info=&#123;\n  url:'https://baidu.com',\n  method:'GET'\n&#125;as const\n\n\n\n函数函数类型type CalcFunc=(num1:number,num2:number)=>void\n\nfunction calc(fn:CalcFunc)&#123;\n  console.info(fn(20,30))\n&#125;\n\n\n\n参数的可选类型\n可选类型必须在必传参数的后面\n可选类型的类型是指定的类型和undefined联合\n\nfunction foo(x:number,y?:number)&#123;\n  console.info(x,y)\n&#125;\n\n\n\n默认参数function foo(x:number,y:number=6)&#123;\n  console.info(x,y)\n&#125;\nfoo(10)\n\n\n\n剩余参数function sum(...nums:number[])&#123;\n  let total=0\n  for(const num of nums)&#123;\n    total+=num\n  &#125;\n  return total\n&#125;\n\nconst result=sum(10,20,30)\n\n\n\nthis的类型\n某些时候可推导\n\nconst info=&#123;\n  name:'why',\n  asyHello()&#123;\n    console.info(this.name)\n  &#125;\n&#125;\ninfo.sayHello()\n\n\n不可推导时，需要指定\n\ntype NameType=&#123;\n  name:string\n&#125;\nfunction sayHello(this:NameType)&#123;\n  console.info(this.name)\n&#125;\n\n\n\n函数的重载function sum(a1:number,a2:number):number;\nfunction sum(a1:string,a2:string):string;\nfunction sum(a1:any,a2:any):any&#123;\n  return a1+a2\n&#125;\n\nconsole.info(sum(20,30))\nconsole.info(sum('aaa','bbb'))\n\n\n\n类类的定义class Person&#123;\n  name!:string\n  age:number\n  \n  constructor(name:string,age:number)&#123;\n    this.age=age\n  &#125;\n  \n  runing()&#123;&#125;\n&#125;\n\n\n\n如果我们不希望给属性初始化，可以使用name!:string 语法，加!\n\n类的继承class Student extends Person&#123;\n  sno:number\n  \n  constructor(name:string,age:number,sno:number)&#123;\n    super(name,age)\n    this.age=sno\n  &#125;\n  \n  studying()&#123;\n    console.info(this.name+'studying')\n  &#125;\n&#125;\n\n\n\n类的成员修饰符\npublic 任何地方可见，公有的属性或方法，默认编写的属性就是public\nprivate 修饰的是仅在同一类中可见、私有的属性或方法\nprotected 仅在自身和子类中可见\n\n只读属性readonly\n如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用readonly\n\nclass Person&#123;\n  readonly name:string\n  \n  constructor(name:string)&#123;\n    this.name=name\n  &#125;\n&#125;\n\nconst p=new Person('why')\nconsole.info(p.name)\n\np.name='code'  // error\n\n\n\ngetters/setters\n在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(getter)和设置(setter)的过程，这个时候我们可以使用存取器\nclass Person&#123;\n  private _name:string\n  \n  set name(newName)&#123;\n    this._name=newName\n  &#125;\n  get name()&#123;\n    return this._name\n  &#125;\n  \n  constructor(name:string)&#123;\n    this.name=name\n  &#125;\n&#125;\n\nconst p=new Person('why')\np.name='coder'\nconsole.info(p.name)\n\n静态成员class Student&#123;\n  static time:string='20:00'\n  \n  static attendClass()&#123;\n    console.info('去上课')\n  &#125;\n&#125;\n\nconsole.info(Student.time)\nStudent.attendClass()\n\n\n\n抽象类abstract\n抽象方法，必须存在于抽象类中\n抽象类是使用abstruct声明的类\n\n特点\n抽象类是不能被实例化的(也就是不能通过new创建)\n抽象方法必须被子类实现，否则该类必须是一个抽象类\n\nabstract class Shape&#123;\n  abstract getArea():number\n&#125;\n\nclass Circle extends Shape&#123;\n  private r:number\n  constructor(r:number)&#123;\n    super()\n    this.r=r\n  &#125;\n  getArea()&#123;\n    return this.r+this.r*3.14\n  &#125;\n&#125;\n\nclass Rectangle extends Shape&#123;\n  private width:number\n  private height:number\n  \n  constructor(width:number,height:number)&#123;\n    super()\n    this.width=width\n    this.height=height\n  &#125;\n  getArea()&#123;\n    return this.width+this.height\n  &#125;\n&#125;\n\nconst circle=new Circle(10)\nconst rectangle=new Reactangle(20,30)\nfunction calcArea(shape:Shape)&#123;\n  console.info(shape.getArea())\n&#125;\ncalcArea(circle)\ncalcArea(rectangle)\n\n\n\n类的类型class Person&#123;\n  name:string\n  constructor(name:string)&#123;\n    this.name=name\n  &#125;\n  runing()&#123;\n    console.info(this.name+'running')\n  &#125;\n&#125;\n\nconst p1:Person=new Person('why')\nconst p2:Person=&#123;\n  name:'kobe',\n  runing function()&#123;\n    console.info(this.name+'runing')\n  &#125;\n&#125;\n\n\n\n接口接口的声明interfacce Point&#123;\n  x:number\n  y:number\n&#125;\n\n\n\n可选属性interface Person&#123;\n  name:string\n  age?:number\n  friend?:&#123;\n    name:string\n  &#125;\n&#125;\n\nconst person:Person=&#123;\n  name:'why',\n  age:19,\n  friend:&#123;\n    name:'kobe'\n  &#125;\n&#125;\n\nconsole.info(person.name)\nconsole.info(person.friend?.name)\n\n\n\n只读属性\n接口中也可以定义只读属性\n\n这样就意味着我们在初始化之后，这个值是不可以被修改的\n\ninterface Person&#123;\n  readonly name:string\n  age?:number\n  readonly friend?:&#123;\n    name:string\n  &#125;\n&#125;\n\nconst person:Person=&#123;\n  name:'why',\n  age:19,\n  friend:&#123;\n    name:'kobe'\n  &#125;\n&#125;\n\nperson.name='code' //不可以设置\nperson.friend=&#123;&#125;  //不可以设置\n\nif(person.friend)&#123;\n  person.friend.name='123'  // 可以\n&#125;\n\n索引类型\n前面我们使用interface来定义对象类型，这个时候其中的属性名、类型、方法都是确定的，但是有时候我们会遇到类似下面的对象\n\ninterface FrontLanguage&#123;\n  [index:number]:string\n&#125;\n\nconst frontend:FrontLanguage=&#123;\n  1:'HTML',\n  2:'CSS',\n  3:'JS'\n&#125;\n\ninterface LanguageBirth=&#123;\n  [name:string]:number\n&#125;\n\nconst language:LanguageBirth=&#123;\n  \"Java\":1999,\n  \"JavaScript\":1000,\n  \"c\":1998\n&#125;\n\n\n\n函数类型\n前面我们都是通过interface来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型\n\ninterface CalcFunc&#123;\n  (num1:number,num2:number):number\n&#125;\n\nconst add:CalcFunc=(num1,num2)=>&#123;\n  return num1+num2\n&#125;\n\nconst sub:CalcFunc=(num1,num2)=>&#123;\n  return num1-num2\n&#125;\n\n\n推荐使用类型别名来定义函数\n\ntype CalcFunc=(num1:number,num2:number)=>number\n\n\n\n接口继承\n接口和类一样是可以进行继承的，也是使用extends关键字\n\n并且我们会发现，接口是支持多继承的\n\ninterface Person&#123;\n  name:string\n  eating:()=>void\n&#125;\n\ninterface Animal&#123;\n  runing:()=>void\n&#125;\n\ninterface Student extends Person,Animal&#123;\n  sno:number\n&#125;\n\nconst stu:Student=&#123;\n  sno:100,\n  name:'why',\n  eating:function()&#123;\n    \n  &#125;,\n  runing:function()&#123;&#125;\n&#125;\n\n接口实现\n接口定义后，也是可以被类实现的\n如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入\n这就是面向接口开发\n\n\n\ninterface ISwim&#123;\n  swimming:()=>void\n&#125;\n\ninterface IRun&#123;\n  runing:()=>void\n&#125;\n\nclass Person implements ISwim,IRun&#123;\n  swimming()&#123;\n    console.info('swimming')\n  &#125;\n  running()&#123;\n    console.info('running')\n  &#125;\n&#125;\n\nfunction swim(swimmer:ISwim)&#123;\n  swimmer.swimming()\n&#125;\n\nconst p=new Person()\nswim(p)\n\n\n\n\n\n交叉类型\n交叉类似表示需要满足多个类型的条件\n交叉类型使用&amp;符号\n在开发中进行交叉时，通常是对对象类型进行交叉的\n\ninterface Colorful&#123;\n  color:string\n&#125;\n\ninterface IRun&#123;\n  runing:()=>void\n&#125;\n\ntype NewType=Colorful&amp;IRun\n\nconst obj:NewType=&#123;\n  color:'red',\n  running:function()&#123;&#125;\n&#125;\n\n\n\ninterface和type的区别\ninterface可以重复的对某个接口来进行属性和方法\ntype定义的是别名，别名是不能重复的\n\ninterface IPerson&#123;\n  name:string\n  running:()=>void\n&#125;\n\ninterface IPerson&#123;\n  age:number\n&#125;\n\n\n枚举枚举类型enum Direction&#123;\n  LEFT,\n  RIGHT,\n  TOP,\n  BOTTOM\n&#125;\n\nfunction turnDirection(direction:Direction)&#123;\n  switch(direction)&#123;\n    case Direction.LEFT:\n      console.info('转向左边')\n      break;\n    case Direction.RIGHT:\n      console.info('转向右边')\n      break;\n    case Direction.TOP:\n      console.info('转向上边')\n      break;\n    case Direction.BOTTOM:\n      console.info('转向下边')\n      break;\n    default:\n      const myDirection:never=direction\n  &#125;\n&#125;\n\n\n\n\n\n泛型泛型接口interface IFoo&lt;T>&#123;\n  initialValue:T,\n  valueList:T[],\n  handleValue:(value:T)=>void\n&#125;\n\nconst foo:IFoo&lt;number>=&#123;\n  initialValue:0,\n  valueList:[0,1,2],\n  handleValue:function(value:number)&#123;\n    console.info(value)\n  &#125;\n&#125;\n\ninterface IFoo&lt;T=number>&#123;\n  initialValue:T,\n  valueList:T[],\n  handleValue:(value:T)=>void\n&#125;\n\n\n\n泛型类class Point&lt;T>&#123;\n  x:T\n  y:T\n  \n  constructor(x:T,y:T)&#123;\n    this.x=x\n    this.y=y\n  &#125;\n&#125;\n\nconst p1=new Point(10,20)\nconst p2=new Point&lt;number>(10,20)\nconst p3:Point&lt;number>=new Point(10,20)\n\n\n\n泛型约束\n有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中\n\n比如string和array都是有length的，或者某些对象也是会有length属性的\n那么只要是拥有length的属性都可以作为我们的参数类型\n\ninterface ILength&#123;\n  length:number\n&#125;\n\nfunction getLength&lt;T extends ILength>(args:T)&#123;\n  return args.length\n&#125;\n\nconsole.info(getLength('abc'))\nconsole.info(getLength(['abc','cba']))\nconsole.info(getLength(&#123;length:100,name:'why'&#125;))\n\n命名空间export namespace Time&#123;\n  export function format(time:string)&#123;\n    return '2022-01-01'\n  &#125;\n&#125;\nexport namespace Price&#123;\n  export function format(price:number)&#123;\n    return '222.22'\n  &#125;\n&#125;\n\n\n\n声明当一个模块引用的是另一个模块的数据时，没有引入需要声明\n声明变量、函数、类// \nlet wName='why'\nlet mAge=19\nlet mHeight=18\n\nfunction wFoo()&#123;\n  console.info('wfoo')\n&#125;\n\nfunction wBar()&#123;\n  console.info('wBar')\n&#125;\n\nfunction Person(name,age)&#123;\n  this.name=name\n  this.age=age\n&#125;\n\ndeclare let wName:string\ndeclare let wAge:number\ndeclare let wHeight:number\n\ndeclare function wFoo():void\ndeclare function wBar():void\n\ndeclare class Person&#123;\n  name:string\n  age:number\n  \n  constructor(name:string,age:number)\n&#125;\n\n\n\n声明模块\n我们也可以声明模块，比如lodash模块默认不能使用的情况，可以自己来声明这个模块\n\ndeclare module 'lodash'&#123;\n  export function join(args:any[]):any\n&#125;\n\n\n\n","slug":"TS基础入门","date":"2022-04-08T05:52:14.000Z","categories_index":"学习记录","tags_index":"TypeScript","author_index":"LIYUNFU"},{"id":"ce895751a313319f06b50d562f5dd5db","title":"ES6新特性","content":"let&amp;const解构赋值数组新特性\nArray.of() ：将一组值转化为数组，返回一个新数组，并且不考虑参数的数量或类型\ncopyWithin() ：把指定位置的成员复制到其他位置，返回原数组\nfind() ：返回第一个符合条件的值\nfindIndex() ：返回第一个符合条件的索引\nkeys() ： 对键名的1遍历，返回一个遍历器对象，可用for-of 循环\nvalues() ：与keys() 用法一样，不过是对键值的遍历\nentries() ：与keys() 用法一样，不过是对 键值对的遍历\nArray.from() ： 从一个类数组或可迭代对象中新建一个新的数组实例\nfill() ： 使用定制的元素填充数组，返回原数组\nincludes() ：判断是否包含某一个元素，返回布尔值，对NaN有效，但不能定位，第二个参数开始寻找位置\nflatMap() ：方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组\nflat() ： 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，默认值为1(应用：数组扁平化(当输入Infinity 自动解到最底层))\n\nlet arr = [1, 2, 3, 4, 5]\n\n//Array.of()\nlet arr1 = Array.of(1, 2, 3);\nconsole.log(arr1) // [1, 2, 3]\n\n//copyWithin(): 三个参数 (target, start = 0, end = this.length)\n// target: 目标的位置\n// start: 开始位置，可以省略，可以是负数。\n// end: 结束位置，可以省略，可以是负数，实际位置是end-1。\nconsole.log(arr.copyWithin(0, 3, 5)) // [4, 5, 3, 4, 5]\n\n//find()\nconsole.log(arr.find((item) => item > 3 )) // 4\n\n//findIndex()\nconsole.log(arr.findIndex((item) => item > 3 )) // 3\n\n// keys()\nfor (let index of arr.keys()) &#123;\n    console.log(index); // 一次返回 0 1 2 3 4\n&#125;\n\n// values()\nfor (let index of arr.values()) &#123;\n    console.log(index); // 一次返回 1 2 3 4 5\n&#125;\n\n// entries()\nfor (let index of arr.entries()) &#123;\n    console.log(index); // 一次返回 [0, 1] [1, 2] [2, 3] [3, 4] [4, 5]\n&#125;\n\n let arr = [1, 2, 3, 4, 5]\n\n// Array.from(): 遍历的可以是伪数组，如 String、Set结构，Node节点\nlet arr1 = Array.from([1, 3, 5], (item) => &#123;\n    return item * 2;\n&#125;)\nconsole.log(arr1) // [2, 6, 10] \n\n// fill(): 三个参数 (target, start = 0, end = this.length)\n// target: 目标的位置\n// start: 开始位置，可以省略，可以是负数。\n// end: 结束位置，可以省略，可以是负数，实际位置是end-1。\nconsole.log(arr.fill(7)) // [7, 7, 7, 7, 7]\nconsole.log(arr.fill(7, 1, 3)) // [1, 7, 7, 4, 5]\n\nlet arr = [1, 2, 3, 4]\n\n//includes()\nconsole.log(arr.includes(3)) // true\nconsole.log([1, 2, NaN].includes(NaN)); // true\n\nlet arr = [1, 2, 3, 4]\n\n// flatMap()\nconsole.log(arr.map((x) => [x * 2])); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\nconsole.log(arr.flatMap((x) => [x * 2])); // [ 2, 4, 6, 8 ]\nconsole.log(arr.flatMap((x) => [[x * 2]])); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\n\nconst arr1 = [0, 1, 2, [3, 4]];\nconst arr2 = [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr1.flat()); // [ 0, 1, 2, 3, 4 ]\nconsole.log(arr2.flat(2)); // [ 0, 1, 2, [ 3, 4 ] ]\nconsole.log(arr2.flat(Infinity)); // [ 0, 1, 2, 3, 4 ]\n\n字符串新特性\nUnicode：大括号包含表示Unicode字符\ncodePointAt() ： 返回字符对应码点，与fromCharCode() 对应\nString.fromCharCode() ：将对应的码点返回为字符，与codePointAt() 对应\nString.raw() ：返回把字符串所有变量替换且对斜杠进行转义的结果\nstartsWith() ： 返回布尔值，表示参数字符串是否存在元字符串的头部\nendsWith ：返回布尔值，表示参数字符串是否存在源字符串的头部\nrepart() ：返回一个新字符串，表示将原字符串重复n次\nincludes() ：返回布尔值，表示是否找到了参数字符串\ntrimStart() ：方法从字符串的开头删除空格，trimLeft() 是此方法的别名\ntrimEnd() ：方法从字符串的末端删除空格，trimRight() 是此方法的别名\npadStart() ： 用于头部补全\npadEnd() ： 用于尾部补全\nJSON.stringify() : 可返回不符合UTF-8标准的字符串\nreplace() ：仅替换一个 字符串中某模式的首个实例\nreplaceAll() ： 返回一个新字符串，该字符串中用一个替换项替换了原字符串所有匹配了模式的部分\n模式可以是一个字符串或一个正则表达式，而替换项可以是一个字符串或一个应用于每个匹配项的函数\n\n//Unicode\nconsole.log(\"a\", \"\\u0061\"); // a a\nconsole.log(\"d\", \"\\u&#123;4E25&#125;\"); // d 严\n\nlet str = 'Domesy'\n\n//codePointAt()\nconsole.log(str.codePointAt(0)) // 68\n\n//String.fromCharCode()\nconsole.log(String.fromCharCode(68)) // D\n\n//String.raw()\nconsole.log(String.raw`Hi\\n$&#123;1 + 2&#125;`); // Hi\\n3\nconsole.log(`Hi\\n$&#123;1 + 2&#125;`); // Hi 3\n\nlet str = 'Domesy'\n\n//startsWith()\nconsole.log(str.startsWith(\"D\")) // true\nconsole.log(str.startsWith(\"s\")) // false\n\n//endsWith()\nconsole.log(str.endsWith(\"y\")) // true\nconsole.log(str.endsWith(\"s\")) // false\n\n//repeat(): 所传的参数会自动向上取整，如果是字符串会转化为数字\nconsole.log(str.repeat(2)) // DomesyDomesy\nconsole.log(str.repeat(2.9)) // DomesyDomesy\n\n// 遍历：for-of\n for(let code of str)&#123;\n   console.log(code) // 一次返回 D o m e s y\n &#125;\n \n //includes()\n console.log(str.includes(\"s\")) // true\n console.log(str.includes(\"a\")) // false\n \n // trimStart()\n const string = \"   Hello world!   \";\n console.log(string.trimStart()); // \"Hello world!   \"\n console.log(string.trimLeft()); // \"Hello world!   \"\n \n // trimEnd()\n const string = \"   Hello world!   \";\n console.log(string.trimEnd()); // \"   Hello world!\"\n console.log(string.trimRight()); // \"   Hello world!\"\n\nlet str = 'Domesy'\n\n//padStart(): 会以空格的形式补位吗，这里用0代替，第二个参数会定义一个模板形式，会以模板进行替换\nconsole.log(\"1\".padStart(2, \"0\")); // 01\nconsole.log(\"8-27\".padStart(10, \"YYYY-0M-0D\")); //  YYYY-08-27\n \n// padEnd()：与padStart()用法相同\nconsole.log(\"1\".padEnd(2, \"0\")); // 10\n\n//JSON.stringify() 升级\nconsole.log(JSON.stringify(\"\\uD83D\\uDE0E\")); // 😎\nconsole.log(JSON.stringify(\"\\u&#123;D800&#125;\")); // \\ud800\n\nlet str = \"Hi！，这是ES6~ES12的新特性，目前为ES12\"\n\nconsole.log(str.replace(\"ES\", \"SY\")); // Hi！，这是SY6~ES12的新特性，目前为ES12\nconsole.log(str.replace(/ES/g, \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\n\nconsole.log(str.replaceAll(\"ES\", \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\nconsole.log(str.replaceAll(/ES/g, \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\n\n\n\n","slug":"ES6新特性","date":"2022-03-12T10:48:14.000Z","categories_index":"知识点","tags_index":"ES6,前瞻","author_index":"LIYUNFU"},{"id":"deb07f2084ce5c6636760b3189f1eaa0","title":"git命令备忘录","content":"\ngit init 初始化版本库\ngit add 每次提交前都要添加\ngit commit -m “修改信息”  \ngit log 打印提交记录\ngit diff readme  查看版本区别\ngit reset 回到某个版本  git reset --hard  版本代号\ngit reflog 打印操作记录 再使用git reset 版本号可以到未来\n工作区的文件git add之后到了暂存区，暂存区git commit一次性提交到master分支\ngit diff HEAD -- readme.txt 查看工作区和版本库里面最新版本的区别\ngit checkout -- readme.txt 丢弃工作区的修改，从暂存区恢复\ngit reset HEAD readme.txt暂存区回到上一个版本\ngit remote add origin git@github.com:michaelliao/learngit.git 关联远程仓库\ngit push -u origin master第一次推送\ngit push origin master以后推送\ngit remote -v查看远程仓库\ngit remote rm origin解除远程仓库\ngit switch -c dev创建并切换到新的dev分支\ngit switch master切换到master分支\ngit branch查看分支\ngit branch -d dev删除分支\ngit merge dev将dev分支合并到当前分支上\ngit merge --no-ff -m &quot;merge with no-ff&quot; dev合并分支并禁用快速合并\ngit stash把当前工作现场储存下来，方便下一次恢复现场继续工作 \ngit stash pop恢复现场，并把stash内容删除\ngit cherry-pick &lt;commit&gt;  如果当前也有bug 就把原先的提交复制到这儿一份\n命令git push origin &lt;tagname&gt;可以推送一个本地标签；\n命令git push origin --tags可以推送全部未推送过的本地标签；\n命令git tag -d &lt;tagname&gt;可以删除一个本地标签；\n命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。\n\n","slug":"git命令备忘录","date":"2022-03-05T03:08:36.000Z","categories_index":"知识点","tags_index":"git,备忘录","author_index":"LIYUNFU"},{"id":"6f0689131b9192e324f81c8459e5c263","title":"ajax基本使用及跨域过程","content":"ajax\n是什么：ajax是Asynchronous JavaScript and XML（异步 JavaScript 和 XMl）的简写\n异步：异步得像服务器发送请求，在等待响应的过程中，不会阻塞当前页面，浏览器可以做自己的事情。直到成功获取响应后，浏览器才开始处理响应数据\nAjax 需要服务器环境，非服务器环境下，很多浏览器无法正常使用ajax\n\nXMLHttpRequest//创建xhr对象\nconst xhr=new XMLHttpRequest();\n\n//监听事件，处理响应\nxhr.addEventListener('readystatechange',()=>&#123;&#125;,false)\n//或\nxhr.onreadystatechange=()=>&#123;&#125;\n\n//处理响应\nxhr.onreadystatechange=()=>&#123;\n    if(xhr.readyState!==4)return;\n    \n    //http code\n    //获取到响应后，响应的内容会自动填充xhr对象的属性\n    if(xhr.status>=200&amp;&amp;xhr.status&lt;300||xhr.status===304)&#123;\n        console.log(xhr.responseText)\n    &#125;\n&#125;\n\n/*\nreadystatechange 事件监听readyState这个状态的变化\n0: 未初始化，尚未调用open()\n1: 启动，已经调用open() 但尚未调用send()\n2: 发送，已经调用send() 但尚未接收到响应\n3: 接收，已经接收到部分响应数据\n4: 完成，已经接收到全部响应数据，而且已经可以在浏览器中使用了\n*/\n\n//准备发送请求\nxhr.open(\n\t'HTTP 方法 GET、POST、PUT、DELETE',\n    '地址 URL',\n    true //是否异步\n)\n\n//发送请求 send的参数是通过请求体携带的数据 只有post能携带请求体\nxhr.send(null)\n\n属性\nresponseType 和 response 属性\nxhr.onreadystatechange = () => &#123;\n  if (xhr.readyState != 4) return;\n  if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n    // 文本形式的响应内容\n    // responseText 只能在没有设置 responseType 或者 responseType = '' 或 'text' 的时候才能使用\n    // console.log('responseText:', xhr.responseText);\n    // 可以用来替代 responseText\n    console.log('response:', xhr.response);\n    // console.log(JSON.parse(xhr.responseText));\n  &#125;\n&#125;;\n\nxhr.responseType = 'text';\ntimeout属性\n//设置请求的超时时间（单位ms） 在发送之前\n xhr.open('GET', url, true);\n\nxhr.timeout = 10000;\n\nxhr.send(null);\nwithCredentials属性\n//指定使用ajax发送请求时是否携带cookie\nxhr.open('GET', url, true);\n\nxhr.withCredentials = true;\n\nxhr.send(null);\n\n方法\nabort() 终止当前请求\nxhr.open('GET', url, true);\nxhr.send(null);\nxhr.abort();\n//放在发送之后\nsetRequestHeader()设置请求头消息\nxhr.setRequestHeader(头部字段的名称, 头部字段的值);\nxhr.setRequestHeader('Content-Type','application/json')\n\n事件\nload事件 响应数据可用时触发\nxhr.onload=()=>&#123;&#125;\nxhr.addEventListener('load',()=>&#123;&#125;)\n//代替readystatechange 可以有效减少判断标识为4 的状态\nerror事件 请求发生错误时触发\nxhr.addEventListener(\n  'load',\n  () => &#123;\n    if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n      console.log(xhr.response);\n    &#125;\n  &#125;,\n  false\n);\nxhr.addEventListener(\n  'error',\n  () => &#123;\n    console.log('error');\n  &#125;,\n  false\n)\nabort事件 调用abort方法后触发\nxhr.addEventListener(\n  'abort',\n  () => &#123;\n    console.log('abort');\n  &#125;,\n  false\n);\n\nJson不支持undefined\n\nJSON.parse()\n将json字符串转化为JS的数据类型，对象或者数组\n\n\nJSON.stringify()\n将JS的基本数据类型，对象或者数组转化为JSON的字符串\n\n\n\nCORS\n使用CORS 跨域的过程\n① 浏览器发送请求\n② 后端在响应头中添加Access-Control-Allow-Origin 头信息\n③ 浏览器接收到响应\n④ 如果是同域下的请求，浏览器不会额外做什么，这次前后端通信就圆满了\n⑤ 如果是跨域请求，浏览器会从响应头中查找是否允许跨域访问\n⑥ 如果允许跨域，通信圆满完成\n⑦ 如果没找到或步包含想要跨域的域名，就丢弃响应结果\n\n\n","slug":"ajax基本使用及跨域过程","date":"2022-03-05T03:06:30.000Z","categories_index":"知识点","tags_index":"ajax,跨域","author_index":"LIYUNFU"},{"id":"c123efc46127ac74fdea33d3d47fa7a0","title":"远程服务器安装Docker并配置数据库","content":"Docker命令安装docker-desktop点击前往官网下载，一直下一步安装即可\n如果出现错误，说明wsl内核未更新到wsl2，点击下载安装之后重启docker-desktop即可\n查看已安装docker版本docker --version\n安装docker-compose\n\n\n\n\n\n\n\n\nDocker Compose是一个工具，旨在帮助定义和共享多容器应用程序。使用Compose，我们可以创建一个YAML文件来定义服务，并且使用单个命令，可以启动所有内容或将其全部拆解。使用 Compose的最大优点是，您可以在文件中定义应用程序堆栈，将其保留在项目存储库的根目录下（现在是受版本控制的），并轻松地让其他人能够为您的项目做出贡献。有人只需要克隆你的存储库并启动撰写应用。事实上，你现在可能会在GitHub/GitLab上看到相当多的项目在做这件事。\n简单来说就是 docker-compose能够让你自定义一个YAML配置文件，能够一键启动所有任务安装了docker desktop的自带docker-compose不需要再安装了\n\nLinux安装教程 https://docs.docker.com/compose/install/\n\n安装mongo使用Docker Hub搜索mongo 点击进入mongo-Docker Hub\ndocker pull mongo:4  #可接版本号也可不接\n\n查看本地下载了哪些镜像docker images\n\n运行mongo映射到宿主机上docker run -d --name some-mongo -p 10050:27017 mongo:4\n\n运行MYSQL映射到宿主机上docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -p 10051:3306 -d mysql:5.6\n\n查看当前运行的服务docker ps\n\n在Linux机器中需要放行端口 10050方案一 直接关闭防火墙#ubuntu\nservice ufw stop\n#centos\nservice firewalld stop\n\n方案二 放行指定端口# ubuntu\nufw allow Port 端口号\n\n#centos\nfirewall-cmd --zone&#x3D;public --add-port&#x3D;10050&#x2F;tcp --permanent\n\n重载防火墙firewall-cmd --reload\n\n提交自己的images提交到docker仓库docker commit id号  liyunfu&#x2F;mysql:1.0\ndocker push liyunfu&#x2F;mysql:1.0 \n\n拉取自己的imagesdocker pull liyunfu&#x2F;mysql:1.0\n\n删除imagesdocker image rm id号\n\n\n\ndocker-compose编写YML文件version: '3'\nservices:\n  mysql1:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10052:3306\n\n  mysql2:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10053:3306\n\n执行YMLdocker-compose up\n\n\n\nLinux连接远程服务器ssh -p 27822 root@server.bontor.cn   # ssh -p 端口  用户名@服务器地址\n\n查看操作系统版本lsb_release -a\n\n查看内核版本uname -a\n\n检查文件系统磁盘空间占用情况df -Th  # 后缀变为以G为单位 不加以字节为单位\n\n目录结构&#x2F;home  主目录\n&#x2F;etc   软件配置文件\n&#x2F;sys   系统目录\n&#x2F;usr   系统可执行文件\n&#x2F;var   日志文件 不断增长大小\n\nCPU和内存top #查看正在运行的进程 已经cpu占用情况 和内存使用情况\n\n文档型：文件相关命令(touch，cat，echo，rm，vi，cd)touch test.txt \nvi test.txt\ncd &#x2F;home\ncat test.txt\necho &quot;123123&quot;&gt;&gt;test.txt  #两个箭头追加 一个箭头覆盖  \n\n硬件型：磁盘/进程/服务/网络查看进程ps -ef | grep docker  #查询并使用grep筛选 docker进程\n\n强制关闭进程kill -9 进程的PID\n\n查看服务的状态service sshd status\n\n关闭服务service sshd stop  #关闭sshd服务\n\n重启服务service sshd restart\n\n功能型：压缩/解压，下载，远程下载wget 资源地址\n\n解压tar zxvf app.tar.gz\n\n压缩tar zcvf app.tar.gz app\n\n\n\n修改默认SSH端口查看默认监听端口netstat -anlp | grep sshd\n\n修改默认监听端口vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config\n#删除#  修改port 22 为 port 27001\n\n#centos修改之后必须运行\nsemanage port -a -t ssh_port_t -p tcp 27001   \n#提示没有该命令\nyum whatprovides semanage\n#找到拥有命令的包安装\nyum install -y policycoreutils-python\n#查看端口\nsemanage port -l | grep ssh\n\n#删除端口\nsemanage port -d -t ssh_port_t -p tcp 22\n","slug":"远程服务器安装Docker并配置数据库","date":"2022-03-05T03:02:36.000Z","categories_index":"实战","tags_index":"数据库,Docker","author_index":"LIYUNFU"},{"id":"417b0753cea51755f39f949bc1137c41","title":"Webpack5搭建标准开发环境","content":"Webpack安装&amp;使用安装npm install webpack webpack-cli -D\n\n使用方式方式一.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version\n\n方式二npx webpack --version\n\n\n\n入口(entry)\n\n\n\n\n\n\n\n\n**入口起点(entry point)*指示 webpack 应该使用哪个模块，来作为构建其内部依赖图*的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。\n出口(output)\n\n\n\n\n\n\n\n\noutput 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist\nconst config = &#123;\n    entry: './src/index.js',\n    output: &#123;\n        filename: 'bundle.js',\n        path: path.join(__dirname, './dist')\n    &#125;\n&#125;\n\n\nloader\n\n\n\n\n\n\n\n\nloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。\n让webpack处理CSS文件\n\n\n\n\n\n\n\n\nwebpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这种情况下，以 .css 结尾的全部文件，都将被提供给 style-loader 和 css-loader。\n\n下载依赖loader\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\n编写规则，匹配哪些后缀使用哪些loader  webpack.config.js\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.css$/,\n            use:['style-loader','css-loader']\n        &#125;\n    ]\n&#125;\nloader链式传递，先从后面的loader开始\n\n\n让webpack处理scss文件\n下载依赖loader\nnpm install sass-loader node-sass -D\n编写规则\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.(scss|sass)$/,\n            use:['style-loader','css-loader','sass-loader']\n        &#125;\n    ]\n&#125;,\n\nfile-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。\n让webpack处理图片\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test: /\\.(png|jpg|svg|gif)$/,\n    use:['file-loader']\n&#125;\n可以在index.js中引入\nimport Icon from './icon.jpg';\n\n//将图像添加到我们现有的div\nconst myIcon = new Image();\nmyIcon.src = Icon;\nelement.appendChild(myIcon);\n也可在index.scss中引入\n.hello&#123;\n  color: red;\n  background: url(\"./icon.jpg\");\n&#125;\n\n让webpack处理字体\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test:/\\.(woff|woff2|eot|ttf|otf)$/,\n    use:['file-loader']\n&#125;\n在index.scss中引入\n@font-face &#123;\n  font-family: 'Myfont';\n  src: url(\"./myfont.TTF\") format('ttf');\n  font-weight: 600;\n  font-style: normal;\n&#125;\n.hello&#123;\n  color: red;\n  font-family: Myfont;\n&#125;\n\n让webpack处理CSV、TSV 、XML\n下载依赖loader\nnpm install csv-loader xml-loader -D\n编写规则\n&#123;\n    test:/\\.(csv|tsv)$/,\n    use:['csv-loader']\n&#125;,\n&#123;\n    test:/\\.xml$/,\n    use:['xml-loader']\n&#125;\n在src下创建data.xml并在index.js中引入\n\ndata.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;note>\n    &lt;to>mary&lt;/to>\n    &lt;from>john&lt;/from>\n    &lt;heading>reminder&lt;/heading>\n    &lt;body>call cindy on tuesday&lt;/body>\n&lt;/note>\n\n\nindex.js\n\nimport Data from './data.xml';\n\nconsole.log(Data);\n\n插件(plugins)\n\n\n\n\n\n\n\n\nloader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。\n使用plugins处理html\n下载依赖plugins\nnpm install html-webpack-plugin -D\n由于插件可以携带参数/选项，所以必须在webpack配置中，向plugins属性传入new实例\n\n```js//处理src下的html文件plugins: [\n    new HtmlWebpackPlugin(&#123;template: &quot;./src/index.html&quot;&#125;)\n\n],\n\n## 模式(mode)\n\n&gt; 通过选择 &#96;development&#96; 或 &#96;production&#96; 之中的一个，来设置 &#96;mode&#96; 参数，你可以启用相应模式下的 webpack 内置的优化\n\n&#96;&#96;&#96;jsx\nmodule.exports &#x3D; &#123;\n  mode: &#39;production&#39;\n&#125;;\n\n模块热替换过程在应用程序中置换模块\n应用程序代码要求HMR runtime检查更新\nHMR runtime(异步)下载更新，然后通知应用程序代码\n应用程序代码要求HMR runtime应用更新\nHMR runtime(同步)应用更新\n\n在编译器中除了普通资源，编译器需要发出update，以允许更新之前的版本到新的版本，update由两部分组成：\n\n更新后的manifest(JSON)\n一个或多个更新后的chunk(JavaScript)\n\n配置标准开发环境ni babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;plugin-transform-runtime -D\nni @babel&#x2F;runtime \n\n创建.babelrc&#123;\n  \"presets\": [\n    \"@babel/preset-env\"\n  ],\n  \"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n  ]\n&#125;\n\n在webpack.config.js中rules添加规则&#123;\n    test:/\\.js$/,\n    loader: \"babel-loader\"\n&#125;\n\n\n\n\n\n\n\n\n\n\n第一里程碑\n自动清理dist目录webpack5.x之后在输出中添加clean:true即可\noutput: &#123;\n    filename: &#39;bundle.js&#39;,\n    path: path.join(__dirname, &#39;.&#x2F;dist&#39;),\n    clean: true\n&#125;,\n\n\nCleanWebpackPlugin does not clean in Webpack 5 - fsou (nilmap.com)\n复制资源到dist目录\n引入对应插件\n\nnpm install --save-dev copy-webpack-plugin\n\n\n编写新的plugin语法，旧语法有问题，因为CopyWebpackPlugin构造函数还支持其他选项\n\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nnew CopyWebpackPlugin(\n    &#123;\n        patterns: [\n            &#123;\n                from: path.join(__dirname, 'assets')\n                to: 'assets'\n            &#125;\n        ]\n    &#125;\n)\n\n\n\n\n\n\n\n\n\n\n\n错误信息：[webpack-cli] Invalid options object. Copy Plugin has been initialized using an options object that does not match the API schema.\n对js和css压缩 丑化JS和CSS压缩css和js\n安装依赖\nni css-minimizer-webpack-plugin -D\nni terser-webpack-plugin -D   &#x2F;&#x2F;让他来增强...扩展运算符\nni mini-css-extract-plugin -D  &#x2F;&#x2F;支持头部单独引用不许安装\n引入对应插件 \nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserJSPlugin=require('terser-webpack-plugin')\nrules\n&#123;\n    test: /\\.(scss|sass)$/,\n    use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']\n&#125;,\noptimization\noptimization: &#123;\n    minimize: true,  //设置开发环境可用，若不设置默认false只能支持生产环境\n    minimizer: [\n        `...`,   //使用扩展运算符增强\n        new CssMinimizerPlugin(),\n      \tnew TerserJSPlugin()\n    ]\n&#125;,\nplugins\nnew MiniCssExtractPlugin(&#123;\n    filename: '[name].css',\n    chunkFilename:'[id].css',\n&#125;),\nnew MiniCssExtractPlugin(),\nnew TerserJSPlugin()\n\n","slug":"Webpack5搭建标准开发环境","date":"2022-03-05T03:00:17.000Z","categories_index":"实战","tags_index":"Webpack,前端工程化","author_index":"LIYUNFU"},{"id":"fe45cec90ec11b72673f92c41490ffd7","title":"基于koa-generator实现验证码功能","content":"第一步\n全局安装koa-generator\n\n```shellnpm install -g koa-generator\n\n- 生成基本框架\n\n- &#96;&#96;&#96;shell\n  koa2 apiname    \n  # 使用koa2后面接目录名即可自动创建名为apiname的目录\n根据命令行提示，进入创建的文件夹，执行npm install\n\n```shellcd apinamenpm install\n\n- 下载依赖完成之后，可以启动看看\n\n- &#96;&#96;&#96;shell\n  npm run start\n打开浏览器访问3000端口\n\n```shellhttp://localhost:3000\n\n- 如果浏览器中页面显示出数据即创建成功，可以进入下一步\n\n\n\n### 第二步\n\n- 在根目录下新建&#96;src&#96;目录\n\n- 将&#96;public&#96; 、&#96;routes&#96; 、&#96;views&#96; 、&#96;app.js&#96;拖入&#96;src&#96;目录\n\n- 修改&#96;bin&#x2F;www&#96;中的&#96;var app &#x3D; require(&#39;..&#x2F;app&#39;);&#96;为&#96;var app &#x3D; require(&#39;..&#x2F;src&#x2F;app&#39;);&#96;\n\n- 改造后目录\n\n- &#96;&#96;&#96;shell\n  |- bin\n    |- www\n  |-node_modules\n  |-src\n    |-public\n    |-routes\n    |-views\n    |-app.js\n  |-package.json\n在src目录下创建目录controller\n\n\n第三步\n安装用于聚合router的包\n\n安装koa-combine-routers包\n\n```shellnpm install koa-combine-routers\n\n- 安装&#96;svg-captcha&#96;  包 用于生成&#96;svg&#96;验证码\n\n- &#96;&#96;&#96;shell\n  npm install svg-captcha\n在controller目录下创建publicController.js 用于生成验证码 并输入以下代码\n\n```jsconst svgCaptcha = require(“svg-captcha”);\nfunction  publicController(ctx) {  //创建一个新验证码svg对象  const newCaptcha = svgCaptcha.create({\nsize: 4,  //验证码长度\nignoreChars: &quot;0o1il&quot;, //排除易混淆的几个0o1il字符\ncolor: true,   //验证码有颜色\nnoise: Math.floor(Math.random() * 5), //干扰线\nwidth: 150,  \nheight: 50,\n\n  });  ctx.body = {\nmsg: newCaptcha.data,\n\n  };}\nmodule.exports = publicController;\n\n- 在&#96;routes&#96;目录下新建&#96;publicRouter.js &#96; 输入以下代码\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;koa-router&quot;)();\n  const getCaptcha &#x3D; require(&quot;..&#x2F;controller&#x2F;PublicController&quot;);\n  \n  router.get(&quot;&#x2F;getCaptcha&quot;, getCaptcha);\n  \n  module.exports &#x3D; router;\n在routes目录下新建routes.js 输入以下代码\n\n```jsconst combineRoutes=require(‘koa-combine-routers’)\nconst aRoutes=require(‘./publicRouter’)\nmodule.exports=combineRoutes(  aRoutes   //如果有多个 可以引入多个，并写在此处用逗号隔开)\n\n- 在&#96;app.js&#96;引入&#96;routes.js&#96; 并使用\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;.&#x2F;routes&#x2F;routes&quot;);\n  app.use(router())\n实现跨域请求，下载并引入koa2-cors包\n\n```shellnpm install koa2-cors\nconst cors = require(“koa2-cors”);\n//cors配置app.use(  cors({\norigin: &quot;http://localhost:8080&quot;, //前端origin\ncredentials: true, //允许跨域带cookie\n\n  }));\n\n\n\n### 第四步\n\n使用&#96;vue&#96;项目，尝试请求验证码  下载&#96;axios&#96;包\n\n&#96;&#96;&#96;vue\n&lt;template&gt;\n\t&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div class&#x3D;&quot;svg&quot; @click&#x3D;&quot;getCaptcha&quot; v-html&#x3D;&quot;svg&quot;&gt;验证码&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nconst axios &#x3D; require(&#39;axios&#39;)\nexport default &#123;\n  name: &#39;app&#39;,\n  data () &#123;\n    return &#123;\n      svg: &#39;&#39;\n    &#125;\n  &#125;,\n  mounted () &#123;\n    this.getCaptcha()\n  &#125;,\n  methods: &#123;\n    getCaptcha () &#123;\n      axios.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;getCaptcha&#39;).then((res) &#x3D;&gt; &#123;\n        if (res.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          this.svg &#x3D; res.data.msg\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n","slug":"基于koa-generator实现验证码功能","date":"2022-03-05T02:56:54.000Z","categories_index":"实战","tags_index":"Koa","author_index":"LIYUNFU"},{"id":"2dd921bc2e0b67b467ed4b61518bdc3d","title":"MongoDB的CRUD","content":"MongoDB初见\nDocker中MongoDB数据的备份与恢复#备份\ndocker exec -it 镜像名 mongodump -h 地址 -u root -p example -o 备份到的地址\ndocker exec -it some-mongo mongodump -h localhost -u root -p example -o &#x2F;temp&#x2F;test\n\n\n\n是什么\n存储文档的非关系型数据库\n\n\n\n可以将多个不同的内容添加到一个集合里面，如果想要添加字段，直接添加，不会报错\n\nMongoDB的CRUD创建文档创建一个文档\n自己提供文档主键_id值，容易出现错误，可以省略文档_id字段，让它自动生成，collection为集合\n\ndb.collection.insertOne(\n\t&#123;\n\t_id: &quot;account1&quot;,\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\ndb.collection.insertOne(\n\t&#123;\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\n创建多个文档\nordered参数用来决定mongoDB是否要按顺序来写入这些文档\nordered:false 表示可以打乱文档写入顺序，以便优化写入的操作\nordered:true(默认值)按顺序执行，如果第一条插入数据错误，那么第二天不会执行\n\n\n\ndb.accounts.insertMany(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t,\n\t&#123;\n\t\tordered:false  &#x2F;&#x2F;可选\n\t&#125;\n)\n\n\n创建单个或多个文档\nsave命令运行时调用insert   db.collection.save \n\ndb.accounts.insert(\n\t&#123;\n\tname: &quot;alice1&quot;,\n\tbalance: 100\n\t&#125;,\n)\n\ndb.accounts.insert(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t\n)\n\n\n\ninsertOne 、insertMany 、insert的区别\n正确和错误返回的结果不同\n\ninsertOne和insertMany命令不支持db.collection.explain()名\n\ninsert支持db.collection.explain命令\n\n\n读取文档读取全部文档\n既不筛选，也不投射\ndb.accounts.find()\n更清晰的显示文档\ndb.accounts.find().pretty()\n\n匹配查询\n读取alice的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;&#125;)\n读取alice的余额为100元的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;,balance: 100&#125;)\n读取复合主键的文档\ndb.accounts.find(&#123;&quot;_id.type&quot;: &quot;savings&quot;&#125;)\n\n比较操作符\n\n\n操作符\n含义\n\n\n\n$eq\n相等查询值的文档\n\n\n$ne\n不等查询值的文档\n\n\n$gt\n大于查询值的文档\n\n\n$gte\n大于或等于查询值的文档\n\n\n$lt\n小于查询值的文档\n\n\n$lte\n小于或等于查询值的文档\n\n\n$in\n与任一查询值相等的文档\n\n\n$nin\n与任何查询值都不等的文档\n\n\n\n读取不属于alice的银行账户文档\ndb.accounts.find(&#123;name: &#123;$ne:&quot;alice&quot;&#125;&#125;)\n读取余额大于500的银行账户文档\ndb.accounts.find(&#123;balance: &#123;$gt:500&#125;&#125;)\n读取用户名字排在fred之前的银行账户文档\ndb.accounts.find(&#123;name: &#123;$lt:&quot;fred&quot;&#125;&#125;)\n读取alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$in:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n读取既不是alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$nin:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n\n逻辑操作符\n\n\n逻辑操作符\n含义\n\n\n\n$not\n筛选条件不成立的文档\n\n\n$and\n多个条件全部成立的文档\n\n\n$or\n至少一个筛选条件成立的文档\n\n\n$nor\n多个筛选条件全部不成立的文档\n\n\n\n读取余额不小于500的银行账户文档  \ndb.accounts.find(&#123;balance:&#123;$not:&#123;$lt:500&#125;&#125;&#125;)\n读取余额大于100并且用户姓名排在fred之后的银行账户文档\ndb.accounts.find(&#123;$and:[&#123;balance:&#123;$gt:100&#125;&#125;,&#123;name:&#123;$gt:&quot;fred&quot;&#125;&#125;]&#125;)\n读取余额大于100并且小于500的银行账户文档\ndb.accounts.find(&#123;balance:&#123;$lt:500,$gt:100&#125;&#125;&#125;)\n读取属于alice或者charlie的银行账户文档\ndb.accounts.find(&#123;\n\t$or:[\n\t\t&#123;name:&#123;$eq:&quot;alice&quot;&#125;&#125;,\n\t\t&#123;name:&#123;$eq:&quot;charlie&quot;&#125;&#125;\n\t]\n&#125;)\n读取既不属于alice和charlie且余额不小于100的银行账户文档\ndb.accounts.find(&#123;\n\t$nor:[\n\t\t&#123;name:&quot;alice&quot;&#125;,\n\t\t&#123;name:&quot;charlie&quot;&#125;,\n\t\t&#123;balance:&#123;$lt:100&#125;&#125;\n\t]\n&#125;)\n\n字段操作符\n\n\n操作符\n含义\n\n\n\n$exists\n包含查询字段的文档\n\n\n$type\n字段类型符合查询值的文档\n\n\n\n读取包含账户类型字段的银行账户文档\ndb.accounts.find(&#123;&quot;_id.type&quot;:&#123;$exists:true&#125;&#125;)\n读取文档主键是字符串的银行账户文档\ndb.accounts.find(&#123;_id:&#123;$type:&quot;string&quot;&#125;&#125;)\n\n数组操作符\n\n\n操作符\n含义\n\n\n\n$all\n数组字段中包含所有查询值的文档\n\n\n$elemMatch\n数组字段中至少存在一个值满足筛选条件的文档\n\n\n\n读取联系地址位于中国北京的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$all:[&quot;china&quot;,&quot;beijing&quot;]&#125;&#125;)\n读取联系电话范围在100000和200000之间的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$elemMatch:&#123;$gt:&quot;100000&quot;,$lt:&quot;200000&quot;&#125;&#125;&#125;)\n\n正则操作符\n读取用户姓名以c或者j开头的银行账号文档\ndb.accounts.find(&#123;name:&#123;$in:[&#x2F;^c&#x2F;,&#x2F;^j&#x2F;]&#125;&#125;)\n读取用户姓名包含LIE(不区分大小写)的银行账户文档\ndb.accounts.find(&#123;name:&#123;$regex:&#x2F;LIE&#x2F;,$options:&#39;i&#39;&#125;&#125;)\n\n文档游标\n查询语句默认返回的是文档游标，默认只显示前二十条\n\n游标函数var cursor=db.accounts.find()\n\n\ncursor.hasNext() cursor.next()\n\n```jsvar myCursor=db.accounts.find({name:”alice”})while(myCursor.hasNext()){  printjson(myCursor.next())}  //只要还有就把剩余文档打印出来\n\n- &#96;cursor.forEach()&#96;\n\n- &#96;&#96;&#96;js\n  var myCursor&#x3D;db.accounts.find(&#123;name:&quot;alice&quot;&#125;)\n  myCursor.forEach(printjson)   &#x2F;&#x2F;每篇文档被打印\ncursor.limit()\n\ncursor.skip()\n\n```jsdb.accounts.find({name:”alice”}).limit(1)  //只返回第一篇文档db.accounts.find({name:”alice”}).skip(1)   //跳过第一篇 只显示第二篇和第三篇\n\n- &#96;cursor.count()&#96;\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count()   &#x2F;&#x2F;返回3\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count(true)  &#x2F;&#x2F;返回1\n  &#x2F;&#x2F;默认不接收limit和skip返回的结果\ncursor.sort()\n\n按照余额从大到小，用户名按字母顺序排序\n\n```jsdb.accounts.find().sort({balance:-1,name:1})\n\n\n\n#### 游标注意事件\n\n- &#96;cursor.skip()&#96;在&#96;cursor.limit()&#96;之前执行\n- &#96;cursor.sort()&#96;在&#96;cursor.skip()&#96;和&#96;cursor.limit()&#96;之前执行\n\n\n\n#### 文档投影\n\n- 只返回银行账户文档中的用户姓名\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;&#125;,&#123;name:1&#125;)\n\n\n只返回银行账户文档中的用户姓名(不包含文档主键)\n\ndb.accounts.find(&#123;&#125;,&#123;name:1,_id:0&#125;)\n\n\n除了文档主键之外，我们不可以在投影文档中混合使用包含和不包含这两种投影操作要么在投影文档中列出所有应该包含的字段，要么列出所有不应该包含的字段\n\n\n更新文档","slug":"MongoDB的CRUD","date":"2022-03-05T02:54:11.000Z","categories_index":"实战","tags_index":"MongoDB,数据库,Mongoose","author_index":"LIYUNFU"},{"id":"b9b69e275d0ea3fd4374ffde1f72e980","title":"JSX如何\"摇身一变\"成为DOM的","content":"JSX代码如何变成DOM抛出问题\n  JSX的本质是什么，它和JS之间到底是什么关系？\n\n  为什么要用JSX？不用会有什么后果？\n\n  JSX背后的功能模块是什么，这个功能模块都做了那些事\n\n\n尝试解答\n  JSX的本质是JS的拓展，但是浏览器不能天然支持JSX，所以需要Babel将它编译为React.createElement()的调用，语法糖返回一个叫React Element的JS对象\n\n\n\n  既然最后编译为React.createElement()的调用，为什么不直接使用React.createElement()呢？\n答：\n  由于实现同样的功能的情况下，JSX代码层次分明，语言简练，而React.createElement()代码繁重\n  JSX语法糖允许前端开发者使用我们最为熟悉的类HTML标签语法来创建虚拟DOM，在降低学习成本的同时，也提升了研发效率和研发体验\n\n\n\n\\\n\n  \n\n\\\ncreateElement解析&#x2F;**\n  React的创建元素方法\n *&#x2F;\n\nfunction createElement(type, config, children) &#123;\n  &#x2F;&#x2F; propName用于储存后面需要用到的元素属性\n  var propName;\n  &#x2F;&#x2F; props用于储存元素属性的键值对集合\n  var props &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; key、ref、self、source均为React元素的属性\n  var key &#x3D; null;\n  var ref &#x3D; null;\n  var self &#x3D; null;\n  var source &#x3D; null;\n\n  &#x2F;&#x2F; config 对象中存储的是元素的属性\n  if (config !&#x3D; null) &#123;\n    &#x2F;&#x2F; 进来之后的第一件事，依次对ref、key、self和source属性赋值\n    if (hasValidRef(config)) &#123;\n      ref &#x3D; config.ref;\n\n      &#123;\n        warnIfStringRefCannotBeAutoConverted(config);\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 此处将key 值字符串化\n    if (hasValidKey(config)) &#123;\n      key &#x3D; &#39;&#39; + config.key;\n    &#125;\n\n    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;\n    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source; &#x2F;&#x2F; Remaining properties are added to a new props object\n\n    &#x2F;&#x2F; 接着就是要把config里面的属性都一个一个挪到props对象里面\n    for (propName in config) &#123;\n      if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;\n        props[propName] &#x3D; config[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; childrenLength 指的是当前元素的子元素的个数，减去的2是type和config两个参数占用的长度\n  var childrenLength &#x3D; arguments.length - 2;\n\n  &#x2F;&#x2F; 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;\n    &#x2F;&#x2F; 直接把这个值赋值给props.children\n    props.children &#x3D; children;\n  &#125; else if (childrenLength &gt; 1) &#123;\n    &#x2F;&#x2F; 处理嵌套多个子元素的情况\n    &#x2F;&#x2F; 声明一个数组，把所有剩余对象参数都遍历传入，最后把数组赋值给props.children对象\n    var childArray &#x3D; Array(childrenLength);\n\n    for (var i &#x3D; 0; i &lt; childrenLength; i++) &#123;\n      childArray[i] &#x3D; arguments[i + 2];\n    &#125;\n\n    &#123;\n      if (Object.freeze) &#123;\n        Object.freeze(childArray);\n      &#125;\n    &#125;\n\n    props.children &#x3D; childArray;\n  &#125; &#x2F;&#x2F; Resolve default props\n\n  &#x2F;&#x2F; 处理defaultProps\n  if (type &amp;&amp; type.defaultProps) &#123;\n    var defaultProps &#x3D; type.defaultProps;\n\n    for (propName in defaultProps) &#123;\n      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;\n        props[propName] &#x3D; defaultProps[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#123;\n    if (key || ref) &#123;\n      var displayName &#x3D; typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39; ? type.displayName || type.name || &#39;Unknown&#39; : type;\n\n      if (key) &#123;\n        defineKeyPropWarningGetter(props, displayName);\n      &#125;\n\n      if (ref) &#123;\n        defineRefPropWarningGetter(props, displayName);\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n&#125;\n\n参数说明：\n  type:用于标识节点的类型，它可以是HTML标签字符串，也可以是React组件类型\n\n  config: 以对象形式传入，组件所有的属性都会以键值对的形式存储在config对象中\n\n  children: 以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的”子节点””子元素”\n\n\n例子DOM结构\n&lt;ul className&#x3D;&quot;list&quot; id&#x3D;&quot;lis&quot;&gt;\n  &lt;li key&#x3D;&#123;1&#125;&gt;&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&#123;2&#125;&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact.createElement语法糖\nReact.createElement(&quot;ul&quot;, &#123;\n  &#x2F;&#x2F; 传入属性键值对\n  className: &quot;list&quot;,\n  id: &quot;lis&quot;\n  &#x2F;&#x2F; 从第三个入参开始往后，传入的参数都是children\n&#125;, React.createElement(&quot;li&quot;, &#123;\n  key: 1\n&#125;), React, createElement(&quot;li&quot;, &#123;\n  key: 2\n&#125;))\n\n流程\n 处理key、ref、self、source四个属性值\n\n 遍历config，筛选出可以提进props里的属性\n\n 提取子元素，推入props.children\n\n 格式化defaultProps\n\n 将以上数据作为入参，发起ReactElement调用\n\n\n总结createElement就像是开发者和ReactElement调用之间的一个“转换器”，在开发者出接收相对简单的参数，然年后将这些参数按照ReactElement的预期做一层格式化，最终通过调用ReactElement来实现元素的创建\nReactElement解析var ReactElement &#x3D; function (type, key, ref, self, source, owner, props) &#123;\n  var element &#x3D; &#123;\n    &#x2F;&#x2F; 用来标识该对象是一个ReactElement\n    $$typeof: REACT_ELEMENT_TYPE,\n    &#x2F;&#x2F; 内置属性赋值\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    &#x2F;&#x2F; 记录创建该元素的组件\n    _owner: owner\n  &#125;;\n\n  return element;\n&#125;;\n\nReactElement只做了一件事情，就是组装，把传入的参数按照一定的规范，组装进element对象里，并把它返回给React.createElement，最终React.createElement又把它交回到开发者手中\n\nrender初识function render(element, container, callback) &#123;\n  if (!isValidContainer(container)) &#123;\n    &#123;\n      throw Error( &quot;Target container is not a DOM element.&quot; );\n    &#125;\n  &#125;\n\n  &#123;\n    var isModernRoot &#x3D; isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer &#x3D;&#x3D;&#x3D; undefined;\n\n    if (isModernRoot) &#123;\n      error(&#39;You are calling ReactDOM.render() on a container that was previously &#39; + &#39;passed to ReactDOM.createRoot(). This is not supported. &#39; + &#39;Did you mean to call root.render(element)?&#39;);\n    &#125;\n  &#125;\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n&#125;\n\n参数说明\n  element:需要渲染的元素(ReactElement)\n\n  container:元素挂载的目标容器(一个真实DOM)\n\n  callback: 回调函数，可选参数，可以用来处理渲染结束后的逻辑\n\n\n总结\n","slug":"JSX如何变成DOM","date":"2022-02-27T09:46:50.000Z","categories_index":"React源码","tags_index":"React,源码","author_index":"LIYUNFU"},{"id":"bdee22d1805781f30b666804c7635df8","title":"flex布局","content":"flex容器属性改变主轴方向flex-directionflex-direction: row默认\nflex-direction: row-reverse\nflex-direction: column\nflex-direction: column-reverse\n换行flex-wrapflex-wrap: nowrap默认\nflex-wrap: wrap\nflex-wrap: wrap-reverse\n缩写flex-flow: [flex-direction] [flex-wrap]flex-flow: column wrap\n主轴对齐justify-contentjustify-content: flex-start默认\njustify-content: flex-end\njustify-content: space-around 平均分配  每个方块的margin-left+margin-right+width相等\njustify-content: space-between 两边没有空隙 中间空隙平均分配\njustify-content: space-evenly所有空隙平均分配\n交叉轴整体对齐align-content 必须要有折行属性才能生效  \nalign-content: stretch默认\n如果交叉轴上的宽度未设置则自动拉伸填满交叉轴\n\n\n\n若交叉轴上的宽度已经设置则效果和flex-start一样\n\n\n\n\nalign-content: flex-start\nalign-content: flex-end\nalign-content: center\n其他属性 space-around``space-between``space-evenly和主轴属性类似交叉轴每一行对齐 align-itemsalign-items: stretch默认align-items: flex-start\nalign-items: flex-end\nalign-items: center\nalign-items: baseline 内容以小写x为基线对齐\n内联与块的上下左右居中布局内联上下左右居中\n块级上下左右居中\n不定项居中布局\n均分列布局\n子项分组布局复杂模式 使用div嵌套\n简单方式 margin-right: auto\nflex子项属性扩展比例flex-grow一个子元素时\n默认值为0\n\n比例值大于等于1，沾满剩余所有空间\n\n比例值为0.5，占剩余空间的一半\n\n\n\n\n多个子元素时\n只有一个有flex-grow时\n\n\n\n两个都有flex-grow时\n\n\n\n当多个元素加起来小于1时，还有剩余空间\n\n\n收缩比例flex-shrink\n默认值为1，溢出部分完全收缩，小数按比例收缩\n\n\n默认情况当有两个及以上需要收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，默认情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-2/5*(200+300-400)=160\n\nbox2收缩后所占尺寸：300-3/5*(200+300-400)=240\n\n\n\n不同比例收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，比例情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-4/7*(200+300-400)=142\n\nbox2收缩后所占尺寸：300-3/7*(200+300-400)=257\n\n\n\n指定flex元素在主轴上的初始大小flex-basis\n当主轴方向是水平时，覆盖水平宽度\n\n当主轴方向是垂直时，覆盖垂直高度\n\n可选值：0% auto 200px 100%  0  \n\n\n\nflex-basis: auto默认值\nflex-basis: 0表示占据最小宽度，会竖起来\nflex缩写flex: 1\nflex: 0\nflex: auto\n改变某个子项的排序位置order\norder: 0当前位置保持不变\n\norder: -1向前排\n\norder: 1向后拍\n\n\n\n控制单独某一个元素交叉轴的布局align-self\n等高布局 内容填充两边也等高\n两列或三列布局  两边固定宽度 中间自适应\nSticky Footer布局 内容空页脚在最底部 内容满也在最底部\n溢出项布局\n\n","slug":"flex布局","date":"2022-02-12T13:46:33.000Z","categories_index":"","tags_index":"CSS,布局","author_index":"LIYUNFU"},{"id":"6436dbae418d43dcb9001fac6bd76e96","title":"布局中的尺寸与位置","content":"相对长度单位&emsp;&emsp;相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应。以下列出了常见相对单位。\n\n\n\n单位\n名称\n\n\n\nem\n在font-size中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小\n\n\nex\n字符“x”的高度\n\n\nch\n数字“0”的宽度\n\n\nrem\n根元素的字体大小\n\n\nlh\n元素的line-height\n\n\nvw\n视窗宽度的1%\n\n\nvh\n视窗高度的1%\n\n\nvmin\n视窗较小尺寸的1%\n\n\nvmax\n视图大尺寸的1%\n\n\nmargin-top传递的现象与解决方案现象：为子元素设置margin-top后，会把父元素一块带下来&lt;div class=\"box1\">\n  &lt;div class=\"box2\">&lt;/div>\n&lt;/div>\n\n.box1&#123;\n  width: 200px;\n  height: 200px;\n  background: pink;\n&#125;\n.box2&#123;\n  width: 100px;\n  height: 100px;\n  background: skyblue;\n  margin-top: 30px;\n&#125;\n\n\n解决方案1： 为父元素加边框\n解决方案2：格式化上下文BFC\n解决方案3：使用padding替代margin\n自适应盒模型的特性当子盒子不写宽度的时候，添加padding，margin，border等，向内缩\n\n标准盒模型和怪异盒模型\n标准盒模型content-box：width，height=content\n怪异盒模型border-box：width，height=content+padding+border\n\n常见清除浮动的方案clear属性 清除上下\nBFC 清除父组件塌陷\n空标签.clearfix::after{}.clearfix::after&#123;\n\tcontent:\"\";\n  clear:both;\n  display:block;\n&#125;\n\n浮动特性注意点\n只会影响后面的元素\n\n文本不会被浮动元素覆盖\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n浮动放不下，会自动换行\n\n\n定位相对定位position：ralative\n相对定位的元素是在文档中的正常位置偏移给定的值\n\n不影响其他元素布局\n\n相对于自身进行偏移\n\n\n绝对定位position：absolute\n脱离标准文档流，不占据空间\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n绝对定位元素相对于最近的非static祖先元素定位，当这样的祖先元素不存在时，则相对于可视区定位\n\n\n固定定位position：fixed粘性定位position：sticky\n粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位\n\n详解display属性display-outside外部值定义自身元素的外部表现，而不影响其内的子元素\n\nblock：表示块级盒子\ninline：表示内联盒子\n\ndisplay-inside内部值定义子元素布局的\n\ntable：带有内部表格布局的块级盒子\n\nflex：带有内部弹性布局的块级盒子\n\ngrid：带有内部网格布局的块级盒子\n\n\nglobal全局值\ninherit：继承父元素的display属性\n\ninitial：不管父元素怎么设定，恢复到浏览器最初时的display属性\n\nunset：unset混合了inherit和initial，如果父元素设值了，就用父元素的设定，如果父元素没有设值，就用浏览器的缺省设定\n\n\n书写模式与逻辑属性writing-mode书写模式\nhorizontal-tb：水平方向自上而下的书写方式\n\nvertical-lr：垂直方向自左而右的书写方式\n\nvertical-rl：垂直方向自右而左的书写方式\n\n\n\nBFC块级格式化上下文概念：\n可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何，都不会影响到外部\n\n触发条件：\nfloat的值不是none\n\nposition的值不是static或relative\n\ndisplay的值是inline-block、table-cel、flex、table-caption或inline-flex\n\noverflow的值不是visible\n\n\nBFC的应用：\n解决margin-top传递问题   在父元素上加\n\n解决纵向margin重叠问题\n\n\n\n\n\n解决浮动高度塌陷  在父元素上加\n\n\n","slug":"布局中的尺寸与位置","date":"2022-02-11T13:28:00.000Z","categories_index":"","tags_index":"布局,css","author_index":"LIYUNFU"},{"id":"72f191bcb7ec59bd5f1454660b2b3dff","title":"西瓜音乐小程序开发第二天","content":"✅ 引入第三方 UI 库 vant✅ 封装 banner 请求✅ 实时获取组件高度解决不同屏幕中的 swiper 样式问题✅ 使用节流函数优化性能\n\n今日完成效果\n\n\n\\\n引入 vantUI 库步骤如下\n 第一步进入微信开发工具，点开详情，勾选使用 npm 模块，并调低基础库，由于当前测试基础库2.22.0无法正常显示 vant 中的van-search标签，遂调低基础库至2.21.2\n\n\n\n 打开终端，初始化package.json并且安装 vant 依赖 npm i @vant/weapp\n\n\n\n\\\n\n 点击工具菜单中的构建 npm，等待构建完成，自动产生miniprogram_npm这就是小程序依赖的包\n\n\n\n\n 最后删除 app.json 中的style:v2防止样式冲突\n\n使用第三方 UI 库\n 在pages/home-music/index.json中导入需要的search组件\n\n&#123;\n  &quot;usingComponents&quot;: &#123;\n    &quot;van-search&quot;: &quot;@vant&#x2F;weapp&#x2F;search&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 在pages/home-music/index.wxml中使用search组件\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n\n这里使搜索框无法输入，绑定了点击方法，使用户点击搜索框跳转到搜索页面，index.js 中实现方法即可，shape属性可以设置为圆角或者方角\n\n&#x2F;**\n  * 事件处理\n  *&#x2F;\n handleSearchClick: function () &#123;\n   wx.navigateTo(&#123;\n     url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n   &#125;);\n &#125;,\n\n\n效果如图\n\n\n\\\n封装 banner 请求新建 service/api_music.jsimport hyRequest from &quot;.&#x2F;index&quot;;\nexport function getBanners() &#123;\n  return hyRequest.get(&quot;&#x2F;banner&quot;, &#123;\n    type: 2,\n  &#125;);\n&#125;\n\n\ntype 的值有四种：0 代表 PC 1 代表 Android 2 代表 Iphone 3 代表 pad\n\n\\\n请求数据并渲染到页面\n 根据官方文档可知，可以通过以下示例获得每次渲染完成的组件的rect\n\n\n\n 新建utils/query-rect.js用以获取组件高度\n\nexport default function (selector) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 获取图片的高度(如何获取组件高度)\n    const query &#x3D; wx.createSelectorQuery();\n    query.select(selector).boundingClientRect();\n    query.exec((res) &#x3D;&gt; &#123;\n      resolve(res);\n    &#125;);\n  &#125;);\n&#125;\n\n\n 在pages/home-music/index.js中定义数据和方法，并调用\n\n&#x2F;&#x2F; pages&#x2F;home-music&#x2F;index.js\nimport &#123; getBanners &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_music&quot;;\nimport queryRect from &quot;..&#x2F;..&#x2F;utils&#x2F;query-rect&quot;;\nimport throttle from &quot;..&#x2F;..&#x2F;utils&#x2F;throttle&quot;;\n\nconst throttleQueryRect &#x3D; throttle(queryRect);\n\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    swiperHeight: 0,\n    banners: &#123;&#125;,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getPageData();\n  &#125;,\n\n  &#x2F;**\n   * 事件处理\n   *&#x2F;\n  handleSearchClick: function () &#123;\n    wx.navigateTo(&#123;\n      url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 网络请求\n   *&#x2F;\n  getPageData: function () &#123;\n    getBanners().then((res) &#x3D;&gt; &#123;\n      this.setData(&#123; banners: res.banners &#125;);\n    &#125;);\n  &#125;,\n\n  handleSwiperImageLoaded: function () &#123;\n    &#x2F;&#x2F; 获取图片的高度\n    throttleQueryRect(&quot;#swiper-img&quot;).then((res) &#x3D;&gt; &#123;\n      const rect &#x3D; res[0];\n      this.setData(&#123;\n        swiperHeight: rect.height,\n      &#125;);\n    &#125;);\n  &#125;,\n&#125;)\n\n\n 在pages/home-music/index.wxml中调用数据，并绑定image加载完成的方法bindonload\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n&lt;!-- 轮播图 --&gt;\n&lt;swiper class&#x3D;&quot;swiper&quot; style&#x3D;&quot;height:&#123;&#123;swiperHeight&#125;&#125;&quot; indicator-dots autoplay circular&gt;\n  &lt;block wx:for&#x3D;&quot;&#123;&#123;banners&#125;&#125;&quot; wx:key&#x3D;&quot;bannerId&quot;&gt;\n    &lt;swiper-item class&#x3D;&quot;swiper-item&quot; &gt;\n      &lt;image id&#x3D;&quot;swiper-img&quot; class&#x3D;&quot;image&quot; mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#123;&#123;item.pic&#125;&#125;&quot;  bindload&#x3D;&quot;handleSwiperImageLoaded&quot; &#x2F;&gt;\n    &lt;&#x2F;swiper-item&gt;\n  &lt;&#x2F;block&gt;\n&lt;&#x2F;swiper&gt;\n\n参数说明:\n\ncircular无限滑动\nmode高度自适应\n\n\n\n\nbindload当image标签加载完成时执行\nindicator-dots显示小圆点\n\n上面用到的节流函数utils/throttle.js\nexport default function throttle(\n  fn,\n  interval &#x3D; 1000,\n  options &#x3D; &#123; leading: true, trailing: false &#125;\n) &#123;\n  &#x2F;&#x2F; 1.记录上一次的开始时间\n  const &#123; leading, trailing, resultCallback &#125; &#x3D; options;\n  let lastTime &#x3D; 0;\n  let timer &#x3D; null;\n\n  &#x2F;&#x2F; 2.事件触发时, 真正执行的函数\n  const _throttle &#x3D; function (...args) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 2.1.获取当前事件触发时的时间\n      const nowTime &#x3D; new Date().getTime();\n      if (!lastTime &amp;&amp; !leading) lastTime &#x3D; nowTime;\n\n      &#x2F;&#x2F; 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数\n      const remainTime &#x3D; interval - (nowTime - lastTime);\n      if (remainTime &lt;&#x3D; 0) &#123;\n        if (timer) &#123;\n          clearTimeout(timer);\n          timer &#x3D; null;\n        &#125;\n\n        &#x2F;&#x2F; 2.3.真正触发函数\n        const result &#x3D; fn.apply(this, args);\n        if (resultCallback) resultCallback(result);\n        resolve(result);\n        &#x2F;&#x2F; 2.4.保留上次触发的时间\n        lastTime &#x3D; nowTime;\n        return;\n      &#125;\n\n      if (trailing &amp;&amp; !timer) &#123;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n          timer &#x3D; null;\n          lastTime &#x3D; !leading ? 0 : new Date().getTime();\n          const result &#x3D; fn.apply(this, args);\n          if (resultCallback) resultCallback(result);\n          resolve(result);\n        &#125;, remainTime);\n      &#125;\n    &#125;);\n  &#125;;\n\n  _throttle.cancel &#x3D; function () &#123;\n    if (timer) clearTimeout(timer);\n    timer &#x3D; null;\n    lastTime &#x3D; 0;\n  &#125;;\n\n  return _throttle;\n&#125;\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第二天","date":"2022-02-10T07:54:45.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"},{"id":"27fc989783c0d00e7c3b706a3747978d","title":"西瓜音乐小程序开发第一天","content":"\n✅ 初始化项目\n✅ 配置 tabbar\n✅ 封装请求函数\n✅ 分层架构二次封装请求函数\n✅ 封装格式化方法 (utils/format.wxs)\n✅ 封装视频列表 item 组件\n✅ 完成视频列表页展示\n今日完成效果如下\n\n\n\\\n初始化项目\n\n\\\n删除无关项目文件\n删除 pages 目录下的 index 和 logs，删除 utils 目录下的 util.js\n初始化 app.js 为\n\n&#x2F;&#x2F; app.js\nApp(&#123;\n\n&#125;)\n\n\n初始化 app.json 为\n\n&#123;\n  &quot;pages&quot;: [\n\n  ],\n  &quot;window&quot;: &#123;\n    &quot;backgroundTextStyle&quot;: &quot;light&quot;,\n    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,\n    &quot;navigationBarTitleText&quot;: &quot;Weixin&quot;,\n    &quot;navigationBarTextStyle&quot;: &quot;black&quot;\n  &#125;,\n  &quot;style&quot;: &quot;v2&quot;,\n  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,\n  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;\n&#125;\n\n\n初始化 app.wxss 为\n\n&#x2F;**app.wxss**&#x2F;\n\n\n目前为止编译器/模拟器会报错\n\n\n\\\n配置 tabbar新建两个页面\n 在 pages 右键创建文件夹home-music和home-video\n 在home-video和home-music上右键新建page为index\n\n\n\n\n 小程序开发工具会自动在目录下创建四个文件，并自动在app.json中添加 url\n \n\n\n\n\n \n\n导入静态资源 assets\n 在文件管理器中打开项目，复制已经准备好的 assets 资源到根目录\n \n\n\\\n在app.json中配置 tabbar&quot;tabBar&quot;: &#123;\n    &quot;list&quot;: [\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-music&#x2F;index&quot;,\n        &quot;text&quot;: &quot;音乐&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_active.png&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-video&#x2F;index&quot;,\n        &quot;text&quot;: &quot;视频&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_active.png&quot;\n      &#125;\n    ]\n  &#125;,\n\n\n\n效果\n\n\n\\\n封装请求函数由于微信小程序给我们提供的wx.request请求许多参数都可以复用，所以可以封装一个请求函数\n\n 在根目录下新建service文件夹\n 新建service/index.js\n\nconst BASE_URL &#x3D; &quot;http:&#x2F;&#x2F;123.207.32.32:9001&quot;;\nclass HYRequest &#123;\n  request(url, method, params) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      wx.request(&#123;\n        url: BASE_URL + url,\n        method: method,\n        data: params,\n        success: function (res) &#123;\n          resolve(res.data);\n        &#125;,\n        fail: function (err) &#123;\n          reject(err);\n        &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  get(url, params) &#123;\n    return this.request(url, &quot;GET&quot;, params);\n  &#125;\n  post(url, data) &#123;\n    return this.request(url, &quot;POST&quot;, data);\n  &#125;\n&#125;\n\nconst hyRequest &#x3D; new HYRequest();\nexport default hyRequest;\n\n二次封装请求函数某些动作需要反复调用请求函数，但是有不变的参数，没必要每次传递，可以再封装一次\n\n 新建service/api_video.js\n\nimport hyRequest from &#39;.&#x2F;index&#39;\nexport function getTopMV(offset,limit&#x3D;10)&#123;\n  return hyRequest.get(&#39;&#x2F;top&#x2F;mv&#39;,&#123;\n    offset,\n    limit\n  &#125;)\n&#125;\n\n\n 由于我们的 api 后台需要接收两个参数，一个是偏移量，一个是数量，我们默认每次截取十个即可\n\n调用请求获得数据\n 在home-video/index.js中引入 getTopMV 方法\n\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\n\n\n 在home-video/index.js的 data 中定义两个变量\n\ndata: &#123;\n   topMVs: [],   &#x2F;&#x2F;用以保存请求到的数据列表\n   hasMore: true,  &#x2F;&#x2F; 判断还有没有更多数据能够请求\n &#125;,\n\n\n 封装专属于home-video的网络请求方法，用以在不同操作下复用\n\n&#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n\n 当生命周期 onLoad 执行时，调用请求方法\n\n&#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n\n 当下拉刷新时调用请求方法\n\n&#x2F;**\n  * 下拉刷新\n  *&#x2F;\n onPullDownRefresh: function () &#123;\n   this.getTopMVData(0);\n &#125;,\n\n\n 当页面触底时调用请求方法\n\n&#x2F;**\n * 页面上拉触底事件的处理函数\n *&#x2F;\nonReachBottom: function () &#123;\n  this.getTopMVData(this.data.topMVs.length);\n&#125;,\n\n\n home-video/index.js完整代码\n\n&#x2F;&#x2F; pages&#x2F;home-video&#x2F;index.js\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    topMVs: [],\n    hasMore: true,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n  &#x2F;**\n   * 封装事件处理的方法\n   *&#x2F;\n  handleVideoItemClick: function (event) &#123;\n    const id &#x3D; event.currentTarget.dataset.item.id;\n\n    &#x2F;&#x2F; 页面跳转\n    wx.navigateTo(&#123;\n      url: &#96;&#x2F;pages&#x2F;detail-video&#x2F;index?id&#x3D;$&#123;id&#125;&#96;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 下拉刷新\n   *&#x2F;\n  onPullDownRefresh: function () &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面初次渲染完成\n   *&#x2F;\n  onReady: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面显示\n   *&#x2F;\n  onShow: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面隐藏\n   *&#x2F;\n  onHide: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面卸载\n   *&#x2F;\n  onUnload: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面相关事件处理函数--监听用户下拉动作\n   *&#x2F;\n  onPullDownRefresh: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面上拉触底事件的处理函数\n   *&#x2F;\n  onReachBottom: function () &#123;\n    this.getTopMVData(this.data.topMVs.length);\n  &#125;,\n\n  &#x2F;**\n   * 用户点击右上角分享\n   *&#x2F;\n  onShareAppMessage: function () &#123;&#125;,\n&#125;);\n\n遍历数据到页面前面我们已经请求到数据了，可以直接在home-video/index.wxml中调用，由于列表的 item 也可以复用，我们将它封装成一个 component\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;!-- &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt; --&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\\\n封装 item 组件\n 在根目录下新建文件夹components/video-item-v1，右键video-item-v1新建component为 index\n \n\n\n\n\n 可以看到component的 index.js 和普通组件不同，其中有一个专门接收父组件传递过来数据的函数\n\n&#x2F;**\n  * 组件的属性列表\n  *&#x2F;\n properties: &#123;\n\n &#125;,\n\n\n 可以在这儿定义接收的数据，就可以直接在 wxml 页面中使用了\n\n&#x2F;**\n   * 组件的属性列表\n   *&#x2F;\n  properties: &#123;\n    item:&#123;\n      type:Object,\n      default:&#123;&#125;\n    &#125;\n  &#125;,\n\n\n 由于服务器返回的数据里面播放量和 时间都需要转换格式，我们可以在 utils 目录下定义一个format.wxs用于格式化数据，wxml 中只能调用 wxs 定义的方法\n\nfunction formatCount(count) &#123;\n  var counter &#x3D; parseInt(count);\n  if (counter &gt; 100000000) &#123;\n    return (counter &#x2F; 100000000).toFixed(1) + &quot;亿&quot;;\n  &#125; else if (counter &gt; 10000) &#123;\n    return (counter &#x2F; 10000).toFixed(1) + &quot;万&quot;;\n  &#125; else &#123;\n    return counter + &quot;&quot;;\n  &#125;\n&#125;\n\nfunction padLeftZero(time) &#123;\n  time &#x3D; time + &quot;&quot;;\n  return (&quot;00&quot; + time).slice(time.length);\n&#125;\nfunction formatDuration(duration) &#123;\n  duration &#x3D; duration &#x2F; 1000;\n\n  var minute &#x3D; Math.floor(duration &#x2F; 60);\n  &#x2F;&#x2F; 计算秒钟\n  var second &#x3D; duration % 60;\n\n  return padLeftZero(minute) + &quot;:&quot; + padLeftZero(second);\n&#125;\n&#x2F;&#x2F; commonjs\nmodule.exports &#x3D; &#123;\n  formatCount: formatCount,\n  formatDuration: formatDuration,\n&#125;;\n\n\n 现在我们可以在 wxml 中使用父组件传递过来的数据了\n\n&lt;!--components&#x2F;video-item-v1&#x2F;index.wxml--&gt;\n&lt;wxs src&#x3D;&quot;..&#x2F;..&#x2F;utils&#x2F;format.wxs&quot; module&#x3D;&quot;format&quot;&gt;&lt;&#x2F;wxs&gt;\n&lt;view class&#x3D;&quot;item&quot;&gt;\n  &lt;view class&#x3D;&quot;album&quot;&gt;\n    &lt;image class&#x3D;&quot;images&quot; src&#x3D;&quot;&#123;&#123;item.cover&#125;&#125;&quot; mode&#x3D;&quot;widthFix&quot; &#x2F;&gt;\n    &lt;view class&#x3D;&quot;info&quot;&gt;\n      &lt;view class&#x3D;&quot;count&quot;&gt;&#123;&#123;format.formatCount(item.playCount)&#125;&#125;&lt;&#x2F;view&gt;\n      &lt;view class&#x3D;&quot;duration&quot;&gt;&#123;&#123;format.formatDuration(item.mv.videos[0].duration)&#125;&#125;&lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class&#x3D;&quot;content&quot;&gt;\n    &#123;&#123;item.name&#125;&#125; - &#123;&#123;item.artisName&#125;&#125;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\n 为 item 组件配置样式\n\n&#x2F;* components&#x2F;video-item-v1&#x2F;index.wxss *&#x2F;\n.item &#123;\n  width: 100%;\n  margin-bottom: 30rpx;\n&#125;\n\n.album &#123;\n  position: relative;\n  border-radius: 12rpx;\n  overflow: hidden;\n  display: flex;\n&#125;\n\n.album .image &#123;\n  width: 100%;\n&#125;\n\n.info &#123;\n  position: absolute;\n  padding: 0 10rpx;\n  box-sizing: border-box;\n  width: 100%;\n  bottom: 8rpx;\n  display: flex;\n  justify-content: space-between;\n  color: #fff;\n  font-size: 24rpx;\n&#125;\n\n.info .count &#123;\n  padding-left: 36rpx;\n  position: relative;\n&#125;\n\n.info .count::before &#123;\n  content: &quot;&quot;;\n  position: absolute;\n  left: -2rpx;\n  top: 4rpx;\n  width: 30rpx;\n  height: 24rpx;\n  background-size: cover;\n  background-image: url(&quot;data:image&#x2F;jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAYCAQAAABHYIU0AAAM82lDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY0dyYXlHYW1tYTJfMgAAWIWlVwdYU8kWnluS0BJ6lRI60gwoXUqkBpBeBFGJIZBACDEFAbEhiyu4dhHBsqKiKIsdgcWGBQtrB7sLuigo6+IqNixvEopYdt&#x2F;7vnfzzb3&#x2F;nXPOnDpnbgBQ5TAFAh4KAMjki4WBUfSEKQmJVNJdIAe0gTKwB8pMlkhAj4gIhSyAn8Vng2+uV+0AkT6v2UnX+pb+rxchhS1iwedxOHJTRKxMAJCJAJC6WQKhGAB5MzhvOlsskOIgiDUyYqJ8IU4CQE5pSFZ6GQWy+Wwhl0UNFDJzqYHMzEwm1dHekRohzErl8r5j9f97ZfIkI7rhUBJlRIfApz20vzCF6SfFrhDvZzH9o4fwk2xuXBjEPgCgJgLxpCiIgyGeKcmIpUNsC3FNqjAgFmIviG9yJEFSPAEATCuPExMPsSHEwfyZYeEQu0PMYYl8EyG2griSw2ZI8wRjhp3nihkxEEN92DNhVpSU3xoAfGIK289&#x2F;cB5PzcgKkdpgAvFBUXa0&#x2F;7DNeRzfsEFdeHs6MzgCYguIX7J5gVGD6xD0BOII6ZrwneDH54WFDvpFKGWLZP7Cd0K7mBMjzZkjAEQTsTAmatA2YkwqN4ABcQDEORxhUNSgv8SjAp6szmBMiO+FkqjYQR9JAWx+rHRNaV0sYAr9AwdjRWoCcQgTsEEWmAnvLMAHnYAKRIALsmUoDTBBJhxUaIEtHIGQiw+HEHKIQIaMQwi6RujDElIZAaRkgVTIyYNyw7NUkALlB+Wka2TBIX2Trtstm2MN6bOHw9dwO5DANw7ohXQORJNBh2wmB9qXCZ++cFYCaWkQj9YyKB8hs3XQBuqQ9T1DWrJktjBH5D7b5gvpfJAHZ0TDnuHaOA0fD4cHHop74jSZlBBy5AI72fxE2dyw1s+eS33rGdE6C9o62vvR8RqO4QkoJYbvPOghfyg+ImjNeyiTMST9lZ8r9CRWAkHpskjG9KoRK6gFwhlc1qXlff+StW+1232Rt&#x2F;DRdSGrlJRv6gLqIlwlXCbcJ1wHVPj8g9BG6IboDuEu&#x2F;N36blSyRmKQBkfWSAWwv8gNG3LyZFq+tfNzzgbX+WoFBBvhpMtWkVIz4eDKeEQj+ZNALIb3VJm03Ve5C&#x2F;xab0t+kw6gti89fg5Qa1Qazn6Odhten3RNqSU&#x2F;lb9CTyCYXpU&#x2F;wBZ8pkrzwF4c9ioMFNjS9tJ6adtoNbQXtPufOWg3aH&#x2F;S2mhbIOUptho7hB3BGrBGrBVQ4VsjdgJrkKEarAn+9v1Dhad9p8KlFcMaqmgpVTxUU6Nrf3Rk6aOiJeUfjnD6P9Tr6IqRZux&#x2F;s2j0Ol92BPbnXUcxpThQSBRrihOFTkEoxvDnSPGByJRiQgmlaENqEMWS4kcZMxKP4VrnDWWY+8X+HrQ4AVKHK4Ev6y5MyCnlYA75+7WP1C+8lHrGHb2rEDLcVdxRPeF7vYj6xc6KhbJcMFsmL5Ltdr5MTvBF&#x2F;YlkXQjOIFNlOfyObbgh7oAzYAcKB1ScjjvhPkN4sCsN9yVZpnBvSPXC&#x2F;XBXaR&#x2F;7oi+w&#x2F;qv1o3cGm+hOtCT6Ey0&#x2F;04l+xCBiAHw6SOeJ44jBELtJucTsHLH0kPfNEuQKuWkcMZUOv3LYVAafZW9LdaQ5wNNN+s00+CnwIlL2LYRotbIkwuzBOVx6IwAF+D2lAXThqWoKT2s7qNUFeMAz0x+ed+EgBuZ1OvSDA+0Wwsjmg4WgCJSAFWAtKAebwTZQDWrBfnAYNMEeewZcAJdBG7gDz5Mu8BT0gVdgAEEQEkJG1BFdxAgxR2wQR8QV8UL8kVAkCklAkpE0hI9IkHxkEVKCrELKkS1INbIPaUBOIOeQK8gtpBPpQf5G3qEYqoRqoAaoBToOdUXpaAgag05D09BZaB5aiC5Dy9BKtAatQ0+gF9A2tAN9ivZjAFPEtDBjzA5zxXyxcCwRS8WE2DysGCvFKrFa2ANasGtYB9aLvcWJuDpOxe1gFoPwWJyFz8Ln4UvxcnwnXoefwq&#x2F;hnXgf&#x2F;pFAJugTbAjuBAZhCiGNMJtQRCglVBEOEU7DDt1FeEUkErVgflxg3hKI6cQ5xKXEjcQ9xOPEK8SHxH4SiaRLsiF5ksJJTJKYVERaT6ohHSNdJXWR3sgpyhnJOcoFyCXK8eUK5Erldskdlbsq91huQF5F3lzeXT5cPkU+V365&#x2F;Db5RvlL8l3yAwqqCpYKngoxCukKCxXKFGoVTivcVXihqKhoouimGKnIVVygWKa4V&#x2F;GsYqfiWyU1JWslX6UkJYnSMqUdSseVbim9IJPJFmQfciJZTF5GriafJN8nv6GoU+wpDEoKZT6lglJHuUp5piyvbK5MV56unKdcqnxA+ZJyr4q8ioWKrwpTZZ5KhUqDyg2VflV1VQfVcNVM1aWqu1TPqXarkdQs1PzVUtQK1baqnVR7qI6pm6r7qrPUF6lvUz+t3qVB1LDUYGika5Ro&#x2F;KJxUaNPU01zgmacZo5mheYRzQ4tTMtCi6HF01qutV+rXeudtoE2XZutvUS7Vvuq9mudMTo+OmydYp09Om0673Spuv66GbordQ&#x2F;r3tPD9az1IvVm623SO63XO0ZjjMcY1pjiMfvH3NZH9a31o&#x2F;Tn6G&#x2F;Vb9XvNzA0CDQQGKw3OGnQa6hl6GOYbrjG8Khhj5G6kZcR12iN0TGjJ1RNKp3Ko5ZRT1H7jPWNg4wlxluMLxoPmFiaxJoUmOwxuWeqYOpqmmq6xrTZtM&#x2F;MyGyyWb7ZbrPb5vLmruYc83XmLeavLSwt4i0WWxy26LbUsWRY5lnutrxrRbbytpplVWl1fSxxrOvYjLEbx162Rq2drDnWFdaXbFAbZxuuzUabK7YEWzdbvm2l7Q07JTu6XbbdbrtOey37UPsC+8P2z8aZjUsct3Jcy7iPNCcaD55udxzUHIIdChwaHf52tHZkOVY4Xh9PHh8wfv74+vHPJ9hMYE&#x2F;YNOGmk7rTZKfFTs1OH5xdnIXOtc49LmYuyS4bXG64arhGuC51PetGcJvkNt+tye2tu7O72H2&#x2F;+18edh4ZHrs8uidaTmRP3DbxoaeJJ9Nzi2eHF9Ur2etnrw5vY2+md6X3Ax9TnxSfKp&#x2F;H9LH0dHoN&#x2F;dkk2iThpEOTXvu6+871Pe6H+QX6Fftd9Ffzj&#x2F;Uv978fYBKQFrA7oC&#x2F;QKXBO4PEgQlBI0MqgGwwDBotRzegLdgmeG3wqRCkkOqQ85EGodagwtHEyOjl48urJd8PMw&#x2F;hhh8NBOCN8dfi9CMuIWRG&#x2F;RhIjIyIrIh9FOUTlR7VEq0fPiN4V&#x2F;SpmUszymDuxVrGS2OY45bikuOq41&#x2F;F+8aviO6aMmzJ3yoUEvQRuQn0iKTEusSqxf6r&#x2F;1LVTu5KckoqS2qdZTsuZdm663nTe9CMzlGcwZxxIJiTHJ+9Kfs8MZ1Yy+2cyZm6Y2cfyZa1jPU3xSVmT0sP2ZK9iP071TF2V2p3mmbY6rYfjzSnl9HJ9ueXc5+lB6ZvTX2eEZ+zI+MSL5+3JlMtMzmzgq&#x2F;Ez+KeyDLNysq4IbARFgo5Z7rPWzuoThgirRIhomqherAH&#x2F;YLZKrCQ&#x2F;SDqzvbIrst&#x2F;Mjpt9IEc1h5&#x2F;TmmuduyT3cV5A3vY5+BzWnOZ84&#x2F;yF+Z1z6XO3zEPmzZzXPN90fuH8rgWBC3YuVFiYsfC3AlrBqoKXi+IXNRYaFC4ofPhD4A+7iyhFwqIbiz0Wb&#x2F;4R&#x2F;5H748Ul45esX&#x2F;KxOKX4fAmtpLTk&#x2F;VLW0vM&#x2F;OfxU9tOnZanLLi53Xr5pBXEFf0X7Su+VO1eprspb9XD15NV1a6hrite8XDtj7bnSCaWb1ymsk6zrKAstq19vtn7F+vflnPK2ikkVezbob1iy4fXGlI1XN&#x2F;lsqt1ssLlk87ufuT&#x2F;f3BK4pa7SorJ0K3Fr9tZH2+K2tWx33V5dpVdVUvVhB39Hx86onaeqXaqrd+nvWr4b3S3Z3VOTVHP5F79f6mvtarfs0dpTshfslex9si95X&#x2F;v+kP3NB1wP1B40P7jhkPqh4jqkLreu7zDncEd9Qv2VhuCG5kaPxkO&#x2F;2v+6o8m4qeKI5pHlRxWOFh79dCzvWP9xwfHeE2knHjbPaL5zcsrJ66ciT108HXL67JmAMydb6C3HznqebTrnfq7hvOv5wxecL9S1OrUe+s3pt0MXnS&#x2F;WXXK5VH&#x2F;Z7XLjlYlXjl71vnrimt+1M9cZ1y+0hbVdaY9tv3kj6UbHzZSb3bd4t57fzr49cGcB&#x2F;Igvvqdyr&#x2F;S+&#x2F;v3K38f+vqfDueNIp19n64PoB3cesh4+&#x2F;UP0x&#x2F;uuwkfkR6WPjR5Xdzt2N&#x2F;UE9Fx+MvVJ11PB04Heoj9V&#x2F;9zwzOrZwb98&#x2F;mrtm9LX9Vz4&#x2F;NPfS1&#x2F;ovtjxcsLL5v6I&#x2F;vuvMl8NvC5+o&#x2F;tm51vXty3v4t89Hpj9nvS+7MPYD40fQz7e&#x2F;ZT56dN&#x2F;AC1d8BzqtvWAAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAAeoAMABAAAAAEAAAAYAAAAAGbJ4J8AAAElSURBVDgRnZQxTsNAEEX&#x2F;WFGUC6RDEEGFREkPihEVokoVDkDFAWgISsUZuAIFQjQUFE5Ni1NEhEjQxQegy2fsFPHKu&#x2F;Zutpr5&#x2F;u&#x2F;vFOsBwDNOVhkDjroTxlA0DqBMayxMcMJfGeEH1CyfI9jlWHYwAZcaN&#x2F;Rhyh5eKbWM0FXxu&#x2F;zBq56rqxsVVt+BN7kFsYY3YlDlgPnIJx40JTlgHGOAT96zUxfggnOmgxFSXrjxOjin9vHKF&#x2F;bsAU1wTl1iynMb7gPrG8ZqW&#x2F;gZh&#x2F;Jug1s2saR94UbeSr1R1o39hzscuVHAdfMHZriVhXFRpXHAcl1xWoS6sS12U1rDYooeXUFEyNTa+AtU4nIiayHFKR&#x2F;YDlpDexgrnIJ9c6sFdH0N0P2ZbLd6&#x2F;wF85hyuQTMxjwAAAABJRU5ErkJggg&#x3D;&#x3D;&quot;);\n&#125;\n\n.content &#123;\n  margin-top: 10rpx;\n  font-size: 28rpx;\n\n  &#x2F;* 显示两行 *&#x2F;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  display: -moz-box;\n  -moz-line-clamp: 2;\n  -moz-box-orient: vertical;\n  word-wrap: break-word;\n  word-break: break-all;\n  white-space: normal;\n  overflow: hidden;\n&#125;\n\n父组件引入子组件\n 在home-video/index.json中引入子组件\n\n&#123;\n  &quot;enablePullDownRefresh&quot;: true,\n  &quot;backgroundTextStyle&quot;: &quot;dark&quot;,\n  &quot;usingComponents&quot;: &#123;\n    &quot;video-item-v1&quot;: &quot;&#x2F;components&#x2F;video-item-v1&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 改写home-video/index.wxml使用组件\n\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n父组件传值就是通过data-item传递的\n\n\\\n\n 最后我们还需要修改home-video/index.wxss\n\n&#x2F;* pages&#x2F;home-video&#x2F;index.wxss *&#x2F;\n.video &#123;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n&#125;\n\n.item &#123;\n  width: 48%;\n&#125;\n\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第一天","date":"2022-02-10T07:50:55.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"}]