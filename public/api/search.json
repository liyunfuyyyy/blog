[{"id":"deb07f2084ce5c6636760b3189f1eaa0","title":"git命令备忘录","content":"\ngit init 初始化版本库\ngit add 每次提交前都要添加\ngit commit -m “修改信息”  \ngit log 打印提交记录\ngit diff readme  查看版本区别\ngit reset 回到某个版本  git reset --hard  版本代号\ngit reflog 打印操作记录 再使用git reset 版本号可以到未来\n工作区的文件git add之后到了暂存区，暂存区git commit一次性提交到master分支\ngit diff HEAD -- readme.txt 查看工作区和版本库里面最新版本的区别\ngit checkout -- readme.txt 丢弃工作区的修改，从暂存区恢复\ngit reset HEAD readme.txt暂存区回到上一个版本\ngit remote add origin git@github.com:michaelliao/learngit.git 关联远程仓库\ngit push -u origin master第一次推送\ngit push origin master以后推送\ngit remote -v查看远程仓库\ngit remote rm origin解除远程仓库\ngit switch -c dev创建并切换到新的dev分支\ngit switch master切换到master分支\ngit branch查看分支\ngit branch -d dev删除分支\ngit merge dev将dev分支合并到当前分支上\ngit merge --no-ff -m &quot;merge with no-ff&quot; dev合并分支并禁用快速合并\ngit stash把当前工作现场储存下来，方便下一次恢复现场继续工作 \ngit stash pop恢复现场，并把stash内容删除\ngit cherry-pick &lt;commit&gt;  如果当前也有bug 就把原先的提交复制到这儿一份\n命令git push origin &lt;tagname&gt;可以推送一个本地标签；\n命令git push origin --tags可以推送全部未推送过的本地标签；\n命令git tag -d &lt;tagname&gt;可以删除一个本地标签；\n命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。\n\n","slug":"git命令备忘录","date":"2022-03-05T03:08:36.000Z","categories_index":"知识点","tags_index":"git,备忘录","author_index":"LIYUNFU"},{"id":"52748ea8c7aacb653b9bc3a082a7560f","title":"基于koa-generator搭建通用服务端","content":"安装koa-generator全局安装koa-generatornpm i koa-generator -g\n\n初始化项目koa2 goudong-server \n\n进入并安装依赖cd goudong-server \nnpm install\n\n\n\n改造项目环境\n在根目录下新建src目录\n\n将public 、routes 、views 、app.js拖入src目录\n\n修改bin/www中的var app = require(&#39;../app&#39;);为var app = require(&#39;../src/app&#39;);\n\n改造后目录\n\n```shell|- bin  |- www|-node_modules|-src  |-public  |-routes  |-views  |-app.js|-package.json\n\n- 在&#96;src&#96;目录下创建四个目录&#96;controller&#96; 、&#96;db&#96; 、&#96;middleware&#96;、&#96;models&#96;\n\n\n\n\n\n## 实现登录功能\n\n### 配置开发环境\n\n#### 安装&#96;koa-generic-session&#96;依赖\n\n&#96;&#96;&#96;shell\nni koa-generic-session \n\n使用const session = require('koa-generic-session')\n\n//session配置\napp.keys = ['liyunfuAAA'] //密钥用于加密\napp.use(session(&#123;\n  //配置cookie\n  cookie: &#123;\n    path: '/',\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000\n  &#125;\n&#125;))\n\n\n\n跨域安装koa2-cors依赖ni koa2-cors\n\n使用const cors = require('koa2-cors')\n\n//cors配置\napp.use(cors(&#123;\n  origin: 'http://localhost:8080',  //前端origin\n  credentials: true //允许跨域带cookie\n&#125;))\n\n连接数据库安装mongooseni mongoose\n\n在db目录下新建db.js/**\n * @description mongoose 连接数据库\n * @author liyunfu\n */\nconst mongoose = require('mongoose')\n\nconst DB_URL = 'mongodb://root:example@47.99.147.11.27017/jingdong?authSource=admin'\n\n// 开始连接\nmongoose.connect(DB_URL, &#123;\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n&#125;)\n\n// 连接对象\nconst db = mongoose.connection\n\ndb.on('error', err => &#123;\n  console.error('mongoose connect error', err)\n&#125;)\ndb.once('open', () => &#123;\n  console.log('mongoose 连接成功')\n&#125;)\n\nmodule.exports = mongoose\n\n\n\n设计Schema和Model\n在models目录下新建User.js\n/**\n * @description user Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true,\n    unique: true\n  &#125;,\n  password: String\n&#125;, &#123; timestamps: true &#125;)\n\nconst User = mongoose.model('user', Schema)\n\nmodule.exports = User\n在models下新建Address.js\n/**\n * @description Address Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  city: String,\n  department: String,\n  houseNumber: String,\n  name: String,\n  phone: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Address = mongoose.model('address', Schema)\n\nmodule.exports = Address\n在models下新建Shop.js\n/**\n * @description Shop Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  expressLimit: &#123;\n    type: Number,\n    default: 0\n  &#125;,\n  expressPrice: Number,\n  slogan: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Shop = mongoose.model('shop', Schema)\n\nmodule.exports = Shop\n在models下新建Product.js\n/**\n * @description Product Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  ShopId: &#123;\n    type: String,\n    require: true\n  &#125;,\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  price: Number,\n  oldPrice: Number,\n  tabs: [String]  //示例 tabs:['all','seckill']\n&#125;, &#123; timestamps: true &#125;)\n\nconst Product = mongoose.model('product', Schema)\n\nmodule.exports = Product\n在models下新建Order.js \n/**\n * @description Order Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  shopId: String,\n  shopName: String,\n\n  idCanceled: &#123;\n    type: Boolean,\n    default: false\n  &#125;,\n  address: &#123;\n    username: String,\n    city: String,\n    department: String,\n    houseNumber: String,\n    name: String,\n    phone: String\n  &#125;,\n  products: [\n    &#123;\n      product: &#123;\n        shopId: &#123;\n          type: String,\n          require: true\n        &#125;,\n        name: String,\n        imgUrl: String,\n        sales: Number,\n        price: Number,\n        oldPrice: Number,\n        tabs: [String]\n      &#125;,\n      orderSales: Number\n    &#125;\n  ]\n&#125;, &#123; timestamps: true &#125;)\n\nconst Order = mongoose.model('order', Schema)\n\nmodule.exports = Order\n在models 下新建index.js \n/**\n * @description Model 入口文件\n * @author liyunfu\n */\nconst Address = require('./Address')\nconst Order = require('./Order')\nconst Product = require('./Product')\nconst Shop = require('./Shop')\nconst User = require(\"./User\")\n\nmodule.exports = &#123;\n  Address,\n  Order,\n  Product,\n  Shop,\n  User\n&#125;\n\n标准化请求成功与失败的响应信息\n在res-model 下新建ErrorModel.js\n/**\n * @description 错误返回的数据结构\n * @author liyunfu\n */\n\nclass ErrorModel &#123;\n  constructor(errno = -1, message = 'error') &#123;\n    this.errno = errno\n    this.message = message\n  &#125;\n&#125;\n\nmodule.exports = ErrorModel\n在res-model 下新建SuccessModel.js\n/**\n * @description 成功返回的数据类型\n * @author liyunfu\n */\n\nclass SuccessModel &#123;\n  constructor(data) &#123;\n    this.errno = 0\n    if (data !== null) &#123;\n      this.data = data\n    &#125;\n  &#125;\n&#125;\n\nmodule.exports = SuccessModel\n在res-model 下新建入口文件index.js\n/**\n * @description 返回数据类型 入口文件\n * @author liyunfu\n */\nconst SuccessModel = require('./SuccessModel')\nconst ErrorModel = require('./ErrorModel')\n\nmodule.exports = &#123; SuccessModel, ErrorModel &#125;\n\n编写登录验证中间件\n在middleware 下新建loginCheck.js\n/**\n * @description 登录验证中间件\n * @author liyunfu\n */\n\nconst &#123; ErrorModel &#125; = require('../res-model/index')\n\nmodule.exports = async (ctx, next) => &#123;\n  const session = ctx.session\n\n  if (session &amp;&amp; session.userInfo) &#123;\n    await next()\n    return\n  &#125;\n  ctx.body = new ErrorModel(10003, '中间件登录验证失败')\n&#125;\n\n用户操作接口\n在controller 下新建 user.js\n/**\n * @description user controller\n * @author liyunfu\n */\n\nconst &#123; User &#125; = require('../models/index')\n\n/**\n * 注册方法\n * @param &#123;Object&#125; userInfo 用户信息\n * @returns \n */\nasync function register(userInfo = &#123;&#125;) &#123;\n  // 注意验证一下username unique\n  const newUser = await User.create(userInfo)\n  return newUser\n&#125;\n\nasync function login(username, password) &#123;\n  const user = await User.findOne(&#123; username, password &#125;)\n  if (user != null) &#123;\n    // 登录成功\n    return true\n  &#125;\n  return false\n&#125;\n\nmodule.exports = &#123;\n  register, login\n&#125;\n在routes 下新建users.js\nconst router = require('koa-router')()\n\n\nconst &#123; register, login &#125; = require('../controller/user')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user')\n\n// 注册\nrouter.post('/register', async function (ctx, next) &#123;\n  const userInfo = ctx.request.body\n  try &#123;\n    await register(userInfo)\n    // 返回成功\n    ctx.body = new SuccessModel()\n  &#125; catch (ex) &#123;\n    console.log(ex)\n    // 返回失败\n    ctx.body = new ErrorModel(10001, `注册失败 - $&#123;ex.message&#125;`)\n  &#125;\n&#125;)\n\n// 登录\nrouter.post('/login', async (ctx, next) => &#123;\n  const &#123; username, password &#125; = ctx.request.body\n  // 查询单个用户\n  const res = await login(username, password)\n\n  if (res) &#123;\n    // 登录成功\n    ctx.session.userInfo = &#123; username &#125;  //设置session\n\n    ctx.body = new SuccessModel()\n  &#125; else &#123;\n    ctx.body = new ErrorModel(10002, `登录验证失败`)\n  &#125;\n&#125;)\n\nrouter.get('/info', loginCheck, async function (ctx, next) &#123;\n  // 加了loginCheck之后，因为保证了必须登录\n  const session = ctx.session\n  ctx.body = new SuccessModel(session.userInfo)\n&#125;)\nmodule.exports = router\n\n地址操作接口\n在controller 下新建address.js\n/**\n * @description address controller\n * @author liyunfu\n */\n\nconst &#123; Address &#125; = require('../models/index')\n\n/**\n * 创建地址 \n * @param &#123;string&#125; username 用户名\n * @param &#123;Object&#125; data 地址的详细信息\n * @returns \n */\nasync function createAddress(username, data) &#123;\n  const address = await Address.create(&#123; username, ...data &#125;)\n\n  return address\n&#125;\n\n/**\n * 获取地址列表\n * @param &#123;string&#125; username 用户名\n * @returns \n */\nasync function getAddressList(username) &#123;\n  const list = await Address.find(&#123; username &#125;).sort(&#123; updatedAt: -1 &#125;)\n  return list\n&#125;\n\n/**\n * 获取单个收获地址\n * @param &#123;string&#125; id id\n * @returns \n */\nasync function getAddressById(id) &#123;\n  const address = await Address.findById(id)\n  return address\n&#125;\n\nasync function updateAddress(id, username, data) &#123;\n  const address = await Address.findOneAndUpdate(\n    &#123;\n      // 查询条件\n      _id: id,\n      username,\n    &#125;,\n    &#123;\n      username, ...data\n    &#125;,\n    &#123;\n      new: true  //返回更新之后的最新数据，默认时false，返回更新之前的数据\n    &#125;\n  )\n  return address\n&#125;\n\nmodule.exports = &#123;\n  createAddress,\n  getAddressList,\n  getAddressById,\n  updateAddress\n&#125;\n在routes 下新建address.js\n/**\n * @description address router\n * @author liyunfu\n */\n\nconst router = require('koa-router')()\nconst &#123; createAddress, getAddressList, getAddressById, updateAddress &#125; = require('../controller/address')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user/address')\n\n// 创建收货地址\nrouter.post('/', loginCheck, async (ctx, next) => &#123;\n  // 获取用户信息\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  const data = ctx.request.body\n\n  // 创建数据\n  try &#123;\n    const newAddress = await createAddress(username, data)\n    ctx.body = new SuccessModel(newAddress)\n  &#125; catch (error) &#123;\n    console.log(error)\n    ctx.body = new ErrorModel(10004, '创建收货地址失败')\n  &#125;\n&#125;)\n\n// 获取收货地址列表\nrouter.get('/', loginCheck, async (ctx, next) => &#123;\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 获取列表\n  const list = await getAddressList(username)\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 获取单个收获地址\nrouter.get('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const address = await getAddressById(id)\n\n  ctx.body = new SuccessModel(address)\n&#125;)\n\n// 更新收货地址\nrouter.patch('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const data = ctx.request.body\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  // 更新\n  const newAddress = await updateAddress(id, username, data)\n  ctx.body = new SuccessModel(newAddress)\n&#125;)\n\nmodule.exports = router\n\n商店商品接口\n在controller 下新建shop.js\n/**\n * @description shop controller\n * @author liyunfu\n */\n\nconst &#123; &#125; = require('../models/index')\n\n// 热门商店列表\nasync function getHotList() &#123;\n  const list = await Shop.find().sort(&#123; _id: -1 &#125;) //逆序\n  return list\n&#125;\n\n// 根据id获取单个商店信息\nasync function getShopInfo(id) &#123;\n  const shop = await Shop.findById(id)\n  return shop\n&#125;\n\n// 根据商店id获取商品\nasync function getProductByShopId(id, tab = '') &#123;\n  const pList = await Product.find(&#123;\n    shopId: id,\n    tabs: &#123;\n      $in: tab  //匹配tabs\n    &#125;\n  &#125;).sort(&#123; _id: -1 &#125;)  //逆序\n  return pList\n&#125;\n\nmodule.exports = &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125;\n在routes下新建shop.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel &#125; = require('../res-model/SuccessModel')\n\nconst &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125; = require('../controller/shop')\n\nrouter.prefix('/api/shop')\n\n// 热门商店（首页商店列表）\nrouter.get('/hot-list', async function (ctx, next) &#123;\n  const list = await getHotList()\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 根据 id 查询单个商店信息\nrouter.get('/:id', async function (ctx, next) &#123;\n  const id = ctx.params.id  //商店id\n  const shop = await getShopInfo(id)\n  ctx.body = new SuccessModel(shop)\n&#125;)\n\nrouter.get('/:id/product', async function (ctx, next) &#123;\n  const id = ctx.params.id\n  const tab = ctx.query.tab || 'all'\n  const products = await getProductByShopId(id, tab)\n  ctx.body = new SuccessModel(products)\n&#125;)\n\n订单接口\n在controller 下新建order.js\n/**\n * @description order controller\n * @author liyunfu\n */\n\nconst &#123; Order, Product, Address &#125; = require('../models/index')\n\n// 创建订单(要从Address，Product里拷贝数据，比较麻烦)\nasync function createOrder(username, data = &#123;&#125;) &#123;\n  console.log(username, data)\n  // 结构data(前端传来的订单信息)\n  const &#123;\n    addressId,\n    shopId,\n    shopName,\n    isCanceled = false,\n    products = []\n  &#125; = data\n\n  // 根据addressId获取地址信息\n  const address = await Address.findById(addressId)\n\n  // 获取商品列表\n  const pIds = products.map(p => p.id)\n  const productList = await Product.find(&#123;\n    // 条件1：商品id\n    _id: &#123;\n      $in: pIds\n    &#125;,\n    // 条件2：商店id\n    shopId\n  &#125;)\n\n  // 给商品列表增加销售数量(订单里，每个商品都有销量)\n  const productListWithSales = productList.map(p => &#123;\n    // 商品id\n    const id = p._id.toString()\n\n    // 找到商品销量\n    const filterProducts = products.filter(item => item.id === id)\n    if (filterProducts.length === 0) &#123;\n      // 没有找到匹配的数量 报错\n      throw new Error('未找到匹配的销量数据')\n    &#125;\n\n    return &#123;\n      orderSales: filterProducts[0].num,\n      product: p\n    &#125;\n  &#125;)\n\n  // 创建订单\n  const newOrder = await Order.create(&#123;\n    username,\n    address,\n    shopId,\n    shopName,\n    isCanceled,\n    products: productListWithSales\n  &#125;)\n  return newOrder\n&#125;\n\n// 获取订单列表\nasync function getOrderList(username) &#123;\n  console.log('username', username)\n  const list = await Order.find(&#123; username &#125;).sort(&#123; _id: -1 &#125;)\n  console.log('list', 'list')\n  return list\n&#125;\n\nmodule.exports = &#123;\n  createOrder,\n  getOrderList\n&#125;\n在routes 下新建order.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\nconst &#123; createOrder, getOrderList &#125; = require('../controller/order')\n\nrouter.prefix('/api/order')\n\n// 创建订单\nrouter.post('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证 可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 订单数据\n  const data = ctx.request.body\n\n  try &#123;\n    const newOrder = await createOrder(username, data)\n    ctx.body = new SuccessModel(newOrder)\n  &#125; catch (ex) &#123;\n    console.error(ex)\n    ctx.body = new ErrorModel(10005, '订单创建失败')\n  &#125;\n&#125;)\n\n// 获取订单列表\nrouter.get('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证，可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  const list = await getOrderList(username)\n\n  ctx.body = new SuccessModel(list)\n&#125;)\n\nmodule.exports = router\n\n改为适合部署到Vercel的项目\n在根目录下新建vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    &#125;\n  ]\n&#125;\n在根目录下新建index.js 将原bin/www内容移到此处\n\n修改package.json\n\"start\": \"node index.js\",\n\"dev\": \"./node_modules/.bin/nodemon index.js\",\n\"prd\": \"pm2 start index.js\",\n\n改造项目，实现跨域\n修改根目录下vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\",\n      \"headers\": &#123;\n        \"Access-Control-Allow-Credentials\": \"true\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,OPTIONS,PATCH,DELETE,POST,PUT\",\n        \"Access-Control-Allow-Headers\": \"X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version\"\n      &#125;\n    &#125;\n  ]\n&#125;\n\n​      \n","slug":"基于koa-generator搭建通用服务端","date":"2022-03-05T02:51:22.000Z","categories_index":"实战","tags_index":"实战,koa","author_index":"LIYUNFU"},{"id":"7bb7fcd214fc2de4ef1142bae196581d","title":"标准化大厂编码规范解决方案","content":"升级最新的vuenpm i vue@3.2.8 vue-router@4.0.11 vuex@4.0.2\n\nESLint规则// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象\n// 文档：https://eslint.bootcss.com/docs/user-guide/configuring\nmodule.exports = &#123;\n  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下\n  root: true,\n  // env 表示启用 ESLint 检测的环境\n  env: &#123;\n    // 在 node 环境下启动 ESLint 检测\n    node: true\n  &#125;,\n  // ESLint 中基础配置需要继承的配置\n  extends: [\"plugin:vue/vue3-essential\", \"@vue/standard\"],\n  // 解析器\n  parserOptions: &#123;\n    parser: \"babel-eslint\"\n  &#125;,\n  // 需要修改的启用规则及其各自的错误级别\n  /**\n   * 错误级别分为三种：\n   * \"off\" 或 0 - 关闭规则\n   * \"warn\" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n   * \"error\" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n   */\n  rules: &#123;\n    \"no-console\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    \"no-debugger\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    'space-before-function-paren': 0  //函数参数前括号没有空格\n  &#125;\n&#125;;\n\nPrettier配置.prettierrc\n&#123;\n  // 不尾随分号\n  \"semi\": false,\n  // 使用单引号\n  \"singleQuote\": true,\n  // 多行逗号分割的语法中，最后一行不加逗号\n  \"trailingComma\": \"none\"\n&#125;\n\n修改VSCode的TabSize\n配置大厂git提交规范全局安装Commitizennpm install -g commitizen@4.2.4\n\n安装并配置 cz-customizable 插件安装npm i cz-customizable@6.3.0 --save-dev\n\n添加以下配置到 package.json 中\"config\": &#123;\n  \"commitizen\": &#123;\n    \"path\": \"node_modules/cz-customizable\"\n  &#125;\n&#125;\n\n项目根目录下创建 .cz-config.js 自定义提示文件module.exports = &#123;\n  // 可选类型\n  types: [\n    &#123; value: 'feat', name: 'feat:     新功能' &#125;,\n    &#123; value: 'fix', name: 'fix:      修复' &#125;,\n    &#123; value: 'docs', name: 'docs:     文档变更' &#125;,\n    &#123; value: 'style', name: 'style:    代码格式(不影响代码运行的变动)' &#125;,\n    &#123;\n      value: 'refactor',\n      name: 'refactor: 重构(既不是增加feature，也不是修复bug)'\n    &#125;,\n    &#123; value: 'perf', name: 'perf:     性能优化' &#125;,\n    &#123; value: 'test', name: 'test:     增加测试' &#125;,\n    &#123; value: 'chore', name: 'chore:    构建过程或辅助工具的变动' &#125;,\n    &#123; value: 'revert', name: 'revert:   回退' &#125;,\n    &#123; value: 'build', name: 'build:    打包' &#125;\n  ],\n  // 消息步骤\n  messages: &#123;\n    type: '请选择提交类型:',\n    customScope: '请输入修改范围(可选):',\n    subject: '请简要描述提交(必填):',\n    body: '请输入详细描述(可选):',\n    footer: '请输入要关闭的issue(可选):',\n    confirmCommit: '确认使用以上信息提交？(y/n/e/h)'\n  &#125;,\n  // 跳过问题\n  skipQuestions: ['body', 'footer'],\n  // subject文字长度默认是72\n  subjectLimit: 72\n&#125;\n\n使用 git cz 代替 git commit使用 husky + commitlint 检查提交描述是否符合规范要求commitlint安装依赖：npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4\n\n根目录下创建 commitlint.config.js 文件module.exports = &#123;\n  // 继承的规则\n  extends: ['@commitlint/config-conventional'],\n  // 定义规则类型\n  rules: &#123;\n    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    'type-enum': [\n      2,\n      'always',\n      [\n        'feat', // 新功能 feature\n        'fix', // 修复 bug\n        'docs', // 文档注释\n        'style', // 代码格式(不影响代码运行的变动)\n        'refactor', // 重构(既不增加新功能，也不是修复bug)\n        'perf', // 性能优化\n        'test', // 增加测试\n        'chore', // 构建过程或辅助工具的变动\n        'revert', // 回退\n        'build' // 打包\n      ]\n    ],\n    // subject 大小写不做校验\n    'subject-case': [0]\n  &#125;\n&#125;\n\n注意：确保保存为 UTF-8 的编码格式，否则可能会出现以下错误：\n\nhusky安装依赖：npm install husky@7.0.1 --save-dev\n\n启动 hooks ， 生成 .husky 文件夹npx husky install\n\n在 package.json 中生成 prepare 指令\n执行 prepare 指令npm run prepare\n\n执行成功，提示\n添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx –no-install commitlint –edit “$1” 指令npx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"'\n\n此时的 .husky 的文件结构\n至此， 不符合规范的 commit 将不再可提交\n通过 pre-commit 检测提交时代码规范我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint –ext .js,.vue src 指令来去进行相关检测：\n\n 执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; 添加 commit 时的 hook （npx eslint --ext .js,.vue src 会在执行到该 hook 时运行） \n 该操作会生成对应文件 pre-commit： \n\n\nlint-staged 自动修复格式错误lint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送lint-staged 无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了\n修改 package.json 配置\"lint-staged\": &#123;\n    \"src/**/*.&#123;js,vue&#125;\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  &#125;\n\n修改 .husky/pre-commit 文件#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\nnpx lint-staged\n","slug":"标准化大厂编码规范解决方案","date":"2022-02-10T08:33:17.000Z","categories_index":"规范","tags_index":"git,规范","author_index":"LIYUNFU"},{"id":"6f0689131b9192e324f81c8459e5c263","title":"ajax基本使用及跨域过程","content":"ajax\n是什么：ajax是Asynchronous JavaScript and XML（异步 JavaScript 和 XMl）的简写\n异步：异步得像服务器发送请求，在等待响应的过程中，不会阻塞当前页面，浏览器可以做自己的事情。直到成功获取响应后，浏览器才开始处理响应数据\nAjax 需要服务器环境，非服务器环境下，很多浏览器无法正常使用ajax\n\nXMLHttpRequest//创建xhr对象\nconst xhr=new XMLHttpRequest();\n\n//监听事件，处理响应\nxhr.addEventListener('readystatechange',()=>&#123;&#125;,false)\n//或\nxhr.onreadystatechange=()=>&#123;&#125;\n\n//处理响应\nxhr.onreadystatechange=()=>&#123;\n    if(xhr.readyState!==4)return;\n    \n    //http code\n    //获取到响应后，响应的内容会自动填充xhr对象的属性\n    if(xhr.status>=200&amp;&amp;xhr.status&lt;300||xhr.status===304)&#123;\n        console.log(xhr.responseText)\n    &#125;\n&#125;\n\n/*\nreadystatechange 事件监听readyState这个状态的变化\n0: 未初始化，尚未调用open()\n1: 启动，已经调用open() 但尚未调用send()\n2: 发送，已经调用send() 但尚未接收到响应\n3: 接收，已经接收到部分响应数据\n4: 完成，已经接收到全部响应数据，而且已经可以在浏览器中使用了\n*/\n\n//准备发送请求\nxhr.open(\n\t'HTTP 方法 GET、POST、PUT、DELETE',\n    '地址 URL',\n    true //是否异步\n)\n\n//发送请求 send的参数是通过请求体携带的数据 只有post能携带请求体\nxhr.send(null)\n\n属性\nresponseType 和 response 属性\nxhr.onreadystatechange = () => &#123;\n  if (xhr.readyState != 4) return;\n  if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n    // 文本形式的响应内容\n    // responseText 只能在没有设置 responseType 或者 responseType = '' 或 'text' 的时候才能使用\n    // console.log('responseText:', xhr.responseText);\n    // 可以用来替代 responseText\n    console.log('response:', xhr.response);\n    // console.log(JSON.parse(xhr.responseText));\n  &#125;\n&#125;;\n\nxhr.responseType = 'text';\ntimeout属性\n//设置请求的超时时间（单位ms） 在发送之前\n xhr.open('GET', url, true);\n\nxhr.timeout = 10000;\n\nxhr.send(null);\nwithCredentials属性\n//指定使用ajax发送请求时是否携带cookie\nxhr.open('GET', url, true);\n\nxhr.withCredentials = true;\n\nxhr.send(null);\n\n方法\nabort() 终止当前请求\nxhr.open('GET', url, true);\nxhr.send(null);\nxhr.abort();\n//放在发送之后\nsetRequestHeader()设置请求头消息\nxhr.setRequestHeader(头部字段的名称, 头部字段的值);\nxhr.setRequestHeader('Content-Type','application/json')\n\n事件\nload事件 响应数据可用时触发\nxhr.onload=()=>&#123;&#125;\nxhr.addEventListener('load',()=>&#123;&#125;)\n//代替readystatechange 可以有效减少判断标识为4 的状态\nerror事件 请求发生错误时触发\nxhr.addEventListener(\n  'load',\n  () => &#123;\n    if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n      console.log(xhr.response);\n    &#125;\n  &#125;,\n  false\n);\nxhr.addEventListener(\n  'error',\n  () => &#123;\n    console.log('error');\n  &#125;,\n  false\n)\nabort事件 调用abort方法后触发\nxhr.addEventListener(\n  'abort',\n  () => &#123;\n    console.log('abort');\n  &#125;,\n  false\n);\n\nJson不支持undefined\n\nJSON.parse()\n将json字符串转化为JS的数据类型，对象或者数组\n\n\nJSON.stringify()\n将JS的基本数据类型，对象或者数组转化为JSON的字符串\n\n\n\nCORS\n使用CORS 跨域的过程\n① 浏览器发送请求\n② 后端在响应头中添加Access-Control-Allow-Origin 头信息\n③ 浏览器接收到响应\n④ 如果是同域下的请求，浏览器不会额外做什么，这次前后端通信就圆满了\n⑤ 如果是跨域请求，浏览器会从响应头中查找是否允许跨域访问\n⑥ 如果允许跨域，通信圆满完成\n⑦ 如果没找到或步包含想要跨域的域名，就丢弃响应结果\n\n\n","slug":"ajax基本使用及跨域过程","date":"2022-03-05T03:06:30.000Z","categories_index":"知识点","tags_index":"ajax,跨域","author_index":"LIYUNFU"},{"id":"c123efc46127ac74fdea33d3d47fa7a0","title":"远程服务器安装Docker并配置数据库","content":"Docker命令安装docker-desktop点击前往官网下载，一直下一步安装即可\n如果出现错误，说明wsl内核未更新到wsl2，点击下载安装之后重启docker-desktop即可\n查看已安装docker版本docker --version\n安装docker-compose\n\n\n\n\n\n\n\n\nDocker Compose是一个工具，旨在帮助定义和共享多容器应用程序。使用Compose，我们可以创建一个YAML文件来定义服务，并且使用单个命令，可以启动所有内容或将其全部拆解。使用 Compose的最大优点是，您可以在文件中定义应用程序堆栈，将其保留在项目存储库的根目录下（现在是受版本控制的），并轻松地让其他人能够为您的项目做出贡献。有人只需要克隆你的存储库并启动撰写应用。事实上，你现在可能会在GitHub/GitLab上看到相当多的项目在做这件事。\n简单来说就是 docker-compose能够让你自定义一个YAML配置文件，能够一键启动所有任务安装了docker desktop的自带docker-compose不需要再安装了\n\nLinux安装教程 https://docs.docker.com/compose/install/\n\n安装mongo使用Docker Hub搜索mongo 点击进入mongo-Docker Hub\ndocker pull mongo:4  #可接版本号也可不接\n\n查看本地下载了哪些镜像docker images\n\n运行mongo映射到宿主机上docker run -d --name some-mongo -p 10050:27017 mongo:4\n\n运行MYSQL映射到宿主机上docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -p 10051:3306 -d mysql:5.6\n\n查看当前运行的服务docker ps\n\n在Linux机器中需要放行端口 10050方案一 直接关闭防火墙#ubuntu\nservice ufw stop\n#centos\nservice firewalld stop\n\n方案二 放行指定端口# ubuntu\nufw allow Port 端口号\n\n#centos\nfirewall-cmd --zone&#x3D;public --add-port&#x3D;10050&#x2F;tcp --permanent\n\n重载防火墙firewall-cmd --reload\n\n提交自己的images提交到docker仓库docker commit id号  liyunfu&#x2F;mysql:1.0\ndocker push liyunfu&#x2F;mysql:1.0 \n\n拉取自己的imagesdocker pull liyunfu&#x2F;mysql:1.0\n\n删除imagesdocker image rm id号\n\n\n\ndocker-compose编写YML文件version: '3'\nservices:\n  mysql1:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10052:3306\n\n  mysql2:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10053:3306\n\n执行YMLdocker-compose up\n\n\n\nLinux连接远程服务器ssh -p 27822 root@server.bontor.cn   # ssh -p 端口  用户名@服务器地址\n\n查看操作系统版本lsb_release -a\n\n查看内核版本uname -a\n\n检查文件系统磁盘空间占用情况df -Th  # 后缀变为以G为单位 不加以字节为单位\n\n目录结构&#x2F;home  主目录\n&#x2F;etc   软件配置文件\n&#x2F;sys   系统目录\n&#x2F;usr   系统可执行文件\n&#x2F;var   日志文件 不断增长大小\n\nCPU和内存top #查看正在运行的进程 已经cpu占用情况 和内存使用情况\n\n文档型：文件相关命令(touch，cat，echo，rm，vi，cd)touch test.txt \nvi test.txt\ncd &#x2F;home\ncat test.txt\necho &quot;123123&quot;&gt;&gt;test.txt  #两个箭头追加 一个箭头覆盖  \n\n硬件型：磁盘/进程/服务/网络查看进程ps -ef | grep docker  #查询并使用grep筛选 docker进程\n\n强制关闭进程kill -9 进程的PID\n\n查看服务的状态service sshd status\n\n关闭服务service sshd stop  #关闭sshd服务\n\n重启服务service sshd restart\n\n功能型：压缩/解压，下载，远程下载wget 资源地址\n\n解压tar zxvf app.tar.gz\n\n压缩tar zcvf app.tar.gz app\n\n\n\n修改默认SSH端口查看默认监听端口netstat -anlp | grep sshd\n\n修改默认监听端口vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config\n#删除#  修改port 22 为 port 27001\n\n#centos修改之后必须运行\nsemanage port -a -t ssh_port_t -p tcp 27001   \n#提示没有该命令\nyum whatprovides semanage\n#找到拥有命令的包安装\nyum install -y policycoreutils-python\n#查看端口\nsemanage port -l | grep ssh\n\n#删除端口\nsemanage port -d -t ssh_port_t -p tcp 22\n","slug":"远程服务器安装Docker并配置数据库","date":"2022-03-05T03:02:36.000Z","categories_index":"实战","tags_index":"数据库,Docker","author_index":"LIYUNFU"},{"id":"417b0753cea51755f39f949bc1137c41","title":"Webpack5搭建标准开发环境","content":"Webpack安装&amp;使用安装npm install webpack webpack-cli -D\n\n使用方式方式一.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version\n\n方式二npx webpack --version\n\n\n\n入口(entry)\n\n\n\n\n\n\n\n\n**入口起点(entry point)*指示 webpack 应该使用哪个模块，来作为构建其内部依赖图*的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。\n出口(output)\n\n\n\n\n\n\n\n\noutput 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist\nconst config = &#123;\n    entry: './src/index.js',\n    output: &#123;\n        filename: 'bundle.js',\n        path: path.join(__dirname, './dist')\n    &#125;\n&#125;\n\n\nloader\n\n\n\n\n\n\n\n\nloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。\n让webpack处理CSS文件\n\n\n\n\n\n\n\n\nwebpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这种情况下，以 .css 结尾的全部文件，都将被提供给 style-loader 和 css-loader。\n\n下载依赖loader\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\n编写规则，匹配哪些后缀使用哪些loader  webpack.config.js\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.css$/,\n            use:['style-loader','css-loader']\n        &#125;\n    ]\n&#125;\nloader链式传递，先从后面的loader开始\n\n\n让webpack处理scss文件\n下载依赖loader\nnpm install sass-loader node-sass -D\n编写规则\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.(scss|sass)$/,\n            use:['style-loader','css-loader','sass-loader']\n        &#125;\n    ]\n&#125;,\n\nfile-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。\n让webpack处理图片\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test: /\\.(png|jpg|svg|gif)$/,\n    use:['file-loader']\n&#125;\n可以在index.js中引入\nimport Icon from './icon.jpg';\n\n//将图像添加到我们现有的div\nconst myIcon = new Image();\nmyIcon.src = Icon;\nelement.appendChild(myIcon);\n也可在index.scss中引入\n.hello&#123;\n  color: red;\n  background: url(\"./icon.jpg\");\n&#125;\n\n让webpack处理字体\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test:/\\.(woff|woff2|eot|ttf|otf)$/,\n    use:['file-loader']\n&#125;\n在index.scss中引入\n@font-face &#123;\n  font-family: 'Myfont';\n  src: url(\"./myfont.TTF\") format('ttf');\n  font-weight: 600;\n  font-style: normal;\n&#125;\n.hello&#123;\n  color: red;\n  font-family: Myfont;\n&#125;\n\n让webpack处理CSV、TSV 、XML\n下载依赖loader\nnpm install csv-loader xml-loader -D\n编写规则\n&#123;\n    test:/\\.(csv|tsv)$/,\n    use:['csv-loader']\n&#125;,\n&#123;\n    test:/\\.xml$/,\n    use:['xml-loader']\n&#125;\n在src下创建data.xml并在index.js中引入\n\ndata.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;note>\n    &lt;to>mary&lt;/to>\n    &lt;from>john&lt;/from>\n    &lt;heading>reminder&lt;/heading>\n    &lt;body>call cindy on tuesday&lt;/body>\n&lt;/note>\n\n\nindex.js\n\nimport Data from './data.xml';\n\nconsole.log(Data);\n\n插件(plugins)\n\n\n\n\n\n\n\n\nloader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。\n使用plugins处理html\n下载依赖plugins\nnpm install html-webpack-plugin -D\n由于插件可以携带参数/选项，所以必须在webpack配置中，向plugins属性传入new实例\n\n```js//处理src下的html文件plugins: [\n    new HtmlWebpackPlugin(&#123;template: &quot;./src/index.html&quot;&#125;)\n\n],\n\n## 模式(mode)\n\n&gt; 通过选择 &#96;development&#96; 或 &#96;production&#96; 之中的一个，来设置 &#96;mode&#96; 参数，你可以启用相应模式下的 webpack 内置的优化\n\n&#96;&#96;&#96;jsx\nmodule.exports &#x3D; &#123;\n  mode: &#39;production&#39;\n&#125;;\n\n模块热替换过程在应用程序中置换模块\n应用程序代码要求HMR runtime检查更新\nHMR runtime(异步)下载更新，然后通知应用程序代码\n应用程序代码要求HMR runtime应用更新\nHMR runtime(同步)应用更新\n\n在编译器中除了普通资源，编译器需要发出update，以允许更新之前的版本到新的版本，update由两部分组成：\n\n更新后的manifest(JSON)\n一个或多个更新后的chunk(JavaScript)\n\n配置标准开发环境ni babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;plugin-transform-runtime -D\nni @babel&#x2F;runtime \n\n创建.babelrc&#123;\n  \"presets\": [\n    \"@babel/preset-env\"\n  ],\n  \"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n  ]\n&#125;\n\n在webpack.config.js中rules添加规则&#123;\n    test:/\\.js$/,\n    loader: \"babel-loader\"\n&#125;\n\n\n\n\n\n\n\n\n\n\n第一里程碑\n自动清理dist目录webpack5.x之后在输出中添加clean:true即可\noutput: &#123;\n    filename: &#39;bundle.js&#39;,\n    path: path.join(__dirname, &#39;.&#x2F;dist&#39;),\n    clean: true\n&#125;,\n\n\nCleanWebpackPlugin does not clean in Webpack 5 - fsou (nilmap.com)\n复制资源到dist目录\n引入对应插件\n\nnpm install --save-dev copy-webpack-plugin\n\n\n编写新的plugin语法，旧语法有问题，因为CopyWebpackPlugin构造函数还支持其他选项\n\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nnew CopyWebpackPlugin(\n    &#123;\n        patterns: [\n            &#123;\n                from: path.join(__dirname, 'assets')\n                to: 'assets'\n            &#125;\n        ]\n    &#125;\n)\n\n\n\n\n\n\n\n\n\n\n\n错误信息：[webpack-cli] Invalid options object. Copy Plugin has been initialized using an options object that does not match the API schema.\n对js和css压缩 丑化JS和CSS压缩css和js\n安装依赖\nni css-minimizer-webpack-plugin -D\nni terser-webpack-plugin -D   &#x2F;&#x2F;让他来增强...扩展运算符\nni mini-css-extract-plugin -D  &#x2F;&#x2F;支持头部单独引用不许安装\n引入对应插件 \nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserJSPlugin=require('terser-webpack-plugin')\nrules\n&#123;\n    test: /\\.(scss|sass)$/,\n    use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']\n&#125;,\noptimization\noptimization: &#123;\n    minimize: true,  //设置开发环境可用，若不设置默认false只能支持生产环境\n    minimizer: [\n        `...`,   //使用扩展运算符增强\n        new CssMinimizerPlugin(),\n      \tnew TerserJSPlugin()\n    ]\n&#125;,\nplugins\nnew MiniCssExtractPlugin(&#123;\n    filename: '[name].css',\n    chunkFilename:'[id].css',\n&#125;),\nnew MiniCssExtractPlugin(),\nnew TerserJSPlugin()\n\n","slug":"Webpack5搭建标准开发环境","date":"2022-03-05T03:00:17.000Z","categories_index":"实战","tags_index":"Webpack,前端工程化","author_index":"LIYUNFU"},{"id":"fe45cec90ec11b72673f92c41490ffd7","title":"基于koa-generator实现验证码功能","content":"第一步\n全局安装koa-generator\n\n```shellnpm install -g koa-generator\n\n- 生成基本框架\n\n- &#96;&#96;&#96;shell\n  koa2 apiname    \n  # 使用koa2后面接目录名即可自动创建名为apiname的目录\n根据命令行提示，进入创建的文件夹，执行npm install\n\n```shellcd apinamenpm install\n\n- 下载依赖完成之后，可以启动看看\n\n- &#96;&#96;&#96;shell\n  npm run start\n打开浏览器访问3000端口\n\n```shellhttp://localhost:3000\n\n- 如果浏览器中页面显示出数据即创建成功，可以进入下一步\n\n\n\n### 第二步\n\n- 在根目录下新建&#96;src&#96;目录\n\n- 将&#96;public&#96; 、&#96;routes&#96; 、&#96;views&#96; 、&#96;app.js&#96;拖入&#96;src&#96;目录\n\n- 修改&#96;bin&#x2F;www&#96;中的&#96;var app &#x3D; require(&#39;..&#x2F;app&#39;);&#96;为&#96;var app &#x3D; require(&#39;..&#x2F;src&#x2F;app&#39;);&#96;\n\n- 改造后目录\n\n- &#96;&#96;&#96;shell\n  |- bin\n    |- www\n  |-node_modules\n  |-src\n    |-public\n    |-routes\n    |-views\n    |-app.js\n  |-package.json\n在src目录下创建目录controller\n\n\n第三步\n安装用于聚合router的包\n\n安装koa-combine-routers包\n\n```shellnpm install koa-combine-routers\n\n- 安装&#96;svg-captcha&#96;  包 用于生成&#96;svg&#96;验证码\n\n- &#96;&#96;&#96;shell\n  npm install svg-captcha\n在controller目录下创建publicController.js 用于生成验证码 并输入以下代码\n\n```jsconst svgCaptcha = require(“svg-captcha”);\nfunction  publicController(ctx) {  //创建一个新验证码svg对象  const newCaptcha = svgCaptcha.create({\nsize: 4,  //验证码长度\nignoreChars: &quot;0o1il&quot;, //排除易混淆的几个0o1il字符\ncolor: true,   //验证码有颜色\nnoise: Math.floor(Math.random() * 5), //干扰线\nwidth: 150,  \nheight: 50,\n\n  });  ctx.body = {\nmsg: newCaptcha.data,\n\n  };}\nmodule.exports = publicController;\n\n- 在&#96;routes&#96;目录下新建&#96;publicRouter.js &#96; 输入以下代码\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;koa-router&quot;)();\n  const getCaptcha &#x3D; require(&quot;..&#x2F;controller&#x2F;PublicController&quot;);\n  \n  router.get(&quot;&#x2F;getCaptcha&quot;, getCaptcha);\n  \n  module.exports &#x3D; router;\n在routes目录下新建routes.js 输入以下代码\n\n```jsconst combineRoutes=require(‘koa-combine-routers’)\nconst aRoutes=require(‘./publicRouter’)\nmodule.exports=combineRoutes(  aRoutes   //如果有多个 可以引入多个，并写在此处用逗号隔开)\n\n- 在&#96;app.js&#96;引入&#96;routes.js&#96; 并使用\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;.&#x2F;routes&#x2F;routes&quot;);\n  app.use(router())\n实现跨域请求，下载并引入koa2-cors包\n\n```shellnpm install koa2-cors\nconst cors = require(“koa2-cors”);\n//cors配置app.use(  cors({\norigin: &quot;http://localhost:8080&quot;, //前端origin\ncredentials: true, //允许跨域带cookie\n\n  }));\n\n\n\n### 第四步\n\n使用&#96;vue&#96;项目，尝试请求验证码  下载&#96;axios&#96;包\n\n&#96;&#96;&#96;vue\n&lt;template&gt;\n\t&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div class&#x3D;&quot;svg&quot; @click&#x3D;&quot;getCaptcha&quot; v-html&#x3D;&quot;svg&quot;&gt;验证码&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nconst axios &#x3D; require(&#39;axios&#39;)\nexport default &#123;\n  name: &#39;app&#39;,\n  data () &#123;\n    return &#123;\n      svg: &#39;&#39;\n    &#125;\n  &#125;,\n  mounted () &#123;\n    this.getCaptcha()\n  &#125;,\n  methods: &#123;\n    getCaptcha () &#123;\n      axios.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;getCaptcha&#39;).then((res) &#x3D;&gt; &#123;\n        if (res.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          this.svg &#x3D; res.data.msg\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n","slug":"基于koa-generator实现验证码功能","date":"2022-03-05T02:56:54.000Z","categories_index":"实战","tags_index":"Koa","author_index":"LIYUNFU"},{"id":"2dd921bc2e0b67b467ed4b61518bdc3d","title":"MongoDB的CRUD","content":"MongoDB初见\nDocker中MongoDB数据的备份与恢复#备份\ndocker exec -it 镜像名 mongodump -h 地址 -u root -p example -o 备份到的地址\ndocker exec -it some-mongo mongodump -h localhost -u root -p example -o &#x2F;temp&#x2F;test\n\n\n\n是什么\n存储文档的非关系型数据库\n\n\n\n可以将多个不同的内容添加到一个集合里面，如果想要添加字段，直接添加，不会报错\n\nMongoDB的CRUD创建文档创建一个文档\n自己提供文档主键_id值，容易出现错误，可以省略文档_id字段，让它自动生成，collection为集合\n\ndb.collection.insertOne(\n\t&#123;\n\t_id: &quot;account1&quot;,\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\ndb.collection.insertOne(\n\t&#123;\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\n创建多个文档\nordered参数用来决定mongoDB是否要按顺序来写入这些文档\nordered:false 表示可以打乱文档写入顺序，以便优化写入的操作\nordered:true(默认值)按顺序执行，如果第一条插入数据错误，那么第二天不会执行\n\n\n\ndb.accounts.insertMany(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t,\n\t&#123;\n\t\tordered:false  &#x2F;&#x2F;可选\n\t&#125;\n)\n\n\n创建单个或多个文档\nsave命令运行时调用insert   db.collection.save \n\ndb.accounts.insert(\n\t&#123;\n\tname: &quot;alice1&quot;,\n\tbalance: 100\n\t&#125;,\n)\n\ndb.accounts.insert(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t\n)\n\n\n\ninsertOne 、insertMany 、insert的区别\n正确和错误返回的结果不同\n\ninsertOne和insertMany命令不支持db.collection.explain()名\n\ninsert支持db.collection.explain命令\n\n\n读取文档读取全部文档\n既不筛选，也不投射\ndb.accounts.find()\n更清晰的显示文档\ndb.accounts.find().pretty()\n\n匹配查询\n读取alice的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;&#125;)\n读取alice的余额为100元的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;,balance: 100&#125;)\n读取复合主键的文档\ndb.accounts.find(&#123;&quot;_id.type&quot;: &quot;savings&quot;&#125;)\n\n比较操作符\n\n\n操作符\n含义\n\n\n\n$eq\n相等查询值的文档\n\n\n$ne\n不等查询值的文档\n\n\n$gt\n大于查询值的文档\n\n\n$gte\n大于或等于查询值的文档\n\n\n$lt\n小于查询值的文档\n\n\n$lte\n小于或等于查询值的文档\n\n\n$in\n与任一查询值相等的文档\n\n\n$nin\n与任何查询值都不等的文档\n\n\n\n读取不属于alice的银行账户文档\ndb.accounts.find(&#123;name: &#123;$ne:&quot;alice&quot;&#125;&#125;)\n读取余额大于500的银行账户文档\ndb.accounts.find(&#123;balance: &#123;$gt:500&#125;&#125;)\n读取用户名字排在fred之前的银行账户文档\ndb.accounts.find(&#123;name: &#123;$lt:&quot;fred&quot;&#125;&#125;)\n读取alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$in:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n读取既不是alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$nin:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n\n逻辑操作符\n\n\n逻辑操作符\n含义\n\n\n\n$not\n筛选条件不成立的文档\n\n\n$and\n多个条件全部成立的文档\n\n\n$or\n至少一个筛选条件成立的文档\n\n\n$nor\n多个筛选条件全部不成立的文档\n\n\n\n读取余额不小于500的银行账户文档  \ndb.accounts.find(&#123;balance:&#123;$not:&#123;$lt:500&#125;&#125;&#125;)\n读取余额大于100并且用户姓名排在fred之后的银行账户文档\ndb.accounts.find(&#123;$and:[&#123;balance:&#123;$gt:100&#125;&#125;,&#123;name:&#123;$gt:&quot;fred&quot;&#125;&#125;]&#125;)\n读取余额大于100并且小于500的银行账户文档\ndb.accounts.find(&#123;balance:&#123;$lt:500,$gt:100&#125;&#125;&#125;)\n读取属于alice或者charlie的银行账户文档\ndb.accounts.find(&#123;\n\t$or:[\n\t\t&#123;name:&#123;$eq:&quot;alice&quot;&#125;&#125;,\n\t\t&#123;name:&#123;$eq:&quot;charlie&quot;&#125;&#125;\n\t]\n&#125;)\n读取既不属于alice和charlie且余额不小于100的银行账户文档\ndb.accounts.find(&#123;\n\t$nor:[\n\t\t&#123;name:&quot;alice&quot;&#125;,\n\t\t&#123;name:&quot;charlie&quot;&#125;,\n\t\t&#123;balance:&#123;$lt:100&#125;&#125;\n\t]\n&#125;)\n\n字段操作符\n\n\n操作符\n含义\n\n\n\n$exists\n包含查询字段的文档\n\n\n$type\n字段类型符合查询值的文档\n\n\n\n读取包含账户类型字段的银行账户文档\ndb.accounts.find(&#123;&quot;_id.type&quot;:&#123;$exists:true&#125;&#125;)\n读取文档主键是字符串的银行账户文档\ndb.accounts.find(&#123;_id:&#123;$type:&quot;string&quot;&#125;&#125;)\n\n数组操作符\n\n\n操作符\n含义\n\n\n\n$all\n数组字段中包含所有查询值的文档\n\n\n$elemMatch\n数组字段中至少存在一个值满足筛选条件的文档\n\n\n\n读取联系地址位于中国北京的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$all:[&quot;china&quot;,&quot;beijing&quot;]&#125;&#125;)\n读取联系电话范围在100000和200000之间的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$elemMatch:&#123;$gt:&quot;100000&quot;,$lt:&quot;200000&quot;&#125;&#125;&#125;)\n\n正则操作符\n读取用户姓名以c或者j开头的银行账号文档\ndb.accounts.find(&#123;name:&#123;$in:[&#x2F;^c&#x2F;,&#x2F;^j&#x2F;]&#125;&#125;)\n读取用户姓名包含LIE(不区分大小写)的银行账户文档\ndb.accounts.find(&#123;name:&#123;$regex:&#x2F;LIE&#x2F;,$options:&#39;i&#39;&#125;&#125;)\n\n文档游标\n查询语句默认返回的是文档游标，默认只显示前二十条\n\n游标函数var cursor=db.accounts.find()\n\n\ncursor.hasNext() cursor.next()\n\n```jsvar myCursor=db.accounts.find({name:”alice”})while(myCursor.hasNext()){  printjson(myCursor.next())}  //只要还有就把剩余文档打印出来\n\n- &#96;cursor.forEach()&#96;\n\n- &#96;&#96;&#96;js\n  var myCursor&#x3D;db.accounts.find(&#123;name:&quot;alice&quot;&#125;)\n  myCursor.forEach(printjson)   &#x2F;&#x2F;每篇文档被打印\ncursor.limit()\n\ncursor.skip()\n\n```jsdb.accounts.find({name:”alice”}).limit(1)  //只返回第一篇文档db.accounts.find({name:”alice”}).skip(1)   //跳过第一篇 只显示第二篇和第三篇\n\n- &#96;cursor.count()&#96;\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count()   &#x2F;&#x2F;返回3\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count(true)  &#x2F;&#x2F;返回1\n  &#x2F;&#x2F;默认不接收limit和skip返回的结果\ncursor.sort()\n\n按照余额从大到小，用户名按字母顺序排序\n\n```jsdb.accounts.find().sort({balance:-1,name:1})\n\n\n\n#### 游标注意事件\n\n- &#96;cursor.skip()&#96;在&#96;cursor.limit()&#96;之前执行\n- &#96;cursor.sort()&#96;在&#96;cursor.skip()&#96;和&#96;cursor.limit()&#96;之前执行\n\n\n\n#### 文档投影\n\n- 只返回银行账户文档中的用户姓名\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;&#125;,&#123;name:1&#125;)\n\n\n只返回银行账户文档中的用户姓名(不包含文档主键)\n\ndb.accounts.find(&#123;&#125;,&#123;name:1,_id:0&#125;)\n\n\n除了文档主键之外，我们不可以在投影文档中混合使用包含和不包含这两种投影操作要么在投影文档中列出所有应该包含的字段，要么列出所有不应该包含的字段\n\n\n更新文档","slug":"MongoDB的CRUD","date":"2022-03-05T02:54:11.000Z","categories_index":"实战","tags_index":"MongoDB,数据库,Mongoose","author_index":"LIYUNFU"},{"id":"b9b69e275d0ea3fd4374ffde1f72e980","title":"JSX如何\"摇身一变\"成为DOM的","content":"JSX代码如何变成DOM抛出问题\n  JSX的本质是什么，它和JS之间到底是什么关系？\n\n  为什么要用JSX？不用会有什么后果？\n\n  JSX背后的功能模块是什么，这个功能模块都做了那些事\n\n\n尝试解答\n  JSX的本质是JS的拓展，但是浏览器不能天然支持JSX，所以需要Babel将它编译为React.createElement()的调用，语法糖返回一个叫React Element的JS对象\n\n\n\n  既然最后编译为React.createElement()的调用，为什么不直接使用React.createElement()呢？\n答：\n  由于实现同样的功能的情况下，JSX代码层次分明，语言简练，而React.createElement()代码繁重\n  JSX语法糖允许前端开发者使用我们最为熟悉的类HTML标签语法来创建虚拟DOM，在降低学习成本的同时，也提升了研发效率和研发体验\n\n\n\n\\\n\n  \n\n\\\ncreateElement解析&#x2F;**\n  React的创建元素方法\n *&#x2F;\n\nfunction createElement(type, config, children) &#123;\n  &#x2F;&#x2F; propName用于储存后面需要用到的元素属性\n  var propName;\n  &#x2F;&#x2F; props用于储存元素属性的键值对集合\n  var props &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; key、ref、self、source均为React元素的属性\n  var key &#x3D; null;\n  var ref &#x3D; null;\n  var self &#x3D; null;\n  var source &#x3D; null;\n\n  &#x2F;&#x2F; config 对象中存储的是元素的属性\n  if (config !&#x3D; null) &#123;\n    &#x2F;&#x2F; 进来之后的第一件事，依次对ref、key、self和source属性赋值\n    if (hasValidRef(config)) &#123;\n      ref &#x3D; config.ref;\n\n      &#123;\n        warnIfStringRefCannotBeAutoConverted(config);\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 此处将key 值字符串化\n    if (hasValidKey(config)) &#123;\n      key &#x3D; &#39;&#39; + config.key;\n    &#125;\n\n    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;\n    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source; &#x2F;&#x2F; Remaining properties are added to a new props object\n\n    &#x2F;&#x2F; 接着就是要把config里面的属性都一个一个挪到props对象里面\n    for (propName in config) &#123;\n      if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;\n        props[propName] &#x3D; config[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; childrenLength 指的是当前元素的子元素的个数，减去的2是type和config两个参数占用的长度\n  var childrenLength &#x3D; arguments.length - 2;\n\n  &#x2F;&#x2F; 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;\n    &#x2F;&#x2F; 直接把这个值赋值给props.children\n    props.children &#x3D; children;\n  &#125; else if (childrenLength &gt; 1) &#123;\n    &#x2F;&#x2F; 处理嵌套多个子元素的情况\n    &#x2F;&#x2F; 声明一个数组，把所有剩余对象参数都遍历传入，最后把数组赋值给props.children对象\n    var childArray &#x3D; Array(childrenLength);\n\n    for (var i &#x3D; 0; i &lt; childrenLength; i++) &#123;\n      childArray[i] &#x3D; arguments[i + 2];\n    &#125;\n\n    &#123;\n      if (Object.freeze) &#123;\n        Object.freeze(childArray);\n      &#125;\n    &#125;\n\n    props.children &#x3D; childArray;\n  &#125; &#x2F;&#x2F; Resolve default props\n\n  &#x2F;&#x2F; 处理defaultProps\n  if (type &amp;&amp; type.defaultProps) &#123;\n    var defaultProps &#x3D; type.defaultProps;\n\n    for (propName in defaultProps) &#123;\n      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;\n        props[propName] &#x3D; defaultProps[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#123;\n    if (key || ref) &#123;\n      var displayName &#x3D; typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39; ? type.displayName || type.name || &#39;Unknown&#39; : type;\n\n      if (key) &#123;\n        defineKeyPropWarningGetter(props, displayName);\n      &#125;\n\n      if (ref) &#123;\n        defineRefPropWarningGetter(props, displayName);\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n&#125;\n\n参数说明：\n  type:用于标识节点的类型，它可以是HTML标签字符串，也可以是React组件类型\n\n  config: 以对象形式传入，组件所有的属性都会以键值对的形式存储在config对象中\n\n  children: 以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的”子节点””子元素”\n\n\n例子DOM结构\n&lt;ul className&#x3D;&quot;list&quot; id&#x3D;&quot;lis&quot;&gt;\n  &lt;li key&#x3D;&#123;1&#125;&gt;&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&#123;2&#125;&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact.createElement语法糖\nReact.createElement(&quot;ul&quot;, &#123;\n  &#x2F;&#x2F; 传入属性键值对\n  className: &quot;list&quot;,\n  id: &quot;lis&quot;\n  &#x2F;&#x2F; 从第三个入参开始往后，传入的参数都是children\n&#125;, React.createElement(&quot;li&quot;, &#123;\n  key: 1\n&#125;), React, createElement(&quot;li&quot;, &#123;\n  key: 2\n&#125;))\n\n流程\n 处理key、ref、self、source四个属性值\n\n 遍历config，筛选出可以提进props里的属性\n\n 提取子元素，推入props.children\n\n 格式化defaultProps\n\n 将以上数据作为入参，发起ReactElement调用\n\n\n总结createElement就像是开发者和ReactElement调用之间的一个“转换器”，在开发者出接收相对简单的参数，然年后将这些参数按照ReactElement的预期做一层格式化，最终通过调用ReactElement来实现元素的创建\nReactElement解析var ReactElement &#x3D; function (type, key, ref, self, source, owner, props) &#123;\n  var element &#x3D; &#123;\n    &#x2F;&#x2F; 用来标识该对象是一个ReactElement\n    $$typeof: REACT_ELEMENT_TYPE,\n    &#x2F;&#x2F; 内置属性赋值\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    &#x2F;&#x2F; 记录创建该元素的组件\n    _owner: owner\n  &#125;;\n\n  return element;\n&#125;;\n\nReactElement只做了一件事情，就是组装，把传入的参数按照一定的规范，组装进element对象里，并把它返回给React.createElement，最终React.createElement又把它交回到开发者手中\n\nrender初识function render(element, container, callback) &#123;\n  if (!isValidContainer(container)) &#123;\n    &#123;\n      throw Error( &quot;Target container is not a DOM element.&quot; );\n    &#125;\n  &#125;\n\n  &#123;\n    var isModernRoot &#x3D; isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer &#x3D;&#x3D;&#x3D; undefined;\n\n    if (isModernRoot) &#123;\n      error(&#39;You are calling ReactDOM.render() on a container that was previously &#39; + &#39;passed to ReactDOM.createRoot(). This is not supported. &#39; + &#39;Did you mean to call root.render(element)?&#39;);\n    &#125;\n  &#125;\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n&#125;\n\n参数说明\n  element:需要渲染的元素(ReactElement)\n\n  container:元素挂载的目标容器(一个真实DOM)\n\n  callback: 回调函数，可选参数，可以用来处理渲染结束后的逻辑\n\n\n总结\n","slug":"JSX如何变成DOM","date":"2022-02-27T09:46:50.000Z","categories_index":"React源码","tags_index":"React,源码","author_index":"LIYUNFU"},{"id":"bdee22d1805781f30b666804c7635df8","title":"flex布局","content":"flex容器属性改变主轴方向flex-directionflex-direction: row默认\nflex-direction: row-reverse\nflex-direction: column\nflex-direction: column-reverse\n换行flex-wrapflex-wrap: nowrap默认\nflex-wrap: wrap\nflex-wrap: wrap-reverse\n缩写flex-flow: [flex-direction] [flex-wrap]flex-flow: column wrap\n主轴对齐justify-contentjustify-content: flex-start默认\njustify-content: flex-end\njustify-content: space-around 平均分配  每个方块的margin-left+margin-right+width相等\njustify-content: space-between 两边没有空隙 中间空隙平均分配\njustify-content: space-evenly所有空隙平均分配\n交叉轴整体对齐align-content 必须要有折行属性才能生效  \nalign-content: stretch默认\n如果交叉轴上的宽度未设置则自动拉伸填满交叉轴\n\n\n\n若交叉轴上的宽度已经设置则效果和flex-start一样\n\n\n\n\nalign-content: flex-start\nalign-content: flex-end\nalign-content: center\n其他属性 space-around``space-between``space-evenly和主轴属性类似交叉轴每一行对齐 align-itemsalign-items: stretch默认align-items: flex-start\nalign-items: flex-end\nalign-items: center\nalign-items: baseline 内容以小写x为基线对齐\n内联与块的上下左右居中布局内联上下左右居中\n块级上下左右居中\n不定项居中布局\n均分列布局\n子项分组布局复杂模式 使用div嵌套\n简单方式 margin-right: auto\nflex子项属性扩展比例flex-grow一个子元素时\n默认值为0\n\n比例值大于等于1，沾满剩余所有空间\n\n比例值为0.5，占剩余空间的一半\n\n\n\n\n多个子元素时\n只有一个有flex-grow时\n\n\n\n两个都有flex-grow时\n\n\n\n当多个元素加起来小于1时，还有剩余空间\n\n\n收缩比例flex-shrink\n默认值为1，溢出部分完全收缩，小数按比例收缩\n\n\n默认情况当有两个及以上需要收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，默认情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-2/5*(200+300-400)=160\n\nbox2收缩后所占尺寸：300-3/5*(200+300-400)=240\n\n\n\n不同比例收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，比例情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-4/7*(200+300-400)=142\n\nbox2收缩后所占尺寸：300-3/7*(200+300-400)=257\n\n\n\n指定flex元素在主轴上的初始大小flex-basis\n当主轴方向是水平时，覆盖水平宽度\n\n当主轴方向是垂直时，覆盖垂直高度\n\n可选值：0% auto 200px 100%  0  \n\n\n\nflex-basis: auto默认值\nflex-basis: 0表示占据最小宽度，会竖起来\nflex缩写flex: 1\nflex: 0\nflex: auto\n改变某个子项的排序位置order\norder: 0当前位置保持不变\n\norder: -1向前排\n\norder: 1向后拍\n\n\n\n控制单独某一个元素交叉轴的布局align-self\n等高布局 内容填充两边也等高\n两列或三列布局  两边固定宽度 中间自适应\nSticky Footer布局 内容空页脚在最底部 内容满也在最底部\n溢出项布局\n\n","slug":"flex布局","date":"2022-02-12T13:46:33.000Z","categories_index":"","tags_index":"CSS,布局","author_index":"LIYUNFU"},{"id":"6436dbae418d43dcb9001fac6bd76e96","title":"布局中的尺寸与位置","content":"相对长度单位&emsp;&emsp;相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应。以下列出了常见相对单位。\n\n\n\n单位\n名称\n\n\n\nem\n在font-size中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小\n\n\nex\n字符“x”的高度\n\n\nch\n数字“0”的宽度\n\n\nrem\n根元素的字体大小\n\n\nlh\n元素的line-height\n\n\nvw\n视窗宽度的1%\n\n\nvh\n视窗高度的1%\n\n\nvmin\n视窗较小尺寸的1%\n\n\nvmax\n视图大尺寸的1%\n\n\nmargin-top传递的现象与解决方案现象：为子元素设置margin-top后，会把父元素一块带下来&lt;div class=\"box1\">\n  &lt;div class=\"box2\">&lt;/div>\n&lt;/div>\n\n.box1&#123;\n  width: 200px;\n  height: 200px;\n  background: pink;\n&#125;\n.box2&#123;\n  width: 100px;\n  height: 100px;\n  background: skyblue;\n  margin-top: 30px;\n&#125;\n\n\n解决方案1： 为父元素加边框\n解决方案2：格式化上下文BFC\n解决方案3：使用padding替代margin\n自适应盒模型的特性当子盒子不写宽度的时候，添加padding，margin，border等，向内缩\n\n标准盒模型和怪异盒模型\n标准盒模型content-box：width，height=content\n怪异盒模型border-box：width，height=content+padding+border\n\n常见清除浮动的方案clear属性 清除上下\nBFC 清除父组件塌陷\n空标签.clearfix::after{}.clearfix::after&#123;\n\tcontent:\"\";\n  clear:both;\n  display:block;\n&#125;\n\n浮动特性注意点\n只会影响后面的元素\n\n文本不会被浮动元素覆盖\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n浮动放不下，会自动换行\n\n\n定位相对定位position：ralative\n相对定位的元素是在文档中的正常位置偏移给定的值\n\n不影响其他元素布局\n\n相对于自身进行偏移\n\n\n绝对定位position：absolute\n脱离标准文档流，不占据空间\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n绝对定位元素相对于最近的非static祖先元素定位，当这样的祖先元素不存在时，则相对于可视区定位\n\n\n固定定位position：fixed粘性定位position：sticky\n粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位\n\n详解display属性display-outside外部值定义自身元素的外部表现，而不影响其内的子元素\n\nblock：表示块级盒子\ninline：表示内联盒子\n\ndisplay-inside内部值定义子元素布局的\n\ntable：带有内部表格布局的块级盒子\n\nflex：带有内部弹性布局的块级盒子\n\ngrid：带有内部网格布局的块级盒子\n\n\nglobal全局值\ninherit：继承父元素的display属性\n\ninitial：不管父元素怎么设定，恢复到浏览器最初时的display属性\n\nunset：unset混合了inherit和initial，如果父元素设值了，就用父元素的设定，如果父元素没有设值，就用浏览器的缺省设定\n\n\n书写模式与逻辑属性writing-mode书写模式\nhorizontal-tb：水平方向自上而下的书写方式\n\nvertical-lr：垂直方向自左而右的书写方式\n\nvertical-rl：垂直方向自右而左的书写方式\n\n\n\nBFC块级格式化上下文概念：\n可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何，都不会影响到外部\n\n触发条件：\nfloat的值不是none\n\nposition的值不是static或relative\n\ndisplay的值是inline-block、table-cel、flex、table-caption或inline-flex\n\noverflow的值不是visible\n\n\nBFC的应用：\n解决margin-top传递问题   在父元素上加\n\n解决纵向margin重叠问题\n\n\n\n\n\n解决浮动高度塌陷  在父元素上加\n\n\n","slug":"布局中的尺寸与位置","date":"2022-02-11T13:28:00.000Z","categories_index":"","tags_index":"布局,css","author_index":"LIYUNFU"},{"id":"72f191bcb7ec59bd5f1454660b2b3dff","title":"西瓜音乐小程序开发第二天","content":"✅ 引入第三方 UI 库 vant✅ 封装 banner 请求✅ 实时获取组件高度解决不同屏幕中的 swiper 样式问题✅ 使用节流函数优化性能\n\n今日完成效果\n\n\n\\\n引入 vantUI 库步骤如下\n 第一步进入微信开发工具，点开详情，勾选使用 npm 模块，并调低基础库，由于当前测试基础库2.22.0无法正常显示 vant 中的van-search标签，遂调低基础库至2.21.2\n\n\n\n 打开终端，初始化package.json并且安装 vant 依赖 npm i @vant/weapp\n\n\n\n\\\n\n 点击工具菜单中的构建 npm，等待构建完成，自动产生miniprogram_npm这就是小程序依赖的包\n\n\n\n\n 最后删除 app.json 中的style:v2防止样式冲突\n\n使用第三方 UI 库\n 在pages/home-music/index.json中导入需要的search组件\n\n&#123;\n  &quot;usingComponents&quot;: &#123;\n    &quot;van-search&quot;: &quot;@vant&#x2F;weapp&#x2F;search&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 在pages/home-music/index.wxml中使用search组件\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n\n这里使搜索框无法输入，绑定了点击方法，使用户点击搜索框跳转到搜索页面，index.js 中实现方法即可，shape属性可以设置为圆角或者方角\n\n&#x2F;**\n  * 事件处理\n  *&#x2F;\n handleSearchClick: function () &#123;\n   wx.navigateTo(&#123;\n     url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n   &#125;);\n &#125;,\n\n\n效果如图\n\n\n\\\n封装 banner 请求新建 service/api_music.jsimport hyRequest from &quot;.&#x2F;index&quot;;\nexport function getBanners() &#123;\n  return hyRequest.get(&quot;&#x2F;banner&quot;, &#123;\n    type: 2,\n  &#125;);\n&#125;\n\n\ntype 的值有四种：0 代表 PC 1 代表 Android 2 代表 Iphone 3 代表 pad\n\n\\\n请求数据并渲染到页面\n 根据官方文档可知，可以通过以下示例获得每次渲染完成的组件的rect\n\n\n\n 新建utils/query-rect.js用以获取组件高度\n\nexport default function (selector) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 获取图片的高度(如何获取组件高度)\n    const query &#x3D; wx.createSelectorQuery();\n    query.select(selector).boundingClientRect();\n    query.exec((res) &#x3D;&gt; &#123;\n      resolve(res);\n    &#125;);\n  &#125;);\n&#125;\n\n\n 在pages/home-music/index.js中定义数据和方法，并调用\n\n&#x2F;&#x2F; pages&#x2F;home-music&#x2F;index.js\nimport &#123; getBanners &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_music&quot;;\nimport queryRect from &quot;..&#x2F;..&#x2F;utils&#x2F;query-rect&quot;;\nimport throttle from &quot;..&#x2F;..&#x2F;utils&#x2F;throttle&quot;;\n\nconst throttleQueryRect &#x3D; throttle(queryRect);\n\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    swiperHeight: 0,\n    banners: &#123;&#125;,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getPageData();\n  &#125;,\n\n  &#x2F;**\n   * 事件处理\n   *&#x2F;\n  handleSearchClick: function () &#123;\n    wx.navigateTo(&#123;\n      url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 网络请求\n   *&#x2F;\n  getPageData: function () &#123;\n    getBanners().then((res) &#x3D;&gt; &#123;\n      this.setData(&#123; banners: res.banners &#125;);\n    &#125;);\n  &#125;,\n\n  handleSwiperImageLoaded: function () &#123;\n    &#x2F;&#x2F; 获取图片的高度\n    throttleQueryRect(&quot;#swiper-img&quot;).then((res) &#x3D;&gt; &#123;\n      const rect &#x3D; res[0];\n      this.setData(&#123;\n        swiperHeight: rect.height,\n      &#125;);\n    &#125;);\n  &#125;,\n&#125;)\n\n\n 在pages/home-music/index.wxml中调用数据，并绑定image加载完成的方法bindonload\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n&lt;!-- 轮播图 --&gt;\n&lt;swiper class&#x3D;&quot;swiper&quot; style&#x3D;&quot;height:&#123;&#123;swiperHeight&#125;&#125;&quot; indicator-dots autoplay circular&gt;\n  &lt;block wx:for&#x3D;&quot;&#123;&#123;banners&#125;&#125;&quot; wx:key&#x3D;&quot;bannerId&quot;&gt;\n    &lt;swiper-item class&#x3D;&quot;swiper-item&quot; &gt;\n      &lt;image id&#x3D;&quot;swiper-img&quot; class&#x3D;&quot;image&quot; mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#123;&#123;item.pic&#125;&#125;&quot;  bindload&#x3D;&quot;handleSwiperImageLoaded&quot; &#x2F;&gt;\n    &lt;&#x2F;swiper-item&gt;\n  &lt;&#x2F;block&gt;\n&lt;&#x2F;swiper&gt;\n\n参数说明:\n\ncircular无限滑动\nmode高度自适应\n\n\n\n\nbindload当image标签加载完成时执行\nindicator-dots显示小圆点\n\n上面用到的节流函数utils/throttle.js\nexport default function throttle(\n  fn,\n  interval &#x3D; 1000,\n  options &#x3D; &#123; leading: true, trailing: false &#125;\n) &#123;\n  &#x2F;&#x2F; 1.记录上一次的开始时间\n  const &#123; leading, trailing, resultCallback &#125; &#x3D; options;\n  let lastTime &#x3D; 0;\n  let timer &#x3D; null;\n\n  &#x2F;&#x2F; 2.事件触发时, 真正执行的函数\n  const _throttle &#x3D; function (...args) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 2.1.获取当前事件触发时的时间\n      const nowTime &#x3D; new Date().getTime();\n      if (!lastTime &amp;&amp; !leading) lastTime &#x3D; nowTime;\n\n      &#x2F;&#x2F; 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数\n      const remainTime &#x3D; interval - (nowTime - lastTime);\n      if (remainTime &lt;&#x3D; 0) &#123;\n        if (timer) &#123;\n          clearTimeout(timer);\n          timer &#x3D; null;\n        &#125;\n\n        &#x2F;&#x2F; 2.3.真正触发函数\n        const result &#x3D; fn.apply(this, args);\n        if (resultCallback) resultCallback(result);\n        resolve(result);\n        &#x2F;&#x2F; 2.4.保留上次触发的时间\n        lastTime &#x3D; nowTime;\n        return;\n      &#125;\n\n      if (trailing &amp;&amp; !timer) &#123;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n          timer &#x3D; null;\n          lastTime &#x3D; !leading ? 0 : new Date().getTime();\n          const result &#x3D; fn.apply(this, args);\n          if (resultCallback) resultCallback(result);\n          resolve(result);\n        &#125;, remainTime);\n      &#125;\n    &#125;);\n  &#125;;\n\n  _throttle.cancel &#x3D; function () &#123;\n    if (timer) clearTimeout(timer);\n    timer &#x3D; null;\n    lastTime &#x3D; 0;\n  &#125;;\n\n  return _throttle;\n&#125;\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第二天","date":"2022-02-10T07:54:45.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"},{"id":"27fc989783c0d00e7c3b706a3747978d","title":"西瓜音乐小程序开发第一天","content":"\n✅ 初始化项目\n✅ 配置 tabbar\n✅ 封装请求函数\n✅ 分层架构二次封装请求函数\n✅ 封装格式化方法 (utils/format.wxs)\n✅ 封装视频列表 item 组件\n✅ 完成视频列表页展示\n今日完成效果如下\n\n\n\\\n初始化项目\n\n\\\n删除无关项目文件\n删除 pages 目录下的 index 和 logs，删除 utils 目录下的 util.js\n初始化 app.js 为\n\n&#x2F;&#x2F; app.js\nApp(&#123;\n\n&#125;)\n\n\n初始化 app.json 为\n\n&#123;\n  &quot;pages&quot;: [\n\n  ],\n  &quot;window&quot;: &#123;\n    &quot;backgroundTextStyle&quot;: &quot;light&quot;,\n    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,\n    &quot;navigationBarTitleText&quot;: &quot;Weixin&quot;,\n    &quot;navigationBarTextStyle&quot;: &quot;black&quot;\n  &#125;,\n  &quot;style&quot;: &quot;v2&quot;,\n  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,\n  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;\n&#125;\n\n\n初始化 app.wxss 为\n\n&#x2F;**app.wxss**&#x2F;\n\n\n目前为止编译器/模拟器会报错\n\n\n\\\n配置 tabbar新建两个页面\n 在 pages 右键创建文件夹home-music和home-video\n 在home-video和home-music上右键新建page为index\n\n\n\n\n 小程序开发工具会自动在目录下创建四个文件，并自动在app.json中添加 url\n \n\n\n\n\n \n\n导入静态资源 assets\n 在文件管理器中打开项目，复制已经准备好的 assets 资源到根目录\n \n\n\\\n在app.json中配置 tabbar&quot;tabBar&quot;: &#123;\n    &quot;list&quot;: [\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-music&#x2F;index&quot;,\n        &quot;text&quot;: &quot;音乐&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_active.png&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-video&#x2F;index&quot;,\n        &quot;text&quot;: &quot;视频&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_active.png&quot;\n      &#125;\n    ]\n  &#125;,\n\n\n\n效果\n\n\n\\\n封装请求函数由于微信小程序给我们提供的wx.request请求许多参数都可以复用，所以可以封装一个请求函数\n\n 在根目录下新建service文件夹\n 新建service/index.js\n\nconst BASE_URL &#x3D; &quot;http:&#x2F;&#x2F;123.207.32.32:9001&quot;;\nclass HYRequest &#123;\n  request(url, method, params) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      wx.request(&#123;\n        url: BASE_URL + url,\n        method: method,\n        data: params,\n        success: function (res) &#123;\n          resolve(res.data);\n        &#125;,\n        fail: function (err) &#123;\n          reject(err);\n        &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  get(url, params) &#123;\n    return this.request(url, &quot;GET&quot;, params);\n  &#125;\n  post(url, data) &#123;\n    return this.request(url, &quot;POST&quot;, data);\n  &#125;\n&#125;\n\nconst hyRequest &#x3D; new HYRequest();\nexport default hyRequest;\n\n二次封装请求函数某些动作需要反复调用请求函数，但是有不变的参数，没必要每次传递，可以再封装一次\n\n 新建service/api_video.js\n\nimport hyRequest from &#39;.&#x2F;index&#39;\nexport function getTopMV(offset,limit&#x3D;10)&#123;\n  return hyRequest.get(&#39;&#x2F;top&#x2F;mv&#39;,&#123;\n    offset,\n    limit\n  &#125;)\n&#125;\n\n\n 由于我们的 api 后台需要接收两个参数，一个是偏移量，一个是数量，我们默认每次截取十个即可\n\n调用请求获得数据\n 在home-video/index.js中引入 getTopMV 方法\n\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\n\n\n 在home-video/index.js的 data 中定义两个变量\n\ndata: &#123;\n   topMVs: [],   &#x2F;&#x2F;用以保存请求到的数据列表\n   hasMore: true,  &#x2F;&#x2F; 判断还有没有更多数据能够请求\n &#125;,\n\n\n 封装专属于home-video的网络请求方法，用以在不同操作下复用\n\n&#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n\n 当生命周期 onLoad 执行时，调用请求方法\n\n&#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n\n 当下拉刷新时调用请求方法\n\n&#x2F;**\n  * 下拉刷新\n  *&#x2F;\n onPullDownRefresh: function () &#123;\n   this.getTopMVData(0);\n &#125;,\n\n\n 当页面触底时调用请求方法\n\n&#x2F;**\n * 页面上拉触底事件的处理函数\n *&#x2F;\nonReachBottom: function () &#123;\n  this.getTopMVData(this.data.topMVs.length);\n&#125;,\n\n\n home-video/index.js完整代码\n\n&#x2F;&#x2F; pages&#x2F;home-video&#x2F;index.js\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    topMVs: [],\n    hasMore: true,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n  &#x2F;**\n   * 封装事件处理的方法\n   *&#x2F;\n  handleVideoItemClick: function (event) &#123;\n    const id &#x3D; event.currentTarget.dataset.item.id;\n\n    &#x2F;&#x2F; 页面跳转\n    wx.navigateTo(&#123;\n      url: &#96;&#x2F;pages&#x2F;detail-video&#x2F;index?id&#x3D;$&#123;id&#125;&#96;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 下拉刷新\n   *&#x2F;\n  onPullDownRefresh: function () &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面初次渲染完成\n   *&#x2F;\n  onReady: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面显示\n   *&#x2F;\n  onShow: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面隐藏\n   *&#x2F;\n  onHide: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面卸载\n   *&#x2F;\n  onUnload: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面相关事件处理函数--监听用户下拉动作\n   *&#x2F;\n  onPullDownRefresh: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面上拉触底事件的处理函数\n   *&#x2F;\n  onReachBottom: function () &#123;\n    this.getTopMVData(this.data.topMVs.length);\n  &#125;,\n\n  &#x2F;**\n   * 用户点击右上角分享\n   *&#x2F;\n  onShareAppMessage: function () &#123;&#125;,\n&#125;);\n\n遍历数据到页面前面我们已经请求到数据了，可以直接在home-video/index.wxml中调用，由于列表的 item 也可以复用，我们将它封装成一个 component\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;!-- &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt; --&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\\\n封装 item 组件\n 在根目录下新建文件夹components/video-item-v1，右键video-item-v1新建component为 index\n \n\n\n\n\n 可以看到component的 index.js 和普通组件不同，其中有一个专门接收父组件传递过来数据的函数\n\n&#x2F;**\n  * 组件的属性列表\n  *&#x2F;\n properties: &#123;\n\n &#125;,\n\n\n 可以在这儿定义接收的数据，就可以直接在 wxml 页面中使用了\n\n&#x2F;**\n   * 组件的属性列表\n   *&#x2F;\n  properties: &#123;\n    item:&#123;\n      type:Object,\n      default:&#123;&#125;\n    &#125;\n  &#125;,\n\n\n 由于服务器返回的数据里面播放量和 时间都需要转换格式，我们可以在 utils 目录下定义一个format.wxs用于格式化数据，wxml 中只能调用 wxs 定义的方法\n\nfunction formatCount(count) &#123;\n  var counter &#x3D; parseInt(count);\n  if (counter &gt; 100000000) &#123;\n    return (counter &#x2F; 100000000).toFixed(1) + &quot;亿&quot;;\n  &#125; else if (counter &gt; 10000) &#123;\n    return (counter &#x2F; 10000).toFixed(1) + &quot;万&quot;;\n  &#125; else &#123;\n    return counter + &quot;&quot;;\n  &#125;\n&#125;\n\nfunction padLeftZero(time) &#123;\n  time &#x3D; time + &quot;&quot;;\n  return (&quot;00&quot; + time).slice(time.length);\n&#125;\nfunction formatDuration(duration) &#123;\n  duration &#x3D; duration &#x2F; 1000;\n\n  var minute &#x3D; Math.floor(duration &#x2F; 60);\n  &#x2F;&#x2F; 计算秒钟\n  var second &#x3D; duration % 60;\n\n  return padLeftZero(minute) + &quot;:&quot; + padLeftZero(second);\n&#125;\n&#x2F;&#x2F; commonjs\nmodule.exports &#x3D; &#123;\n  formatCount: formatCount,\n  formatDuration: formatDuration,\n&#125;;\n\n\n 现在我们可以在 wxml 中使用父组件传递过来的数据了\n\n&lt;!--components&#x2F;video-item-v1&#x2F;index.wxml--&gt;\n&lt;wxs src&#x3D;&quot;..&#x2F;..&#x2F;utils&#x2F;format.wxs&quot; module&#x3D;&quot;format&quot;&gt;&lt;&#x2F;wxs&gt;\n&lt;view class&#x3D;&quot;item&quot;&gt;\n  &lt;view class&#x3D;&quot;album&quot;&gt;\n    &lt;image class&#x3D;&quot;images&quot; src&#x3D;&quot;&#123;&#123;item.cover&#125;&#125;&quot; mode&#x3D;&quot;widthFix&quot; &#x2F;&gt;\n    &lt;view class&#x3D;&quot;info&quot;&gt;\n      &lt;view class&#x3D;&quot;count&quot;&gt;&#123;&#123;format.formatCount(item.playCount)&#125;&#125;&lt;&#x2F;view&gt;\n      &lt;view class&#x3D;&quot;duration&quot;&gt;&#123;&#123;format.formatDuration(item.mv.videos[0].duration)&#125;&#125;&lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class&#x3D;&quot;content&quot;&gt;\n    &#123;&#123;item.name&#125;&#125; - &#123;&#123;item.artisName&#125;&#125;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\n 为 item 组件配置样式\n\n&#x2F;* components&#x2F;video-item-v1&#x2F;index.wxss *&#x2F;\n.item &#123;\n  width: 100%;\n  margin-bottom: 30rpx;\n&#125;\n\n.album &#123;\n  position: relative;\n  border-radius: 12rpx;\n  overflow: hidden;\n  display: flex;\n&#125;\n\n.album .image &#123;\n  width: 100%;\n&#125;\n\n.info &#123;\n  position: absolute;\n  padding: 0 10rpx;\n  box-sizing: border-box;\n  width: 100%;\n  bottom: 8rpx;\n  display: flex;\n  justify-content: space-between;\n  color: #fff;\n  font-size: 24rpx;\n&#125;\n\n.info .count &#123;\n  padding-left: 36rpx;\n  position: relative;\n&#125;\n\n.info .count::before &#123;\n  content: &quot;&quot;;\n  position: absolute;\n  left: -2rpx;\n  top: 4rpx;\n  width: 30rpx;\n  height: 24rpx;\n  background-size: cover;\n  background-image: url(&quot;data:image&#x2F;jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAYCAQAAABHYIU0AAAM82lDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY0dyYXlHYW1tYTJfMgAAWIWlVwdYU8kWnluS0BJ6lRI60gwoXUqkBpBeBFGJIZBACDEFAbEhiyu4dhHBsqKiKIsdgcWGBQtrB7sLuigo6+IqNixvEopYdt&#x2F;7vnfzzb3&#x2F;nXPOnDpnbgBQ5TAFAh4KAMjki4WBUfSEKQmJVNJdIAe0gTKwB8pMlkhAj4gIhSyAn8Vng2+uV+0AkT6v2UnX+pb+rxchhS1iwedxOHJTRKxMAJCJAJC6WQKhGAB5MzhvOlsskOIgiDUyYqJ8IU4CQE5pSFZ6GQWy+Wwhl0UNFDJzqYHMzEwm1dHekRohzErl8r5j9f97ZfIkI7rhUBJlRIfApz20vzCF6SfFrhDvZzH9o4fwk2xuXBjEPgCgJgLxpCiIgyGeKcmIpUNsC3FNqjAgFmIviG9yJEFSPAEATCuPExMPsSHEwfyZYeEQu0PMYYl8EyG2griSw2ZI8wRjhp3nihkxEEN92DNhVpSU3xoAfGIK289&#x2F;cB5PzcgKkdpgAvFBUXa0&#x2F;7DNeRzfsEFdeHs6MzgCYguIX7J5gVGD6xD0BOII6ZrwneDH54WFDvpFKGWLZP7Cd0K7mBMjzZkjAEQTsTAmatA2YkwqN4ABcQDEORxhUNSgv8SjAp6szmBMiO+FkqjYQR9JAWx+rHRNaV0sYAr9AwdjRWoCcQgTsEEWmAnvLMAHnYAKRIALsmUoDTBBJhxUaIEtHIGQiw+HEHKIQIaMQwi6RujDElIZAaRkgVTIyYNyw7NUkALlB+Wka2TBIX2Trtstm2MN6bOHw9dwO5DANw7ohXQORJNBh2wmB9qXCZ++cFYCaWkQj9YyKB8hs3XQBuqQ9T1DWrJktjBH5D7b5gvpfJAHZ0TDnuHaOA0fD4cHHop74jSZlBBy5AI72fxE2dyw1s+eS33rGdE6C9o62vvR8RqO4QkoJYbvPOghfyg+ImjNeyiTMST9lZ8r9CRWAkHpskjG9KoRK6gFwhlc1qXlff+StW+1232Rt&#x2F;DRdSGrlJRv6gLqIlwlXCbcJ1wHVPj8g9BG6IboDuEu&#x2F;N36blSyRmKQBkfWSAWwv8gNG3LyZFq+tfNzzgbX+WoFBBvhpMtWkVIz4eDKeEQj+ZNALIb3VJm03Ve5C&#x2F;xab0t+kw6gti89fg5Qa1Qazn6Odhten3RNqSU&#x2F;lb9CTyCYXpU&#x2F;wBZ8pkrzwF4c9ioMFNjS9tJ6adtoNbQXtPufOWg3aH&#x2F;S2mhbIOUptho7hB3BGrBGrBVQ4VsjdgJrkKEarAn+9v1Dhad9p8KlFcMaqmgpVTxUU6Nrf3Rk6aOiJeUfjnD6P9Tr6IqRZux&#x2F;s2j0Ol92BPbnXUcxpThQSBRrihOFTkEoxvDnSPGByJRiQgmlaENqEMWS4kcZMxKP4VrnDWWY+8X+HrQ4AVKHK4Ev6y5MyCnlYA75+7WP1C+8lHrGHb2rEDLcVdxRPeF7vYj6xc6KhbJcMFsmL5Ltdr5MTvBF&#x2F;YlkXQjOIFNlOfyObbgh7oAzYAcKB1ScjjvhPkN4sCsN9yVZpnBvSPXC&#x2F;XBXaR&#x2F;7oi+w&#x2F;qv1o3cGm+hOtCT6Ey0&#x2F;04l+xCBiAHw6SOeJ44jBELtJucTsHLH0kPfNEuQKuWkcMZUOv3LYVAafZW9LdaQ5wNNN+s00+CnwIlL2LYRotbIkwuzBOVx6IwAF+D2lAXThqWoKT2s7qNUFeMAz0x+ed+EgBuZ1OvSDA+0Wwsjmg4WgCJSAFWAtKAebwTZQDWrBfnAYNMEeewZcAJdBG7gDz5Mu8BT0gVdgAEEQEkJG1BFdxAgxR2wQR8QV8UL8kVAkCklAkpE0hI9IkHxkEVKCrELKkS1INbIPaUBOIOeQK8gtpBPpQf5G3qEYqoRqoAaoBToOdUXpaAgag05D09BZaB5aiC5Dy9BKtAatQ0+gF9A2tAN9ivZjAFPEtDBjzA5zxXyxcCwRS8WE2DysGCvFKrFa2ANasGtYB9aLvcWJuDpOxe1gFoPwWJyFz8Ln4UvxcnwnXoefwq&#x2F;hnXgf&#x2F;pFAJugTbAjuBAZhCiGNMJtQRCglVBEOEU7DDt1FeEUkErVgflxg3hKI6cQ5xKXEjcQ9xOPEK8SHxH4SiaRLsiF5ksJJTJKYVERaT6ohHSNdJXWR3sgpyhnJOcoFyCXK8eUK5Erldskdlbsq91huQF5F3lzeXT5cPkU+V365&#x2F;Db5RvlL8l3yAwqqCpYKngoxCukKCxXKFGoVTivcVXihqKhoouimGKnIVVygWKa4V&#x2F;GsYqfiWyU1JWslX6UkJYnSMqUdSseVbim9IJPJFmQfciJZTF5GriafJN8nv6GoU+wpDEoKZT6lglJHuUp5piyvbK5MV56unKdcqnxA+ZJyr4q8ioWKrwpTZZ5KhUqDyg2VflV1VQfVcNVM1aWqu1TPqXarkdQs1PzVUtQK1baqnVR7qI6pm6r7qrPUF6lvUz+t3qVB1LDUYGika5Ro&#x2F;KJxUaNPU01zgmacZo5mheYRzQ4tTMtCi6HF01qutV+rXeudtoE2XZutvUS7Vvuq9mudMTo+OmydYp09Om0673Spuv66GbordQ&#x2F;r3tPD9az1IvVm623SO63XO0ZjjMcY1pjiMfvH3NZH9a31o&#x2F;Tn6G&#x2F;Vb9XvNzA0CDQQGKw3OGnQa6hl6GOYbrjG8Khhj5G6kZcR12iN0TGjJ1RNKp3Ko5ZRT1H7jPWNg4wlxluMLxoPmFiaxJoUmOwxuWeqYOpqmmq6xrTZtM&#x2F;MyGyyWb7ZbrPb5vLmruYc83XmLeavLSwt4i0WWxy26LbUsWRY5lnutrxrRbbytpplVWl1fSxxrOvYjLEbx162Rq2drDnWFdaXbFAbZxuuzUabK7YEWzdbvm2l7Q07JTu6XbbdbrtOey37UPsC+8P2z8aZjUsct3Jcy7iPNCcaD55udxzUHIIdChwaHf52tHZkOVY4Xh9PHh8wfv74+vHPJ9hMYE&#x2F;YNOGmk7rTZKfFTs1OH5xdnIXOtc49LmYuyS4bXG64arhGuC51PetGcJvkNt+tye2tu7O72H2&#x2F;+18edh4ZHrs8uidaTmRP3DbxoaeJJ9Nzi2eHF9Ur2etnrw5vY2+md6X3Ax9TnxSfKp&#x2F;H9LH0dHoN&#x2F;dkk2iThpEOTXvu6+871Pe6H+QX6Fftd9Ffzj&#x2F;Uv978fYBKQFrA7oC&#x2F;QKXBO4PEgQlBI0MqgGwwDBotRzegLdgmeG3wqRCkkOqQ85EGodagwtHEyOjl48urJd8PMw&#x2F;hhh8NBOCN8dfi9CMuIWRG&#x2F;RhIjIyIrIh9FOUTlR7VEq0fPiN4V&#x2F;SpmUszymDuxVrGS2OY45bikuOq41&#x2F;F+8aviO6aMmzJ3yoUEvQRuQn0iKTEusSqxf6r&#x2F;1LVTu5KckoqS2qdZTsuZdm663nTe9CMzlGcwZxxIJiTHJ+9Kfs8MZ1Yy+2cyZm6Y2cfyZa1jPU3xSVmT0sP2ZK9iP071TF2V2p3mmbY6rYfjzSnl9HJ9ueXc5+lB6ZvTX2eEZ+zI+MSL5+3JlMtMzmzgq&#x2F;Ez+KeyDLNysq4IbARFgo5Z7rPWzuoThgirRIhomqherAH&#x2F;YLZKrCQ&#x2F;SDqzvbIrst&#x2F;Mjpt9IEc1h5&#x2F;TmmuduyT3cV5A3vY5+BzWnOZ84&#x2F;yF+Z1z6XO3zEPmzZzXPN90fuH8rgWBC3YuVFiYsfC3AlrBqoKXi+IXNRYaFC4ofPhD4A+7iyhFwqIbiz0Wb&#x2F;4R&#x2F;5H748Ul45esX&#x2F;KxOKX4fAmtpLTk&#x2F;VLW0vM&#x2F;OfxU9tOnZanLLi53Xr5pBXEFf0X7Su+VO1eprspb9XD15NV1a6hrite8XDtj7bnSCaWb1ymsk6zrKAstq19vtn7F+vflnPK2ikkVezbob1iy4fXGlI1XN&#x2F;lsqt1ssLlk87ufuT&#x2F;f3BK4pa7SorJ0K3Fr9tZH2+K2tWx33V5dpVdVUvVhB39Hx86onaeqXaqrd+nvWr4b3S3Z3VOTVHP5F79f6mvtarfs0dpTshfslex9si95X&#x2F;v+kP3NB1wP1B40P7jhkPqh4jqkLreu7zDncEd9Qv2VhuCG5kaPxkO&#x2F;2v+6o8m4qeKI5pHlRxWOFh79dCzvWP9xwfHeE2knHjbPaL5zcsrJ66ciT108HXL67JmAMydb6C3HznqebTrnfq7hvOv5wxecL9S1OrUe+s3pt0MXnS&#x2F;WXXK5VH&#x2F;Z7XLjlYlXjl71vnrimt+1M9cZ1y+0hbVdaY9tv3kj6UbHzZSb3bd4t57fzr49cGcB&#x2F;Igvvqdyr&#x2F;S+&#x2F;v3K38f+vqfDueNIp19n64PoB3cesh4+&#x2F;UP0x&#x2F;uuwkfkR6WPjR5Xdzt2N&#x2F;UE9Fx+MvVJ11PB04Heoj9V&#x2F;9zwzOrZwb98&#x2F;mrtm9LX9Vz4&#x2F;NPfS1&#x2F;ovtjxcsLL5v6I&#x2F;vuvMl8NvC5+o&#x2F;tm51vXty3v4t89Hpj9nvS+7MPYD40fQz7e&#x2F;ZT56dN&#x2F;AC1d8BzqtvWAAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAAeoAMABAAAAAEAAAAYAAAAAGbJ4J8AAAElSURBVDgRnZQxTsNAEEX&#x2F;WFGUC6RDEEGFREkPihEVokoVDkDFAWgISsUZuAIFQjQUFE5Ni1NEhEjQxQegy2fsFPHKu&#x2F;Zutpr5&#x2F;u&#x2F;vFOsBwDNOVhkDjroTxlA0DqBMayxMcMJfGeEH1CyfI9jlWHYwAZcaN&#x2F;Rhyh5eKbWM0FXxu&#x2F;zBq56rqxsVVt+BN7kFsYY3YlDlgPnIJx40JTlgHGOAT96zUxfggnOmgxFSXrjxOjin9vHKF&#x2F;bsAU1wTl1iynMb7gPrG8ZqW&#x2F;gZh&#x2F;Jug1s2saR94UbeSr1R1o39hzscuVHAdfMHZriVhXFRpXHAcl1xWoS6sS12U1rDYooeXUFEyNTa+AtU4nIiayHFKR&#x2F;YDlpDexgrnIJ9c6sFdH0N0P2ZbLd6&#x2F;wF85hyuQTMxjwAAAABJRU5ErkJggg&#x3D;&#x3D;&quot;);\n&#125;\n\n.content &#123;\n  margin-top: 10rpx;\n  font-size: 28rpx;\n\n  &#x2F;* 显示两行 *&#x2F;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  display: -moz-box;\n  -moz-line-clamp: 2;\n  -moz-box-orient: vertical;\n  word-wrap: break-word;\n  word-break: break-all;\n  white-space: normal;\n  overflow: hidden;\n&#125;\n\n父组件引入子组件\n 在home-video/index.json中引入子组件\n\n&#123;\n  &quot;enablePullDownRefresh&quot;: true,\n  &quot;backgroundTextStyle&quot;: &quot;dark&quot;,\n  &quot;usingComponents&quot;: &#123;\n    &quot;video-item-v1&quot;: &quot;&#x2F;components&#x2F;video-item-v1&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 改写home-video/index.wxml使用组件\n\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n父组件传值就是通过data-item传递的\n\n\\\n\n 最后我们还需要修改home-video/index.wxss\n\n&#x2F;* pages&#x2F;home-video&#x2F;index.wxss *&#x2F;\n.video &#123;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n&#125;\n\n.item &#123;\n  width: 48%;\n&#125;\n\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第一天","date":"2022-02-10T07:50:55.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"}]