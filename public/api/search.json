[{"id":"962830b6bd2196f70a73107af4c3efd5","title":"Flutter01环境配置","content":"安装flutterflutter3 还不支持交叉编译\n学了一段时间的flutter准备从0开始记录flutter3的学习过程\n安装SDK进入https://docs.flutter.dev/get-started/install/windows 下载压缩包，将压缩包解压到C盘根目录下，不要解压到Program files或Program Files(x86)这两个高权限目录下。\n\n配置环境变量将flutter目录下bin的地址填入环境变量path中，重启电脑或注销。\n\n查看是否配置成功命令行键入flutter查看是否配置成功\n报错\n\n使用git clone -b stable https://github.com/flutter/flutter.git重新克隆下来，将原先的删除\n安装Dart SDK键入flutter等待dart sdk下载完成\n\n\\\n安装其他键入flutter doctor查看还有以下几种没有解决的，下面我们一步一步来解决。\n\n安装chrome进入https://www.google.com/chrome/ 下载安装即可\n安装visual studio 2022进入https://visualstudio.microsoft.com/zh-hans/downloads/ 下载社区版即可，勾选使用C++的桌面开发点击安装，等待安装完成。\n\n安装Andriod Studio进入https://developer.android.com/studio 下载，勾选Andriod Virtual Device，一路默认勾选，等待安装完成，如出现红色，尝试科学上网。\n\n安装Andriod SDK选择SDK Manager，勾选Andriod SDK Command-line Tools，如果是需要的话可以将下面勾选的HAXM一起安装，\n\n\n安装安卓虚拟机选择Virtual Device Manager，选择Pixel 5，下一步，选择推荐的安卓版本R下一步 等待安装成功。\n\n\n\n查看是否配置成功运行flutter doctor\n\n其他问题解决Visual Studio报错这个错是由于2022这个版本出现的错误，可以进入https://github.com/flutter/flutter/issues/102451 查看，只有临时解决方案，根据指引下载vswhere.exe发放入指定目录下，再使用flutter doctor测试。\n\n添加flutter国内镜像源给flutter添加国内的镜像，添加到环境变量中\n\n\n\\\n解决信号灯超时时间已到(网络问题)https://stackoverflow.com/questions/71063780/how-is-http-host-availability-in-flutter-2-10 根据回答，修改maven地址。\n\n测试：非常棒，可以愉快开发了。\n\n","slug":"flutter01","date":"2022-05-28T11:49:05.000Z","categories_index":"","tags_index":"flutter,多端","author_index":"LIYUNFU"},{"id":"52748ea8c7aacb653b9bc3a082a7560f","title":"基于koa-generator搭建通用服务端","content":"安装koa-generator全局安装koa-generatornpm i koa-generator -g\n\n初始化项目koa2 goudong-server \n\n进入并安装依赖cd goudong-server \nnpm install\n\n\n\n改造项目环境\n在根目录下新建src目录\n\n将public 、routes 、views 、app.js拖入src目录\n\n修改bin/www中的var app = require(&#39;../app&#39;);为var app = require(&#39;../src/app&#39;);\n\n改造后目录\n\n```shell|- bin  |- www|-node_modules|-src  |-public  |-routes  |-views  |-app.js|-package.json\n\n- 在&#96;src&#96;目录下创建四个目录&#96;controller&#96; 、&#96;db&#96; 、&#96;middleware&#96;、&#96;models&#96;\n\n\n\n\n\n## 实现登录功能\n\n### 配置开发环境\n\n#### 安装&#96;koa-generic-session&#96;依赖\n\n&#96;&#96;&#96;shell\nni koa-generic-session \n\n使用const session = require('koa-generic-session')\n\n//session配置\napp.keys = ['liyunfuAAA'] //密钥用于加密\napp.use(session(&#123;\n  //配置cookie\n  cookie: &#123;\n    path: '/',\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000\n  &#125;\n&#125;))\n\n\n\n跨域安装koa2-cors依赖ni koa2-cors\n\n使用const cors = require('koa2-cors')\n\n//cors配置\napp.use(cors(&#123;\n  origin: 'http://localhost:8080',  //前端origin\n  credentials: true //允许跨域带cookie\n&#125;))\n\n连接数据库安装mongooseni mongoose\n\n在db目录下新建db.js/**\n * @description mongoose 连接数据库\n * @author liyunfu\n */\nconst mongoose = require('mongoose')\n\nconst DB_URL = 'mongodb://root:example@47.99.147.11.27017/jingdong?authSource=admin'\n\n// 开始连接\nmongoose.connect(DB_URL, &#123;\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n&#125;)\n\n// 连接对象\nconst db = mongoose.connection\n\ndb.on('error', err => &#123;\n  console.error('mongoose connect error', err)\n&#125;)\ndb.once('open', () => &#123;\n  console.log('mongoose 连接成功')\n&#125;)\n\nmodule.exports = mongoose\n\n\n\n设计Schema和Model\n在models目录下新建User.js\n/**\n * @description user Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true,\n    unique: true\n  &#125;,\n  password: String\n&#125;, &#123; timestamps: true &#125;)\n\nconst User = mongoose.model('user', Schema)\n\nmodule.exports = User\n在models下新建Address.js\n/**\n * @description Address Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  city: String,\n  department: String,\n  houseNumber: String,\n  name: String,\n  phone: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Address = mongoose.model('address', Schema)\n\nmodule.exports = Address\n在models下新建Shop.js\n/**\n * @description Shop Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  expressLimit: &#123;\n    type: Number,\n    default: 0\n  &#125;,\n  expressPrice: Number,\n  slogan: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Shop = mongoose.model('shop', Schema)\n\nmodule.exports = Shop\n在models下新建Product.js\n/**\n * @description Product Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  ShopId: &#123;\n    type: String,\n    require: true\n  &#125;,\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  price: Number,\n  oldPrice: Number,\n  tabs: [String]  //示例 tabs:['all','seckill']\n&#125;, &#123; timestamps: true &#125;)\n\nconst Product = mongoose.model('product', Schema)\n\nmodule.exports = Product\n在models下新建Order.js \n/**\n * @description Order Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  shopId: String,\n  shopName: String,\n\n  idCanceled: &#123;\n    type: Boolean,\n    default: false\n  &#125;,\n  address: &#123;\n    username: String,\n    city: String,\n    department: String,\n    houseNumber: String,\n    name: String,\n    phone: String\n  &#125;,\n  products: [\n    &#123;\n      product: &#123;\n        shopId: &#123;\n          type: String,\n          require: true\n        &#125;,\n        name: String,\n        imgUrl: String,\n        sales: Number,\n        price: Number,\n        oldPrice: Number,\n        tabs: [String]\n      &#125;,\n      orderSales: Number\n    &#125;\n  ]\n&#125;, &#123; timestamps: true &#125;)\n\nconst Order = mongoose.model('order', Schema)\n\nmodule.exports = Order\n在models 下新建index.js \n/**\n * @description Model 入口文件\n * @author liyunfu\n */\nconst Address = require('./Address')\nconst Order = require('./Order')\nconst Product = require('./Product')\nconst Shop = require('./Shop')\nconst User = require(\"./User\")\n\nmodule.exports = &#123;\n  Address,\n  Order,\n  Product,\n  Shop,\n  User\n&#125;\n\n标准化请求成功与失败的响应信息\n在res-model 下新建ErrorModel.js\n/**\n * @description 错误返回的数据结构\n * @author liyunfu\n */\n\nclass ErrorModel &#123;\n  constructor(errno = -1, message = 'error') &#123;\n    this.errno = errno\n    this.message = message\n  &#125;\n&#125;\n\nmodule.exports = ErrorModel\n在res-model 下新建SuccessModel.js\n/**\n * @description 成功返回的数据类型\n * @author liyunfu\n */\n\nclass SuccessModel &#123;\n  constructor(data) &#123;\n    this.errno = 0\n    if (data !== null) &#123;\n      this.data = data\n    &#125;\n  &#125;\n&#125;\n\nmodule.exports = SuccessModel\n在res-model 下新建入口文件index.js\n/**\n * @description 返回数据类型 入口文件\n * @author liyunfu\n */\nconst SuccessModel = require('./SuccessModel')\nconst ErrorModel = require('./ErrorModel')\n\nmodule.exports = &#123; SuccessModel, ErrorModel &#125;\n\n编写登录验证中间件\n在middleware 下新建loginCheck.js\n/**\n * @description 登录验证中间件\n * @author liyunfu\n */\n\nconst &#123; ErrorModel &#125; = require('../res-model/index')\n\nmodule.exports = async (ctx, next) => &#123;\n  const session = ctx.session\n\n  if (session &amp;&amp; session.userInfo) &#123;\n    await next()\n    return\n  &#125;\n  ctx.body = new ErrorModel(10003, '中间件登录验证失败')\n&#125;\n\n用户操作接口\n在controller 下新建 user.js\n/**\n * @description user controller\n * @author liyunfu\n */\n\nconst &#123; User &#125; = require('../models/index')\n\n/**\n * 注册方法\n * @param &#123;Object&#125; userInfo 用户信息\n * @returns \n */\nasync function register(userInfo = &#123;&#125;) &#123;\n  // 注意验证一下username unique\n  const newUser = await User.create(userInfo)\n  return newUser\n&#125;\n\nasync function login(username, password) &#123;\n  const user = await User.findOne(&#123; username, password &#125;)\n  if (user != null) &#123;\n    // 登录成功\n    return true\n  &#125;\n  return false\n&#125;\n\nmodule.exports = &#123;\n  register, login\n&#125;\n在routes 下新建users.js\nconst router = require('koa-router')()\n\n\nconst &#123; register, login &#125; = require('../controller/user')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user')\n\n// 注册\nrouter.post('/register', async function (ctx, next) &#123;\n  const userInfo = ctx.request.body\n  try &#123;\n    await register(userInfo)\n    // 返回成功\n    ctx.body = new SuccessModel()\n  &#125; catch (ex) &#123;\n    console.log(ex)\n    // 返回失败\n    ctx.body = new ErrorModel(10001, `注册失败 - $&#123;ex.message&#125;`)\n  &#125;\n&#125;)\n\n// 登录\nrouter.post('/login', async (ctx, next) => &#123;\n  const &#123; username, password &#125; = ctx.request.body\n  // 查询单个用户\n  const res = await login(username, password)\n\n  if (res) &#123;\n    // 登录成功\n    ctx.session.userInfo = &#123; username &#125;  //设置session\n\n    ctx.body = new SuccessModel()\n  &#125; else &#123;\n    ctx.body = new ErrorModel(10002, `登录验证失败`)\n  &#125;\n&#125;)\n\nrouter.get('/info', loginCheck, async function (ctx, next) &#123;\n  // 加了loginCheck之后，因为保证了必须登录\n  const session = ctx.session\n  ctx.body = new SuccessModel(session.userInfo)\n&#125;)\nmodule.exports = router\n\n地址操作接口\n在controller 下新建address.js\n/**\n * @description address controller\n * @author liyunfu\n */\n\nconst &#123; Address &#125; = require('../models/index')\n\n/**\n * 创建地址 \n * @param &#123;string&#125; username 用户名\n * @param &#123;Object&#125; data 地址的详细信息\n * @returns \n */\nasync function createAddress(username, data) &#123;\n  const address = await Address.create(&#123; username, ...data &#125;)\n\n  return address\n&#125;\n\n/**\n * 获取地址列表\n * @param &#123;string&#125; username 用户名\n * @returns \n */\nasync function getAddressList(username) &#123;\n  const list = await Address.find(&#123; username &#125;).sort(&#123; updatedAt: -1 &#125;)\n  return list\n&#125;\n\n/**\n * 获取单个收获地址\n * @param &#123;string&#125; id id\n * @returns \n */\nasync function getAddressById(id) &#123;\n  const address = await Address.findById(id)\n  return address\n&#125;\n\nasync function updateAddress(id, username, data) &#123;\n  const address = await Address.findOneAndUpdate(\n    &#123;\n      // 查询条件\n      _id: id,\n      username,\n    &#125;,\n    &#123;\n      username, ...data\n    &#125;,\n    &#123;\n      new: true  //返回更新之后的最新数据，默认时false，返回更新之前的数据\n    &#125;\n  )\n  return address\n&#125;\n\nmodule.exports = &#123;\n  createAddress,\n  getAddressList,\n  getAddressById,\n  updateAddress\n&#125;\n在routes 下新建address.js\n/**\n * @description address router\n * @author liyunfu\n */\n\nconst router = require('koa-router')()\nconst &#123; createAddress, getAddressList, getAddressById, updateAddress &#125; = require('../controller/address')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user/address')\n\n// 创建收货地址\nrouter.post('/', loginCheck, async (ctx, next) => &#123;\n  // 获取用户信息\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  const data = ctx.request.body\n\n  // 创建数据\n  try &#123;\n    const newAddress = await createAddress(username, data)\n    ctx.body = new SuccessModel(newAddress)\n  &#125; catch (error) &#123;\n    console.log(error)\n    ctx.body = new ErrorModel(10004, '创建收货地址失败')\n  &#125;\n&#125;)\n\n// 获取收货地址列表\nrouter.get('/', loginCheck, async (ctx, next) => &#123;\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 获取列表\n  const list = await getAddressList(username)\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 获取单个收获地址\nrouter.get('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const address = await getAddressById(id)\n\n  ctx.body = new SuccessModel(address)\n&#125;)\n\n// 更新收货地址\nrouter.patch('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const data = ctx.request.body\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  // 更新\n  const newAddress = await updateAddress(id, username, data)\n  ctx.body = new SuccessModel(newAddress)\n&#125;)\n\nmodule.exports = router\n\n商店商品接口\n在controller 下新建shop.js\n/**\n * @description shop controller\n * @author liyunfu\n */\n\nconst &#123; &#125; = require('../models/index')\n\n// 热门商店列表\nasync function getHotList() &#123;\n  const list = await Shop.find().sort(&#123; _id: -1 &#125;) //逆序\n  return list\n&#125;\n\n// 根据id获取单个商店信息\nasync function getShopInfo(id) &#123;\n  const shop = await Shop.findById(id)\n  return shop\n&#125;\n\n// 根据商店id获取商品\nasync function getProductByShopId(id, tab = '') &#123;\n  const pList = await Product.find(&#123;\n    shopId: id,\n    tabs: &#123;\n      $in: tab  //匹配tabs\n    &#125;\n  &#125;).sort(&#123; _id: -1 &#125;)  //逆序\n  return pList\n&#125;\n\nmodule.exports = &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125;\n在routes下新建shop.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel &#125; = require('../res-model/SuccessModel')\n\nconst &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125; = require('../controller/shop')\n\nrouter.prefix('/api/shop')\n\n// 热门商店（首页商店列表）\nrouter.get('/hot-list', async function (ctx, next) &#123;\n  const list = await getHotList()\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 根据 id 查询单个商店信息\nrouter.get('/:id', async function (ctx, next) &#123;\n  const id = ctx.params.id  //商店id\n  const shop = await getShopInfo(id)\n  ctx.body = new SuccessModel(shop)\n&#125;)\n\nrouter.get('/:id/product', async function (ctx, next) &#123;\n  const id = ctx.params.id\n  const tab = ctx.query.tab || 'all'\n  const products = await getProductByShopId(id, tab)\n  ctx.body = new SuccessModel(products)\n&#125;)\n\n订单接口\n在controller 下新建order.js\n/**\n * @description order controller\n * @author liyunfu\n */\n\nconst &#123; Order, Product, Address &#125; = require('../models/index')\n\n// 创建订单(要从Address，Product里拷贝数据，比较麻烦)\nasync function createOrder(username, data = &#123;&#125;) &#123;\n  console.log(username, data)\n  // 结构data(前端传来的订单信息)\n  const &#123;\n    addressId,\n    shopId,\n    shopName,\n    isCanceled = false,\n    products = []\n  &#125; = data\n\n  // 根据addressId获取地址信息\n  const address = await Address.findById(addressId)\n\n  // 获取商品列表\n  const pIds = products.map(p => p.id)\n  const productList = await Product.find(&#123;\n    // 条件1：商品id\n    _id: &#123;\n      $in: pIds\n    &#125;,\n    // 条件2：商店id\n    shopId\n  &#125;)\n\n  // 给商品列表增加销售数量(订单里，每个商品都有销量)\n  const productListWithSales = productList.map(p => &#123;\n    // 商品id\n    const id = p._id.toString()\n\n    // 找到商品销量\n    const filterProducts = products.filter(item => item.id === id)\n    if (filterProducts.length === 0) &#123;\n      // 没有找到匹配的数量 报错\n      throw new Error('未找到匹配的销量数据')\n    &#125;\n\n    return &#123;\n      orderSales: filterProducts[0].num,\n      product: p\n    &#125;\n  &#125;)\n\n  // 创建订单\n  const newOrder = await Order.create(&#123;\n    username,\n    address,\n    shopId,\n    shopName,\n    isCanceled,\n    products: productListWithSales\n  &#125;)\n  return newOrder\n&#125;\n\n// 获取订单列表\nasync function getOrderList(username) &#123;\n  console.log('username', username)\n  const list = await Order.find(&#123; username &#125;).sort(&#123; _id: -1 &#125;)\n  console.log('list', 'list')\n  return list\n&#125;\n\nmodule.exports = &#123;\n  createOrder,\n  getOrderList\n&#125;\n在routes 下新建order.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\nconst &#123; createOrder, getOrderList &#125; = require('../controller/order')\n\nrouter.prefix('/api/order')\n\n// 创建订单\nrouter.post('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证 可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 订单数据\n  const data = ctx.request.body\n\n  try &#123;\n    const newOrder = await createOrder(username, data)\n    ctx.body = new SuccessModel(newOrder)\n  &#125; catch (ex) &#123;\n    console.error(ex)\n    ctx.body = new ErrorModel(10005, '订单创建失败')\n  &#125;\n&#125;)\n\n// 获取订单列表\nrouter.get('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证，可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  const list = await getOrderList(username)\n\n  ctx.body = new SuccessModel(list)\n&#125;)\n\nmodule.exports = router\n\n改为适合部署到Vercel的项目\n在根目录下新建vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    &#125;\n  ]\n&#125;\n在根目录下新建index.js 将原bin/www内容移到此处\n\n修改package.json\n\"start\": \"node index.js\",\n\"dev\": \"./node_modules/.bin/nodemon index.js\",\n\"prd\": \"pm2 start index.js\",\n\n改造项目，实现跨域\n修改根目录下vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\",\n      \"headers\": &#123;\n        \"Access-Control-Allow-Credentials\": \"true\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,OPTIONS,PATCH,DELETE,POST,PUT\",\n        \"Access-Control-Allow-Headers\": \"X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version\"\n      &#125;\n    &#125;\n  ]\n&#125;\n\n​      \n","slug":"基于koa-generator搭建通用服务端","date":"2022-03-05T02:51:22.000Z","categories_index":"实战","tags_index":"实战,koa","author_index":"LIYUNFU"},{"id":"7bb7fcd214fc2de4ef1142bae196581d","title":"标准化大厂编码规范解决方案","content":"升级最新的vuenpm i vue@3.2.8 vue-router@4.0.11 vuex@4.0.2\n\nESLint规则// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象\n// 文档：https://eslint.bootcss.com/docs/user-guide/configuring\nmodule.exports = &#123;\n  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下\n  root: true,\n  // env 表示启用 ESLint 检测的环境\n  env: &#123;\n    // 在 node 环境下启动 ESLint 检测\n    node: true\n  &#125;,\n  // ESLint 中基础配置需要继承的配置\n  extends: [\"plugin:vue/vue3-essential\", \"@vue/standard\"],\n  // 解析器\n  parserOptions: &#123;\n    parser: \"babel-eslint\"\n  &#125;,\n  // 需要修改的启用规则及其各自的错误级别\n  /**\n   * 错误级别分为三种：\n   * \"off\" 或 0 - 关闭规则\n   * \"warn\" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n   * \"error\" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n   */\n  rules: &#123;\n    \"no-console\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    \"no-debugger\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    'space-before-function-paren': 0  //函数参数前括号没有空格\n  &#125;\n&#125;;\n\nPrettier配置.prettierrc\n&#123;\n  // 不尾随分号\n  \"semi\": false,\n  // 使用单引号\n  \"singleQuote\": true,\n  // 多行逗号分割的语法中，最后一行不加逗号\n  \"trailingComma\": \"none\"\n&#125;\n\n修改VSCode的TabSize\n配置大厂git提交规范全局安装Commitizennpm install -g commitizen@4.2.4\n\n安装并配置 cz-customizable 插件安装npm i cz-customizable@6.3.0 --save-dev\n\n添加以下配置到 package.json 中\"config\": &#123;\n  \"commitizen\": &#123;\n    \"path\": \"node_modules/cz-customizable\"\n  &#125;\n&#125;\n\n项目根目录下创建 .cz-config.js 自定义提示文件module.exports = &#123;\n  // 可选类型\n  types: [\n    &#123; value: 'feat', name: 'feat:     新功能' &#125;,\n    &#123; value: 'fix', name: 'fix:      修复' &#125;,\n    &#123; value: 'docs', name: 'docs:     文档变更' &#125;,\n    &#123; value: 'style', name: 'style:    代码格式(不影响代码运行的变动)' &#125;,\n    &#123;\n      value: 'refactor',\n      name: 'refactor: 重构(既不是增加feature，也不是修复bug)'\n    &#125;,\n    &#123; value: 'perf', name: 'perf:     性能优化' &#125;,\n    &#123; value: 'test', name: 'test:     增加测试' &#125;,\n    &#123; value: 'chore', name: 'chore:    构建过程或辅助工具的变动' &#125;,\n    &#123; value: 'revert', name: 'revert:   回退' &#125;,\n    &#123; value: 'build', name: 'build:    打包' &#125;\n  ],\n  // 消息步骤\n  messages: &#123;\n    type: '请选择提交类型:',\n    customScope: '请输入修改范围(可选):',\n    subject: '请简要描述提交(必填):',\n    body: '请输入详细描述(可选):',\n    footer: '请输入要关闭的issue(可选):',\n    confirmCommit: '确认使用以上信息提交？(y/n/e/h)'\n  &#125;,\n  // 跳过问题\n  skipQuestions: ['body', 'footer'],\n  // subject文字长度默认是72\n  subjectLimit: 72\n&#125;\n\n使用 git cz 代替 git commit使用 husky + commitlint 检查提交描述是否符合规范要求commitlint安装依赖：npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4\n\n根目录下创建 commitlint.config.js 文件module.exports = &#123;\n  // 继承的规则\n  extends: ['@commitlint/config-conventional'],\n  // 定义规则类型\n  rules: &#123;\n    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    'type-enum': [\n      2,\n      'always',\n      [\n        'feat', // 新功能 feature\n        'fix', // 修复 bug\n        'docs', // 文档注释\n        'style', // 代码格式(不影响代码运行的变动)\n        'refactor', // 重构(既不增加新功能，也不是修复bug)\n        'perf', // 性能优化\n        'test', // 增加测试\n        'chore', // 构建过程或辅助工具的变动\n        'revert', // 回退\n        'build' // 打包\n      ]\n    ],\n    // subject 大小写不做校验\n    'subject-case': [0]\n  &#125;\n&#125;\n\n注意：确保保存为 UTF-8 的编码格式，否则可能会出现以下错误：\n\nhusky安装依赖：npm install husky@7.0.1 --save-dev\n\n启动 hooks ， 生成 .husky 文件夹npx husky install\n\n在 package.json 中生成 prepare 指令\n执行 prepare 指令npm run prepare\n\n执行成功，提示\n添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx –no-install commitlint –edit “$1” 指令npx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"'\n\n此时的 .husky 的文件结构\n至此， 不符合规范的 commit 将不再可提交\n通过 pre-commit 检测提交时代码规范我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint –ext .js,.vue src 指令来去进行相关检测：\n\n 执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; 添加 commit 时的 hook （npx eslint --ext .js,.vue src 会在执行到该 hook 时运行） \n 该操作会生成对应文件 pre-commit： \n\n\nlint-staged 自动修复格式错误lint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送lint-staged 无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了\n修改 package.json 配置\"lint-staged\": &#123;\n    \"src/**/*.&#123;js,vue&#125;\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  &#125;\n\n修改 .husky/pre-commit 文件#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\nnpx lint-staged\n","slug":"标准化大厂编码规范解决方案","date":"2022-02-10T08:33:17.000Z","categories_index":"规范","tags_index":"git,规范","author_index":"LIYUNFU"},{"id":"4edaeadfac9de456799e43869dc8071d","title":"nestjs全解[windows版]","content":"前期准备基于docker配置数据库环境\n进入docker官网下载docker desktop\nhttps://www.docker.com/get-started/\n使用docker-compose简化运行方式\n由于docker desktop安装时已经自带docker-compose，我们只需要在C:\\Users\\[yourname]\\.docker  C盘你的用户目录下的.docker 文件夹下添加docker-compose.yml 即可\nversion: \"3.8\"\n\nservices:\n  mysql:\n    image: mysql:8.0.23\n    command: --default-authentication-plugin=mysql_native_password\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: example\n    ports:\n      - 3306:3306\n\n  postgres:\n    image: postgres:13.1\n    restart: always\n    environment:\n      POSTGRES_PASSWORD: example\n    ports:\n      - 5432:5432\n\n  adminer:\n    image: adminer\n    restart: always\n    ports:\n      - 8080:8080\n\n\n其中adminer 为可视化数据库管理系统，当启动images时，可以在localhost:8080 访问页面，另外两个为数据库\n\n在C:\\Users\\[yourname]\\.docker 当前目录下，执行docker-compose up 会自动拉取并执行images\ndocker-compose up\n\nNest.js认识Nest.js安装\n全局安装@nestjs/cli 工具，并新建项目learn_nest \nnpm i -g @nestjs&#x2F;cli\n\nnest new learn_nest\n安装好之后的src 核心文件\nsrc\n|-- app.controller.spec.ts\n|-- app.controller.ts\n|-- app.module.ts\n|-- app.service.ts\n|-- main.ts\n核心文件概述\n\n\n\n核心文件\n概述\n\n\n\napp.controller.ts\n带有单个路由的基本控制器示例\n\n\napp.controller.spec.ts\n对于基本控制器的单元测试样例\n\n\napp.module.ts\n应用程序的跟模块\n\n\napp.service.ts\n带有单个方法的基本服务\n\n\nmain.ts\n应用程序入口文件\n\n\n\nmain.ts 认识\nimport &#123; NestFactory &#125; from '@nestjs/core';\nimport &#123; AppModule &#125; from './app.module';\n\nasync function bootstrap() &#123;\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n&#125;\nbootstrap();\n\n// 使用NestFactory来创建Nest应用实例，并监听3000端口\n\n控制器controller\n控制器负责处理传入的请求 和向客户端返回响应 \n控制器的目的是接收应用的特定请求。路由机制控制哪个控制器接收哪些请求，通常，每个控制器有多个路由，不同的路由可以执行不同的操作。\n为了创建一个基本的控制器，我们使用类和装饰器 。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射(将请求绑定到相应的控制器)\n\n路由示例\n/* event.controller.ts */\nimport &#123;Controller,Get&#125; from '@/nestjs/common'\n\n@Controller('event')\nexport class EventController&#123;\n    @Get('/list')\n    findAll():string&#123;\n        return 'this is event all'\n    &#125;\n&#125;\n\n上面示例就可以在postman中请求urllocalhost:3000/event/list 即可得到返回结果\n\nRequest示例\n/* event.controller.ts */\nimport &#123;Controller,Get&#125; from '@/nestjs/common'\nimport &#123;Request&#125; from 'express'\n\n@Controller('event')\nexport class EventController&#123;\n    @Get('/list')\n    findAll(@Req() request:Request):string&#123;\n        return 'this is event all'\n    &#125;\n&#125;\n\n\n常见底层装饰器对照表\n\n\n\n装饰器\n对象\n\n\n\n@Request() , @Req()\nreq\n\n\n@Response() , @Res()\nres\n\n\n@Next()\nnext\n\n\n@Session()\nreq.session\n\n\n@Param(key?:string)\nreq.params/req.params[key]\n\n\n@Body(key?:string)\nreq.body / req.body[key]\n\n\n@Query(key?:string)\nreq.query / req.query[key]\n\n\n@Header(name?:string)\nreq.headers / req.headers[key]\n\n\n@Ip()\nreq.ip\n\n\n@HostParam()\nreq.hosts\n\n\n\n资源路由@Put()  @Delete() @Patch()  @Get()  @Post @All()\n\n 路由通配符 (路由同样支持模式匹配，例如星号被用作通配符)\n\n状态码\n@Post()\n@HttpCode(204)\ncreate() &#123;\n  return 'This action adds a new cat';\n&#125;\n\n返回状态码204\n\nHeaders\n可以指定返回头\n@Post()\n@Header('Cache-Control', 'none')\ncreate() &#123;\n  return 'This action adds a new cat';\n&#125;\n重定向\n@Redirect()装饰器有两个参数，url 和statusCode ，如果省略，则statusCode 默认为302 \n@Get()\n@Redirect('https://nestjs.com', 301\n\n有时候想要动态指定重定向地址，可以返回一个标准的对象，重定向到v5版本\n@Get('docs')\n@Redirect('https://docs.nestjs.com', 302)\ngetDocs(@Query('version') version) &#123;\n  if (version &amp;&amp; version === '5') &#123;\n    return &#123; url: 'https://docs.nestjs.com/v5/' &#125;;\n  &#125;\n&#125;\n路由参数\n当你需要接收动态数据 作为请求的一部分时，如GET /event/1 来获取id为1的event\n@Get(':id')\nfindOne(@Param() params):string&#123;\n    console.log(params.id)\n    return `this is return $&#123;params.id&#125;`\n&#125;\n\n或\n@Get(':id')\nfindOne(@Param('id'):id):string&#123;\n    return `this is return $&#123;id&#125;`\n&#125;\n子域路由\n即要求传入的HTTP 主机匹配某个特定的值才会响应\n@Controller(&#123; host: ':account.example.com' &#125;)\nexport class AccountController &#123;\n  @Get()\n  getInfo(@HostParam('account') account: string) &#123;\n    return account;\n  &#125;\n请求负载(规定接收的客户端参数)\n创建create-event.dto.ts \nexport class CreateEventDto &#123;\n  name: string;\n  description: string;\n  when: string;\n  address: string;\n&#125;\n\n\n在event.controller.ts 中使用\n@Post()\nasync create(@Body() input: CreateEventDto) &#123;\n  return await this.repository.save(&#123;\n    ...input,\n    when: new Date(input.when),\n  &#125;);\n&#125;\n\n​    最后一步，需要在App.module.ts中添加自定义的controller\nimport &#123; Module &#125; from '@nestjs/common';\nimport &#123; CatsController &#125; from './cats/cats.controller';\n\n@Module(&#123;\n  controllers: [EventController],\n&#125;)\nexport class AppModule &#123;&#125;\n\n\n\n提供者Providers模块Module中间件 Middleware异常过滤管道pipes守卫拦截器自定义装饰器基本原理技术安全","slug":"nestjs全解","date":"2022-04-23T01:38:46.000Z","categories_index":"服务端","tags_index":"数据库,服务端,nestjs,node","author_index":"LIYUNFU"},{"id":"d7e719f5c11a6405545a398b1276387c","title":"函数式编程范式","content":"函数式编程范式什么是函数式编程函数式编程就是利用纯函数实现细粒度的函数，通过函数组合组合成功能更强大的函数\n\n函数式编程对运算过程进行抽象，面向对象编程对事物进行抽象\n函数式编程中的函数指的不是程序中的函数，而是数学中的函数即映射关系\n相同的输入始终要得到相同的输出\n\n为什么要学习函数式编程\n函数式编程是随着React的流行受到越来越多关注\nVue3也开始拥抱函数式编程\n函数式编程可以抛弃this\n打包过程中可以更好的利用tree shaking过滤无用代码\n方便测试、方便并行处理\n有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda\n\n函数是一等公民\n函数可以存储在变量中\n函数作为参数\n函数作为返回值\n\n高阶函数什么是高阶函数\n高阶函数(Higher-order function)\n\n\n可以把函数作为参数传递给另一个函数\n可以把函数作为另一个函数的返回结果\n\n\n函数作为参数\n\n\n高阶函数模拟forEach\n\n\n\nfunction forEach(arr,fn)&#123;\n    for(let i=0;i&lt;arr.length;i++)&#123;\n        fn(arr[i])\n    &#125;\n&#125;\n\n// 测试\nlet arr=[1,3,4,6,7]\nforEach(arr,function(item)&#123;\n    console.log(item)\n&#125;)\n\n\n\n高阶函数模拟filter\n\n\n\n// filter\nfunction filter(arr,fn)&#123;\n    let results=[]\n    for(let i=0;i&lt;arr.length;i++)&#123;\n        if(fn(arr[i]))&#123;\n            results.push(arr[i])\n        &#125;\n    &#125;\n    return results\n&#125;\n\n// 测试\nconsole.log(filter(arr,function(item)&#123;\n    return item%2===0\n&#125;))\n\n\n函数作为返回值\n\n\n高阶函数模拟once\n\n\n\nfunction once(fn)&#123;\n    let done=false\n    return function()&#123;\n        if(!done)&#123;\n            done=true\n            return fn.apply(this,arguments)\n        &#125;\n    &#125;\n&#125;\n\nlet pay=once(function(money)&#123;\n    console.log(`支付：$&#123;money&#125; RMB`)\n&#125;)\n\n// 只会支付一次\npay(5)\npay(5)\npay(5)\n\n使用高阶函数的意义\n抽象可以帮我们屏蔽细节，只需要关注我们的目标\n高阶函数是用来抽象通用的问题\n\n常用高阶函数\nforEach\n\nmap\n\nfilter\n\nevery\n\nsome\n\nfind/findIndex\n\nreduce\n\nsort\n\n\n高阶函数实现map\n\n\n\n// map\nconst map=(arr,fn)=>&#123;\n    let results=[]\n    for(const value of arr)&#123;\n        results.push(fn(value))\n    &#125;\n    return results\n&#125;\n\n// 测试\nconst arr=[1,2,3,4,5]\nconsole.log(map(arr,function(item)&#123;\n    return item*2\n&#125;))\n\n\n\n高阶函数实现every 判断数组的元素是否都匹配\n\n\n\n//every\nconst every=(arr,fn)=>&#123;\n    let result=true\n    for(const value of arr)&#123;\n        result=fn(value)\n        if(!result)&#123;\n            break\n        &#125;\n    &#125;\n    return result\n&#125;\n\n// 测试\nconsole.log(every(arr,function(item)&#123;\n    return item>0\n&#125;))\n\n\n\n高阶函数实现some检测数组的元素是否有一个满足条件\n\n\n\n// some\nconst some=(arr,fn)=>&#123;\n    let result=false\n    for(const value of arr)&#123;\n        result=fn(value)\n        if(result)&#123;\n            break\n        &#125;\n    &#125;\n    return result\n&#125;\n\nconsole.log(some(arr,function(item)&#123;\n    return item%2===0\n&#125;))\n\n闭包什么是闭包可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的对象\n\n闭包的本质：函数在执行的时候会放在一个执行栈上当函数执行完毕之后会从执行栈上移出，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\n\n闭包案例封装一个求次方的方法\n// 生成计算数字的多少次幂的函数\nfunction makePower (power)&#123;\n    return function(x)&#123;\n        return Math.pow(x,power)\n    &#125;\n&#125;\n\nlet pow2=makePower(2)\nlet pow3=makePower(3)\n\nconsole.log(pow2(4))\nconsole.log(pow3(4))\n\n封装一个根据基本工资和绩效工资求实际工资\nfunction makeSalary(x)&#123;\n    return function(y)&#123;\n        return x+y\n    &#125;\n&#125;\n\nlet salaryLevel1=makeSalary(1500)\nlet salaryLevel2=makeSalary(2000)\n\nconsole.log(salaryLevel1(2000))\nconsole.log(salaryLevel2(4000))\n\n纯函数什么是纯函数\n相同的输入永远会得到相同的输出，而且没有任何可观察的副作用\n数组的slice和splice分别是纯函数和不纯的函数\n\nlet numbers = [1, 2, 3, 4, 5]\n// 纯函数\nnumbers.slice(0, 3)\n// => [1, 2, 3]\nnumbers.slice(0, 3)\n// => [1, 2, 3]\nnumbers.slice(0, 3)\n// => [1, 2, 3]\n// 不纯的函数\nnumbers.splice(0, 3)\n// => [1, 2, 3]\nnumbers.splice(0, 3)\n// => [4, 5]\nnumbers.splice(0, 3)\n// => []\n\n纯函数的好处\n可缓存\n\n\n因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来\n模拟memoize记忆函数\n\n\n\n// 模拟memoize方法的实现\nfunction memoize(fn)&#123;\n    let cache=&#123;&#125;\n    return function()&#123;\n        // 转为字符串\n        let key=JSON.stringify(arguments)\n        cache[key]=cache[key]||fn.apply(fn,arguments)\n        return cache[key]\n    &#125;\n&#125;\n\nlet getAreaWithMemory=memoize(getArea)\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))\n\n\n可测试\n\n并行处理\n\n\n在多线程环境下并行操作共享的内存数据很可能会出现意外情况\n纯函数不需要访问共享的内容数据，所以在并行环境下可以任意运行纯函数(Web Worker)\n\n\n\n副作用副作用让一个函数变得不纯，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用\n柯里化什么是柯里化\n当一个函数有多个参数的时候先传递一部分参数调用它(这部分参数以后永远不变)\n然后返回一个新的函数接收剩余的参数，返回结果\n\nfunction checkAge(min)&#123;\n    return function(age)&#123;\n        return age>=min\n    &#125;\n&#125;\n\nconst checkAge18=checkAge(18)\nconsole.log(checkAge18(20))\n\nlodash中的柯里化\n_.curry(fn)\n\n\n功能：创建一个函数，该函数接收一个或多个fn的参数，如果fn所需要的参数都被提供则执行fn并返回执行的结果，否则继续返回该函数并等待接收剩余的参数\n参数：需要柯里化的函数\n返回值：柯里化后的函数\n\n\n\nimport _ from 'lodash'\n\nfunction getSum(a,b,c)&#123;\n    return a+b+c\n&#125;\n\nconst curried=_.curry(getSum)\n\nconsole.log(curried(1,2,3))\nconsole.log(curried(1)(2)(3))\nconsole.log(curried(1,2)(3))\n\n柯里化案例\n判断一个字符串中是否有空白字符\n\nconst _ = require('lodash')\nconst match = _.curry(function (reg, str) &#123;\nreturn str.match(reg)\n&#125;)\nconst haveSpace = match(/\\s+/g)\nconst haveNumber = match(/\\d+/g)\nconsole.log(haveSpace('hello world'))\nconsole.log(haveNumber('25$'))\nconst filter = _.curry(function (func, array) &#123;\nreturn array.filter(func)\n&#125;)\nconsole.log(filter(haveSpace, ['John Connor', 'John_Donne']))\nconst findSpace = filter(haveSpace)\nconsole.log(findSpace(['John Connor', 'John_Donne']))\n\n模拟_.curry()的实现function curry (func) &#123;\nreturn function curriedFn (...args) &#123;\n// 判断实参和形参的个数\nif (args.length &lt; func.length) &#123;\nreturn function () &#123;\nreturn curriedFn(...args.concat(Array.from(arguments)))\n&#125;\n&#125;\n// 实参和形参个数相同，调用 func，返回结果\nreturn func(...args)\n&#125;\n&#125;\n\n总结\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住某些固定参数的新函数\n这是一种对函数参数的缓存\n让函数变得更灵活，让函数的粒度更小\n可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能\n\n","slug":"函数式编程范式","date":"2022-04-10T12:42:12.000Z","categories_index":"大前端","tags_index":"大前端,JavaScript","author_index":"LIYUNFU"},{"id":"8f40b8c169f1805e005d621691667888","title":"代码输出题","content":"一、异步&amp;事件循环1. 代码输出结果const promise = new Promise((resolve, reject) => &#123;\n  console.log(1);\n  console.log(2);\n&#125;);\npromise.then(() => &#123;\n  console.log(3);\n&#125;);\nconsole.log(4);\n复制代码\n\n输出结果如下：\n1 \n2 \n4\n复制代码\n\npromise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。\n2. 代码输出结果const promise1 = new Promise((resolve, reject) => &#123;\n  console.log('promise1')\n  resolve('resolve1')\n&#125;)\nconst promise2 = promise1.then(res => &#123;\n  console.log(res)\n&#125;)\nconsole.log('1', promise1);\nconsole.log('2', promise2);\n复制代码\n\n输出结果如下：\npromise1\n1 Promise&#123;&lt;resolved>: resolve1&#125;\n2 Promise&#123;&lt;pending>&#125;\nresolve1\n复制代码\n\n需要注意的是，直接打印promise1，会打印出它的状态值和参数。\n代码执行过程如下：\n\nscript是一个宏任务，按照顺序执行这些代码；\n首先进入Promise，执行该构造函数中的代码，打印promise1；\n碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来；\n碰到promise1.then这个微任务，将它放入微任务队列；\npromise2是一个新的状态为pending的Promise；\n执行同步代码1， 同时打印出promise1的状态是resolved；\n执行同步代码2，同时打印出promise2的状态是pending；\n宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。\n\n3. 代码输出结果const promise = new Promise((resolve, reject) => &#123;\n  console.log(1);\n  setTimeout(() => &#123;\n    console.log(\"timerStart\");\n    resolve(\"success\");\n    console.log(\"timerEnd\");\n  &#125;, 0);\n  console.log(2);\n&#125;);\npromise.then((res) => &#123;\n  console.log(res);\n&#125;);\nconsole.log(4);\n复制代码\n\n输出结果如下：\n1\n2\n4\ntimerStart\ntimerEnd\nsuccess\n复制代码\n\n代码执行过程如下：\n\n首先遇到Promise构造函数，会先执行里面的内容，打印1；\n遇到定时器steTimeout，它是一个宏任务，放入宏任务队列；\n继续向下执行，打印出2；\n由于Promise的状态此时还是pending，所以promise.then先不执行；\n继续执行下面的同步任务，打印出4；\n此时微任务队列没有任务，继续执行下一轮宏任务，执行steTimeout；\n首先执行timerStart，然后遇到了resolve，将promise的状态改为resolved且保存结果并将之前的promise.then推入微任务队列，再执行timerEnd；\n执行完这个宏任务，就去执行微任务promise.then，打印出resolve的结果。\n\n4. 代码输出结果Promise.resolve().then(() => &#123;\n  console.log('promise1');\n  const timer2 = setTimeout(() => &#123;\n    console.log('timer2')\n  &#125;, 0)\n&#125;);\nconst timer1 = setTimeout(() => &#123;\n  console.log('timer1')\n  Promise.resolve().then(() => &#123;\n    console.log('promise2')\n  &#125;)\n&#125;, 0)\nconsole.log('start');\n复制代码\n\n输出结果如下：\nstart\npromise1\ntimer1\npromise2\ntimer2\n复制代码\n\n代码执行过程如下：\n\n首先，Promise.resolve().then是一个微任务，加入微任务队列\n执行timer1，它是一个宏任务，加入宏任务队列\n继续执行下面的同步代码，打印出start\n这样第一轮宏任务就执行完了，开始执行微任务Promise.resolve().then，打印出promise1\n遇到timer2，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是timer1、timer2；\n这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器timer1，打印timer1；\n遇到Promise.resolve().then，它是一个微任务，加入微任务队列\n开始执行微任务队列中的任务，打印promise2；\n最后执行宏任务timer2定时器，打印出timer2；\n\n5. 代码输出结果const promise = new Promise((resolve, reject) => &#123;\n    resolve('success1');\n    reject('error');\n    resolve('success2');\n&#125;);\npromise.then((res) => &#123;\n    console.log('then:', res);\n&#125;).catch((err) => &#123;\n    console.log('catch:', err);\n&#125;)\n复制代码\n\n输出结果如下：\nthen：success1\n复制代码\n\n这个题目考察的就是Promise的状态在发生变化之后，就不会再发生变化。开始状态由pending变为resolve，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。\n6. 代码输出结果Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n复制代码\n\n输出结果如下：\n1\nPromise &#123;&lt;fulfilled>: undefined&#125;\n复制代码\n\nPromise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。\nthen方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。\n7. 代码输出结果const promise1 = new Promise((resolve, reject) => &#123;\n  setTimeout(() => &#123;\n    resolve('success')\n  &#125;, 1000)\n&#125;)\nconst promise2 = promise1.then(() => &#123;\n  throw new Error('error!!!')\n&#125;)\nconsole.log('promise1', promise1)\nconsole.log('promise2', promise2)\nsetTimeout(() => &#123;\n  console.log('promise1', promise1)\n  console.log('promise2', promise2)\n&#125;, 2000)\n复制代码\n\n输出结果如下：\npromise1 Promise &#123;&lt;pending>&#125;\npromise2 Promise &#123;&lt;pending>&#125;\n\nUncaught (in promise) Error: error!!!\npromise1 Promise &#123;&lt;fulfilled>: \"success\"&#125;\npromise2 Promise &#123;&lt;rejected>: Error: error!!&#125;\n复制代码\n\n8. 代码输出结果Promise.resolve(1)\n  .then(res => &#123;\n    console.log(res);\n    return 2;\n  &#125;)\n  .catch(err => &#123;\n    return 3;\n  &#125;)\n  .then(res => &#123;\n    console.log(res);\n  &#125;);\n复制代码\n\n输出结果如下：\n1   \n2\n复制代码\n\nPromise是可以链式调用的，由于每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。\n上面的输出结果之所以依次打印出1和2，是因为resolve(1)之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成resolve(2)，被最后的then打印输出2。\n9. 代码输出结果Promise.resolve().then(() => &#123;\n  return new Error('error!!!')\n&#125;).then(res => &#123;\n  console.log(\"then: \", res)\n&#125;).catch(err => &#123;\n  console.log(\"catch: \", err)\n&#125;)\n复制代码\n\n输出结果如下：\n\"then: \" \"Error: error!!!\"\n复制代码\n\n返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error(&#39;error!!!&#39;)也被包裹成了return Promise.resolve(new Error(&#39;error!!!&#39;))，因此它会被then捕获而不是catch。\n10. 代码输出结果const promise = Promise.resolve().then(() => &#123;\n  return promise;\n&#125;)\npromise.catch(console.err)\n复制代码\n\n输出结果如下：\nUncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise>\n复制代码\n\n这里其实是一个坑，.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。\n11. 代码输出结果Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n复制代码\n\n输出结果如下：\n1\n复制代码\n\n看到这个题目，好多的then，实际上只需要记住一个原则：.then 或.catch 的参数期望是函数，传入非函数则会发生值透传。\n第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将resolve(1) 的值直接传到最后一个then里，直接打印出1。\n12. 代码输出结果Promise.reject('err!!!')\n  .then((res) => &#123;\n    console.log('success', res)\n  &#125;, (err) => &#123;\n    console.log('error', err)\n  &#125;).catch(err => &#123;\n    console.log('catch', err)\n  &#125;)\n复制代码\n\n输出结果如下：\nerror err!!!\n复制代码\n\n我们知道，.then函数中的两个参数：\n\n第一个参数是用来处理Promise成功的函数\n第二个则是处理失败的函数\n\n也就是说Promise.resolve(&#39;1&#39;)的值会进入成功的函数，Promise.reject(&#39;2&#39;)的值会进入失败的函数。\n在这道题中，错误直接被then的第二个参数捕获了，所以就不会被catch捕获了，输出结果为：error err!!!&#39;\n但是，如果是像下面这样：\nPromise.resolve()\n  .then(function success (res) &#123;\n    throw new Error('error!!!')\n  &#125;, function fail1 (err) &#123;\n    console.log('fail1', err)\n  &#125;).catch(function fail2 (err) &#123;\n    console.log('fail2', err)\n  &#125;)\n复制代码\n\n在then的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的catch捕获到。\n13. 代码输出结果Promise.resolve('1')\n  .then(res => &#123;\n    console.log(res)\n  &#125;)\n  .finally(() => &#123;\n    console.log('finally')\n  &#125;)\nPromise.resolve('2')\n  .finally(() => &#123;\n    console.log('finally2')\n  \treturn '我是finally2返回的值'\n  &#125;)\n  .then(res => &#123;\n    console.log('finally2后面的then函数', res)\n  &#125;)\n复制代码\n\n输出结果如下：\n1\nfinally2\nfinally\nfinally2后面的then函数 2\n复制代码\n\n.finally()一般用的很少，只要记住以下几点就可以了：\n\n.finally()方法不管Promise对象最后的状态如何都会执行\n.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是无法知道Promise最终的状态是resolved还是rejected的\n它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。\nfinally本质上是then方法的特例\n\n.finally()的错误捕获：\nPromise.resolve('1')\n  .finally(() => &#123;\n    console.log('finally1')\n    throw new Error('我是finally中抛出的异常')\n  &#125;)\n  .then(res => &#123;\n    console.log('finally后面的then函数', res)\n  &#125;)\n  .catch(err => &#123;\n    console.log('捕获错误', err)\n  &#125;)\n复制代码\n\n输出结果为：\n'finally1'\n'捕获错误' Error: 我是finally中抛出的异常\n复制代码\n\n14. 代码输出结果function runAsync (x) &#123;\n    const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))\n    return p\n&#125;\n\nPromise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res => console.log(res))\n复制代码\n\n输出结果如下：\n1\n2\n3\n[1, 2, 3]\n复制代码\n\n首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。\n之后再使用Promise.all来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。\n15. 代码输出结果function runAsync (x) &#123;\n  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))\n  return p\n&#125;\nfunction runReject (x) &#123;\n  const p = new Promise((res, rej) => setTimeout(() => rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x))\n  return p\n&#125;\nPromise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])\n       .then(res => console.log(res))\n       .catch(err => console.log(err))\n复制代码\n\n输出结果如下：\n// 1s后输出\n1\n3\n// 2s后输出\n2\nError: 2\n// 4s后输出\n4\n复制代码\n\n可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是runReject(2)的结果。如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。会被.then()的第二个回调函数捕获。\n16. 代码输出结果function runAsync (x) &#123;\n  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))\n  return p\n&#125;\nPromise.race([runAsync(1), runAsync(2), runAsync(3)])\n  .then(res => console.log('result: ', res))\n  .catch(err => console.log(err))\n复制代码\n\n输出结果如下：\n1\n'result: ' 1\n2\n3\n复制代码\n\nthen只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。\n17. 代码输出结果function runAsync(x) &#123;\n  const p = new Promise(r =>\n    setTimeout(() => r(x, console.log(x)), 1000)\n  );\n  return p;\n&#125;\nfunction runReject(x) &#123;\n  const p = new Promise((res, rej) =>\n    setTimeout(() => rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)\n  );\n  return p;\n&#125;\nPromise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])\n  .then(res => console.log(\"result: \", res))\n  .catch(err => console.log(err));\n复制代码\n\n输出结果如下：\n0\nError: 0\n1\n2\n3\n复制代码\n\n可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。\n注意：all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。\n18. 代码输出结果async function async1() &#123;\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n&#125;\nasync function async2() &#123;\n  console.log(\"async2\");\n&#125;\nasync1();\nconsole.log('start')\n复制代码\n\n输出结果如下：\nasync1 start\nasync2\nstart\nasync1 end\n复制代码\n\n代码的执行过程如下：\n\n首先执行函数中的同步代码async1 start，之后遇到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1；\n跳出async1函数后，执行同步代码start；\n在一轮宏任务全部执行完之后，再来执行await后面的内容async1 end。\n\n这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。\n19. 代码输出结果async function async1() &#123;\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n  setTimeout(() => &#123;\n    console.log('timer1')\n  &#125;, 0)\n&#125;\nasync function async2() &#123;\n  setTimeout(() => &#123;\n    console.log('timer2')\n  &#125;, 0)\n  console.log(\"async2\");\n&#125;\nasync1();\nsetTimeout(() => &#123;\n  console.log('timer3')\n&#125;, 0)\nconsole.log(\"start\")\n复制代码\n\n输出结果如下：\nasync1 start\nasync2\nstart\nasync1 end\ntimer2\ntimer3\ntimer1\n复制代码\n\n代码的执行过程如下：\n\n首先进入async1，打印出async1 start；\n之后遇到async2，进入async2，遇到定时器timer2，加入宏任务队列，之后打印async2；\n由于async2阻塞了后面代码的执行，所以执行后面的定时器timer3，将其加入宏任务队列，之后打印start；\n然后执行async2后面的代码，打印出async1 end，遇到定时器timer1，将其加入宏任务队列；\n最后，宏任务队列有三个任务，先后顺序为timer2，timer3，timer1，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。\n\n20. 代码输出结果async function async1 () &#123;\n  console.log('async1 start');\n  await new Promise(resolve => &#123;\n    console.log('promise1')\n  &#125;)\n  console.log('async1 success');\n  return 'async1 end'\n&#125;\nconsole.log('srcipt start')\nasync1().then(res => console.log(res))\nconsole.log('srcipt end')\n复制代码\n\n输出结果如下：\nscript start\nasync1 start\npromise1\nscript end\n复制代码\n\n这里需要注意的是在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，所以在await之后的内容是不会执行的，包括async1后面的 .then。\n21. 代码输出结果async function async1 () &#123;\n  console.log('async1 start');\n  await new Promise(resolve => &#123;\n    console.log('promise1')\n    resolve('promise1 resolve')\n  &#125;).then(res => console.log(res))\n  console.log('async1 success');\n  return 'async1 end'\n&#125;\nconsole.log('srcipt start')\nasync1().then(res => console.log(res))\nconsole.log('srcipt end')\n复制代码\n\n这里是对上面一题进行了改造，加上了resolve。\n输出结果如下：\nscript start\nasync1 start\npromise1\nscript end\npromise1 resolve\nasync1 success\nasync1 end\n复制代码\n\n22. 代码输出结果async function async1() &#123;\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n&#125;\n\nasync function async2() &#123;\n  console.log(\"async2\");\n&#125;\n\nconsole.log(\"script start\");\n\nsetTimeout(function() &#123;\n  console.log(\"setTimeout\");\n&#125;, 0);\n\nasync1();\n\nnew Promise(resolve => &#123;\n  console.log(\"promise1\");\n  resolve();\n&#125;).then(function() &#123;\n  console.log(\"promise2\");\n&#125;);\nconsole.log('script end')\n复制代码\n\n输出结果如下：\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n复制代码\n\n代码执行过程如下：\n\n开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；\n遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；\n之后执行函数async1，首先打印出async1 start；\n遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；\n然后跳出async1和async2，遇到Promise，打印出promise1；\n遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；\n之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；\n执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。\n\n23. 代码输出结果async function async1 () &#123;\n  await async2();\n  console.log('async1');\n  return 'async1 success'\n&#125;\nasync function async2 () &#123;\n  return new Promise((resolve, reject) => &#123;\n    console.log('async2')\n    reject('error')\n  &#125;)\n&#125;\nasync1().then(res => console.log(res))\n复制代码\n\n输出结果如下：\nasync2\nUncaught (in promise) error\n复制代码\n\n可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。\n如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：\nasync function async1 () &#123;\n  await Promise.reject('error!!!').catch(e => console.log(e))\n  console.log('async1');\n  return Promise.resolve('async1 success')\n&#125;\nasync1().then(res => console.log(res))\nconsole.log('script start')\n复制代码\n\n这样的输出结果就是：\nscript start\nerror!!!\nasync1\nasync1 success\n复制代码\n\n24. 代码输出结果const first = () => (new Promise((resolve, reject) => &#123;\n    console.log(3);\n    let p = new Promise((resolve, reject) => &#123;\n        console.log(7);\n        setTimeout(() => &#123;\n            console.log(5);\n            resolve(6);\n            console.log(p)\n        &#125;, 0)\n        resolve(1);\n    &#125;);\n    resolve(2);\n    p.then((arg) => &#123;\n        console.log(arg);\n    &#125;);\n&#125;));\nfirst().then((arg) => &#123;\n    console.log(arg);\n&#125;);\nconsole.log(4);\n复制代码\n\n输出结果如下：\n3\n7\n4\n1\n2\n5\nPromise&#123;&lt;resolved>: 1&#125;\n复制代码\n\n代码的执行过程如下：\n\n首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；\n遇到了定时器，将其加入宏任务队列；\n执行Promise  p中的resolve，状态变为resolved，返回值为1；\n执行Promise first中的resolve，状态变为resolved，返回值为2；\n遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；\n执行外面的代码，打印出4；\n这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；\n这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以resolve(6)不会再执行；\n最后console.log(p)打印出Promise&#123;&lt;resolved&gt;: 1&#125;；\n\n25. 代码输出结果const async1 = async () => &#123;\n  console.log('async1');\n  setTimeout(() => &#123;\n    console.log('timer1')\n  &#125;, 2000)\n  await new Promise(resolve => &#123;\n    console.log('promise1')\n  &#125;)\n  console.log('async1 end')\n  return 'async1 success'\n&#125; \nconsole.log('script start');\nasync1().then(res => console.log(res));\nconsole.log('script end');\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .catch(4)\n  .then(res => console.log(res))\nsetTimeout(() => &#123;\n  console.log('timer2')\n&#125;, 1000)\n复制代码\n\n输出结果如下：\nscript start\nasync1\npromise1\nscript end\n1\ntimer2\ntimer1\n复制代码\n\n代码的执行过程如下：\n\n首先执行同步带吗，打印出script start；\n遇到定时器timer1将其加入宏任务队列；\n之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；\n然后执行同步代码，打印出script end；\n继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；\n遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。\n\n26. 代码输出结果const p1 = new Promise((resolve) => &#123;\n  setTimeout(() => &#123;\n    resolve('resolve3');\n    console.log('timer1')\n  &#125;, 0)\n  resolve('resovle1');\n  resolve('resolve2');\n&#125;).then(res => &#123;\n  console.log(res)  // resolve1\n  setTimeout(() => &#123;\n    console.log(p1)\n  &#125;, 1000)\n&#125;).finally(res => &#123;\n  console.log('finally', res)\n&#125;)\n复制代码\n\n执行结果为如下：\nresolve1\nfinally  undefined\ntimer1\nPromise&#123;&lt;resolved>: undefined&#125;\n复制代码\n\n需要注意的是最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值，而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果在定时器的下面加上一个return 1，则值就会变成1。\n27. 代码输出结果console.log('1');\n\nsetTimeout(function() &#123;\n    console.log('2');\n    process.nextTick(function() &#123;\n        console.log('3');\n    &#125;)\n    new Promise(function(resolve) &#123;\n        console.log('4');\n        resolve();\n    &#125;).then(function() &#123;\n        console.log('5')\n    &#125;)\n&#125;)\nprocess.nextTick(function() &#123;\n    console.log('6');\n&#125;)\nnew Promise(function(resolve) &#123;\n    console.log('7');\n    resolve();\n&#125;).then(function() &#123;\n    console.log('8')\n&#125;)\n\nsetTimeout(function() &#123;\n    console.log('9');\n    process.nextTick(function() &#123;\n        console.log('10');\n    &#125;)\n    new Promise(function(resolve) &#123;\n        console.log('11');\n        resolve();\n    &#125;).then(function() &#123;\n        console.log('12')\n    &#125;)\n&#125;)\n复制代码\n\n输出结果如下：\n1\n7\n6\n8\n2\n4\n3\n5\n9\n11\n10\n12\n复制代码\n\n（1）第一轮事件循环流程分析如下：\n\n整体script作为第一个宏任务进入主线程，遇到console.log，输出1。\n遇到setTimeout，其回调函数被分发到宏任务Event Queue中。暂且记为setTimeout1。\n遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。记为process1。\n遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。记为then1。\n又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，记为setTimeout2。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\nsetTimeout1\nprocess1\n\n\nsetTimeout2\nthen1\n\n\n上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了process1和then1两个微任务：\n\n执行process1，输出6。\n执行then1，输出8。\n\n第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。\n（2）第二轮时间循环从**setTimeout1**宏任务开始：\n\n首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。\nnew Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\nsetTimeout2\nprocess2\n\n\n\nthen2\n\n\n第二轮事件循环宏任务结束，发现有process2和then2两个微任务可以执行：\n\n输出3。\n输出5。\n\n第二轮事件循环结束，第二轮输出2，4，3，5。\n（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。\n\n直接输出9。\n将process.nextTick()分发到微任务Event Queue中。记为process3。\n直接执行new Promise，输出11。\n将then分发到微任务Event Queue中，记为then3。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\n\nprocess3\n\n\n\nthen3\n\n\n第三轮事件循环宏任务执行结束，执行两个微任务process3和then3：\n\n输出10。\n输出12。\n\n第三轮事件循环结束，第三轮输出9，11，10，12。\n整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。\n28. 代码输出结果console.log(1)\n\nsetTimeout(() => &#123;\n  console.log(2)\n&#125;)\n\nnew Promise(resolve =>  &#123;\n  console.log(3)\n  resolve(4)\n&#125;).then(d => console.log(d))\n\nsetTimeout(() => &#123;\n  console.log(5)\n  new Promise(resolve =>  &#123;\n    resolve(6)\n  &#125;).then(d => console.log(d))\n&#125;)\n\nsetTimeout(() => &#123;\n  console.log(7)\n&#125;)\n\nconsole.log(8)\n复制代码\n\n输出结果如下：\n1\n3\n8\n4\n2\n5\n6\n7\n复制代码\n\n代码执行过程如下：\n\n首先执行script代码，打印出1；\n遇到第一个定时器，加入到宏任务队列；\n遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；\n遇到第二个定时器，加入到宏任务队列；\n遇到第三个定时器，加入到宏任务队列；\n继续执行script代码，打印出8，第一轮执行结束；\n执行微任务队列，打印出第一个Promise的resolve结果：4；\n开始执行宏任务队列，执行第一个定时器，打印出2；\n此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；\n执行微任务队列，打印出6；\n执行宏任务队列中的最后一个定时器，打印出7。\n\n29. 代码输出结果console.log(1);\n    \nsetTimeout(() => &#123;\n  console.log(2);\n  Promise.resolve().then(() => &#123;\n    console.log(3)\n  &#125;);\n&#125;);\n\nnew Promise((resolve, reject) => &#123;\n  console.log(4)\n  resolve(5)\n&#125;).then((data) => &#123;\n  console.log(data);\n&#125;)\n\nsetTimeout(() => &#123;\n  console.log(6);\n&#125;)\n\nconsole.log(7);\n复制代码\n\n代码输出结果如下：\n1\n4\n7\n5\n2\n3\n6\n复制代码\n\n代码执行过程如下：\n\n首先执行scrip代码，打印出1；\n遇到第一个定时器setTimeout，将其加入到宏任务队列；\n遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；\n遇到第二个定时器setTimeout，将其加入到红任务队列；\n执行script代码，打印出7，至此第一轮执行完成；\n指定微任务队列中的代码，打印出resolve的结果：5；\n执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；\n执行完这个宏任务，就开始执行微任务队列，打印出3；\n继续执行宏任务队列中的第二个定时器，打印出6。\n\n30. 代码输出结果Promise.resolve().then(() => &#123;\n    console.log('1');\n    throw 'Error';\n&#125;).then(() => &#123;\n    console.log('2');\n&#125;).catch(() => &#123;\n    console.log('3');\n    throw 'Error';\n&#125;).then(() => &#123;\n    console.log('4');\n&#125;).catch(() => &#123;\n    console.log('5');\n&#125;).then(() => &#123;\n    console.log('6');\n&#125;);\n复制代码\n\n执行结果如下：\n1 \n3 \n5 \n6\n复制代码\n\n在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。\n31. 代码输出结果setTimeout(function () &#123;\n  console.log(1);\n&#125;, 100);\n\nnew Promise(function (resolve) &#123;\n  console.log(2);\n  resolve();\n  console.log(3);\n&#125;).then(function () &#123;\n  console.log(4);\n  new Promise((resove, reject) => &#123;\n    console.log(5);\n    setTimeout(() =>  &#123;\n      console.log(6);\n    &#125;, 10);\n  &#125;)\n&#125;);\nconsole.log(7);\nconsole.log(8);\n复制代码\n\n输出结果为：\n2\n3\n7\n8\n4\n5\n6\n1\n复制代码\n\n代码执行过程如下：\n\n首先遇到定时器，将其加入到宏任务队列；\n遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；\n继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；\n执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；\n执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；\n此时微任务队列为空，继续执行宏任务队列，打印出1。\n\n做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。\n二、this1. 代码输出结果function foo() &#123;\n  console.log( this.a );\n&#125;\n\nfunction doFoo() &#123;\n  foo();\n&#125;\n\nvar obj = &#123;\n  a: 1,\n  doFoo: doFoo\n&#125;;\n\nvar a = 2; \nobj.doFoo()\n复制代码\n\n输出结果：2\n在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。\n2. 代码输出结果var a = 10\nvar obj = &#123;\n  a: 20,\n  say: () => &#123;\n    console.log(this.a)\n  &#125;\n&#125;\nobj.say() \n\nvar anotherObj = &#123; a: 30 &#125; \nobj.say.apply(anotherObj) \n复制代码\n\n输出结果：10  10\n我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。\n但是，如果是普通函数，那么就会有完全不一样的结果：\nvar a = 10  \nvar obj = &#123;  \n  a: 20,  \n  say()&#123;\n    console.log(this.a)  \n  &#125;  \n&#125;  \nobj.say()   \nvar anotherObj=&#123;a:30&#125;   \nobj.say.apply(anotherObj)\n复制代码\n\n输出结果：20 30\n这时，say方法中的this就会指向他所在的对象，输出其中的a的值。\n3. 代码输出结果function a() &#123;\n  console.log(this);\n&#125;\na.call(null);\n复制代码\n\n打印结果：window对象\n根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。\n要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：\n'use strict';\n\nfunction a() &#123;\n    console.log(this);\n&#125;\na.call(null); // null\na.call(undefined); // undefined\n复制代码\n\n4. 代码输出结果var obj = &#123; \n  name : 'cuggz', \n  fun : function()&#123; \n    console.log(this.name); \n  &#125; \n&#125; \nobj.fun()     // cuggz\nnew obj.fun() // undefined\n复制代码\n\n使用new构造函数时，其this指向的是全局环境window。\n6. 代码输出结果var obj = &#123;\n   say: function() &#123;\n     var f1 = () =>  &#123;\n       console.log(\"1111\", this);\n     &#125;\n     f1();\n   &#125;,\n   pro: &#123;\n     getPro:() =>  &#123;\n        console.log(this);\n     &#125;\n   &#125;\n&#125;\nvar o = obj.say;\no();\nobj.say();\nobj.pro.getPro();\n复制代码\n\n输出结果：\n1111 window对象\n1111 obj对象\nwindow对象\n复制代码\n\n解析：\n\no()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；\nobj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；\nobj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。\n\n7. 代码输出结果var myObject = &#123;\n    foo: \"bar\",\n    func: function() &#123;\n        var self = this;\n        console.log(this.foo);  \n        console.log(self.foo);  \n        (function() &#123;\n            console.log(this.foo);  \n            console.log(self.foo);  \n        &#125;());\n    &#125;\n&#125;;\nmyObject.func();\n复制代码\n\n输出结果：bar bar undefined bar\n解析：\n\n首先func是由myObject调用的，this指向myObject。又因为var self = this;所以self指向myObject。\n这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。\n\n8. 代码输出问题window.number = 2;\nvar obj = &#123;\n number: 3,\n db1: (function()&#123;\n   console.log(this);\n   this.number *= 4;\n   return function()&#123;\n     console.log(this);\n     this.number *= 5;\n   &#125;\n &#125;)()\n&#125;\nvar db1 = obj.db1;\ndb1();\nobj.db1();\nconsole.log(obj.number);     // 15\nconsole.log(window.number);  // 40\n复制代码\n\n这道题目看清起来有点乱，但是实际上是考察this指向的:\n\n执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；\n执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。\n\n9. 代码输出结果var length = 10;\nfunction fn() &#123;\n    console.log(this.length);\n&#125;\n \nvar obj = &#123;\n  length: 5,\n  method: function(fn) &#123;\n    fn();\n    arguments[0]();\n  &#125;\n&#125;;\n \nobj.method(fn, 1);\n复制代码\n\n输出结果： 10 2\n解析：\n\n第一次执行fn()，this指向window对象，输出10。\n第二次执行arguments0，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。\n\n10. 代码输出结果var a = 1;\nfunction printA()&#123;\n  console.log(this.a);\n&#125;\nvar obj=&#123;\n  a:2,\n  foo:printA,\n  bar:function()&#123;\n    printA();\n  &#125;\n&#125;\n\nobj.foo(); // 2\nobj.bar(); // 1\nvar foo = obj.foo;\nfoo(); // 1\n复制代码\n\n输出结果： 2 1 1\n解析：\n\nobj.foo()，foo 的this指向obj对象，所以a会输出2；\nobj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；\nfoo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；\n\n11. 代码输出结果var x = 3;\nvar y = 4;\nvar obj = &#123;\n    x: 1,\n    y: 6,\n    getX: function() &#123;\n        var x = 5;\n        return function() &#123;\n            return this.x;\n        &#125;();\n    &#125;,\n    getY: function() &#123;\n        var y = 7;\n        return this.y;\n    &#125;\n&#125;\nconsole.log(obj.getX()) // 3\nconsole.log(obj.getY()) // 6\n复制代码\n\n输出结果：3  6\n解析：\n\n我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；\ngetY是由obj调用的，所以其this指向的是obj对象，会打印出6。\n\n12. 代码输出结果 var a = 10; \n var obt = &#123; \n   a: 20, \n   fn: function()&#123; \n     var a = 30; \n     console.log(this.a)\n   &#125; \n &#125;\n obt.fn();  // 20\n obt.fn.call(); // 10\n (obt.fn)(); // 20\n复制代码\n\n输出结果： 20  10  20\n解析：\n\n obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；\n obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；\n (obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于  obt.fn()，所以会打印出 20；\n\n13. 代码输出结果function a(xx)&#123;\n  this.x = xx;\n  return this\n&#125;;\nvar x = a(5);\nvar y = a(6);\n\nconsole.log(x.x)  // undefined\nconsole.log(y.x)  // 6\n复制代码\n\n输出结果： undefined  6\n解析：\n\n最关键的就是var x = a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。所以 this.x = 5 就相当于：window.x = 5。之后 return this，也就是说 var x = a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。\n当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。\n\n14. 代码输出结果function foo(something)&#123;\n    this.a = something\n&#125;\n\nvar obj1 = &#123;\n    foo: foo\n&#125;\n\nvar obj2 = &#123;&#125;\n\nobj1.foo(2); \nconsole.log(obj1.a); // 2\n\nobj1.foo.call(obj2, 3);\nconsole.log(obj2.a); // 3\n\nvar bar = new obj1.foo(4)\nconsole.log(obj1.a); // 2\nconsole.log(bar.a); // 4\n复制代码\n\n输出结果： 2  3  2  4\n解析：\n\n首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；\n执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；\nobj1.a会打印出2；\n最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。\n\n15. 代码输出结果function foo(something)&#123;\n    this.a = something\n&#125;\n\nvar obj1 = &#123;&#125;\n\nvar bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1.a); // 2\n\nvar baz = new bar(3);\nconsole.log(obj1.a); // 2\nconsole.log(baz.a); // 3\n复制代码\n\n输出结果： 2  2  3\n这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：this绑定的优先级：new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。\n三、作用域&amp;变量提升&amp;闭包1. 代码输出结果(function()&#123;\n   var x = y = 1;\n&#125;)();\nvar z;\n\nconsole.log(y); // 1\nconsole.log(z); // undefined\nconsole.log(x); // Uncaught ReferenceError: x is not defined\n复制代码\n\n这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。\n2. 代码输出结果var a, b\n(function () &#123;\n   console.log(a);\n   console.log(b);\n   var a = (b = 3);\n   console.log(a);\n   console.log(b);   \n&#125;)()\nconsole.log(a);\nconsole.log(b);\n复制代码\n\n输出结果：\nundefined \nundefined \n3 \n3 \nundefined \n3\n复制代码\n\n这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。\n3. 代码输出结果var friendName = 'World';\n(function() &#123;\n  if (typeof friendName === 'undefined') &#123;\n    var friendName = 'Jack';\n    console.log('Goodbye ' + friendName);\n  &#125; else &#123;\n    console.log('Hello ' + friendName);\n  &#125;\n&#125;)();\n复制代码\n\n输出结果：Goodbye Jack\n我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：\nvar name = 'World!';\n(function () &#123;\n    var name;\n    if (typeof name === 'undefined') &#123;\n        name = 'Jack';\n        console.log('Goodbye ' + name);\n    &#125; else &#123;\n        console.log('Hello ' + name);\n    &#125;\n&#125;)();\n复制代码\n\n这样，答案就一目了然了。\n4. 代码输出结果function fn1()&#123;\n  console.log('fn1')\n&#125;\nvar fn2\n \nfn1()\nfn2()\n \nfn2 = function() &#123;\n  console.log('fn2')\n&#125;\n \nfn2()\n复制代码\n\n输出结果：\nfn1\nUncaught TypeError: fn2 is not a function\nfn2\n复制代码\n\n这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。\n5. 代码输出结果function a() &#123;\n    var temp = 10;\n    function b() &#123;\n        console.log(temp); // 10\n    &#125;\n    b();\n&#125;\na();\n\nfunction a() &#123;\n    var temp = 10;\n    b();\n&#125;\nfunction b() &#123;\n    console.log(temp); // 报错 Uncaught ReferenceError: temp is not defined\n&#125;\na();\n复制代码\n\n在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。\n6. 代码输出结果 var a=3;\n function c()&#123;\n    alert(a);\n &#125;\n (function()&#123;\n  var a=4;\n  c();\n &#125;)();\n复制代码\n\njs中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等\n7.  代码输出问题function fun(n, o) &#123;\n  console.log(o)\n  return &#123;\n    fun: function(m)&#123;\n      return fun(m, n);\n    &#125;\n  &#125;;\n&#125;\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);\n复制代码\n\n输出结果：\nundefined  0  0  0\nundefined  0  1  2\nundefined  0  1  1\n复制代码\n\n这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 console.log(o); 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。\n8. 代码输出结果f = function() &#123;return true;&#125;;   \ng = function() &#123;return false;&#125;;   \n(function() &#123;   \n   if (g() &amp;&amp; [] == ![]) &#123;   \n      f = function f() &#123;return false;&#125;;   \n      function g() &#123;return true;&#125;   \n   &#125;   \n&#125;)();   \nconsole.log(f());\n复制代码\n\n输出结果： false\n这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。\n第二个条件是[] == ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。\n两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。\n四、原型&amp;继承1. 代码输出结果function Person(name) &#123;\n    this.name = name\n&#125;\nvar p2 = new Person('king');\nconsole.log(p2.__proto__) //Person.prototype\nconsole.log(p2.__proto__.__proto__) //Object.prototype\nconsole.log(p2.__proto__.__proto__.__proto__) // null\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错\nconsole.log(p2.constructor)//Person\nconsole.log(p2.prototype)//undefined p2是实例，没有prototype属性\nconsole.log(Person.constructor)//Function 一个空函数\nconsole.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性\nconsole.log(Person.prototype.constructor)//Person\nconsole.log(Person.prototype.__proto__)// Object.prototype\nconsole.log(Person.__proto__) //Function.prototype\nconsole.log(Function.prototype.__proto__)//Object.prototype\nconsole.log(Function.__proto__)//Function.prototype\nconsole.log(Object.__proto__)//Function.prototype\nconsole.log(Object.prototype.__proto__)//null\n复制代码\n\n这道义题目考察原型、原型链的基础，记住就可以了。\n2. 代码输出结果// a\nfunction Foo () &#123;\n getName = function () &#123;\n   console.log(1);\n &#125;\n return this;\n&#125;\n// b\nFoo.getName = function () &#123;\n console.log(2);\n&#125;\n// c\nFoo.prototype.getName = function () &#123;\n console.log(3);\n&#125;\n// d\nvar getName = function () &#123;\n console.log(4);\n&#125;\n// e\nfunction getName () &#123;\n console.log(5);\n&#125;\n\nFoo.getName();           // 2\ngetName();               // 4\nFoo().getName();         // 1\ngetName();               // 1 \nnew Foo.getName();       // 2\nnew Foo().getName();     // 3\nnew new Foo().getName(); // 3\n复制代码\n\n输出结果：2  4  1  1  2  3  3\n解析：\n\nFoo.getName()， Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；\ngetName()， 这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；\n** Foo().getName()，** 这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；\ngetName()， 上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；\nnew Foo.getName()， 这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；\nnew Foo().getName()， 这 里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.protot === Foo.prototype，所以输出 3；\nnew new Foo().getName()， 这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。\n\n3. 代码输出结果var F = function() &#123;&#125;;\nObject.prototype.a = function() &#123;\n  console.log('a');\n&#125;;\nFunction.prototype.b = function() &#123;\n  console.log('b');\n&#125;\nvar f = new F();\nf.a();\nf.b();\nF.a();\nF.b()\n复制代码\n\n输出结果：\na\nUncaught TypeError: f.b is not a function\na\nb\n复制代码\n\n解析：\n\nf 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a ，而 f.b() 就报错了。\nF 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof Object === true，F instanceof Function === true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。\n\n4. 代码输出结果function Foo()&#123;\n    Foo.a = function()&#123;\n        console.log(1);\n    &#125;\n    this.a = function()&#123;\n        console.log(2)\n    &#125;\n&#125;\n\nFoo.prototype.a = function()&#123;\n    console.log(3);\n&#125;\n\nFoo.a = function()&#123;\n    console.log(4);\n&#125;\n\nFoo.a();\nlet obj = new Foo();\nobj.a();\nFoo.a();\n复制代码\n\n输出结果：4 2 1\n解析：\n\nFoo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4\nlet obj = new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。\nobj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2\nFoo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1\n\n5. 代码输出结果function Dog() &#123;\n  this.name = 'puppy'\n&#125;\nDog.prototype.bark = () => &#123;\n  console.log('woof!woof!')\n&#125;\nconst dog = new Dog()\nconsole.log(Dog.prototype.constructor === Dog &amp;&amp; dog.constructor === Dog &amp;&amp; dog instanceof Dog)\n复制代码\n\n输出结果：true\n解析： 因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。\nconstructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。\n6. 代码输出结果var A = &#123;n: 4399&#125;;\nvar B =  function()&#123;this.n = 9999&#125;;\nvar C =  function()&#123;var n = 8888&#125;;\nB.prototype = A;\nC.prototype = A;\nvar b = new B();\nvar c = new C();\nA.n++\nconsole.log(b.n);\nconsole.log(c.n);\n复制代码\n\n输出结果：9999  4400\n解析：\n\nconsole.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b = new B()时，函数内部this.n=9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。\nconsole.log(c.n)，同理，当执行var c = new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。\n\n7. 代码输出问题function A()&#123;\n&#125;\nfunction B(a)&#123;\n　　this.a = a;\n&#125;\nfunction C(a)&#123;\n　　if(a)&#123;\nthis.a = a;\n　　&#125;\n&#125;\nA.prototype.a = 1;\nB.prototype.a = 1;\nC.prototype.a = 1;\n \nconsole.log(new A().a);\nconsole.log(new B().a);\nconsole.log(new C(2).a);\n复制代码\n\n输出结果：1  undefined  2\n解析：\n\nconsole.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；\nconsole.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;\nconsole.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a = 2,故属性a的值为2。\n\n8 代码输出问题function Parent() &#123;\n    this.a = 1;\n    this.b = [1, 2, this.a];\n    this.c = &#123; demo: 5 &#125;;\n    this.show = function () &#123;\n        console.log(this.a , this.b , this.c.demo );\n    &#125;\n&#125;\n\nfunction Child() &#123;\n    this.a = 2;\n    this.change = function () &#123;\n        this.b.push(this.a);\n        this.a = this.b.length;\n        this.c.demo = this.a++;\n    &#125;\n&#125;\n\nChild.prototype = new Parent();\nvar parent = new Parent();\nvar child1 = new Child();\nvar child2 = new Child();\nchild1.a = 11;\nchild2.a = 12;\nparent.show();\nchild1.show();\nchild2.show();\nchild1.change();\nchild2.change();\nparent.show();\nchild1.show();\nchild2.show();\n复制代码\n\n输出结果：\nparent.show(); // 1  [1,2,1] 5\n\nchild1.show(); // 11 [1,2,1] 5\nchild2.show(); // 12 [1,2,1] 5\n\nparent.show(); // 1 [1,2,1] 5\n\nchild1.show(); // 5 [1,2,1,11,12] 5\n\nchild2.show(); // 6 [1,2,1,11,12] 5\n复制代码\n\n这道题目值得神帝，他涉及到的知识点很多，例如this的指向、原型、原型链、类的继承、数据类型等。\n解析：\n\nparent.show()，可以直接获得所需的值，没啥好说的；\nchild1.show()，Child的构造函数原本是指向Child的，题目显式将Child类的原型对象指向了Parent类的一个实例，需要注意Child.prototype指向的是Parent的实例parent，而不是指向Parent这个类。\nchild2.show()，这个也没啥好说的；\nparent.show()，parent是一个Parent类的实例，Child.prorotype指向的是Parent类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响parent实例，所以输出结果不变；\nchild1.show()，child1执行了change()方法后，发生了怎样的变化呢?\n\n\nthis.b.push(this.a)，**由于this的动态指向特性，this.b会指向Child.prototype上的**b**数组,this.a会指向child1的a属性,所以Child.prototype.b变成了[1,2,1,11]**;\n**this.a = this.b.length，*这条语句中this.a和this.b的指向与上一句一致，故结果为child1.a变为*4;\nthis.c.demo = this.a++，**由于child1自身属性并没有**c**这个属性，所以此处的this.c会指向Child.prototype.c，this.a值为4，为原始类型，故赋值操作时会直接赋值，Child.prototype.c.demo的结果为4，而this.a随后自增为5(4 + 1 = 5)。**\n\n\nchild2执行了change()方法, 而child2和child1均是Child类的实例，所以他们的原型链指向同一个原型对象Child.prototype,也就是同一个parent实例，所以child2.change()中所有影响到原型对象的语句都会影响child1的最终输出结果。\n\n\nthis.b.push(this.a)，**由于this的动态指向特性，this.b会指向Child.prototype上的**b**数组,this.a会指向child2的a属性,所以Child.prototype.b变成了[1,2,1,11,12]**;\n**this.a = this.b.length，*这条语句中this.a和this.b的指向与上一句一致，故结果为child2.a变为*5;\nthis.c.demo = this.a++，**由于child2自身属性并没有**c**这个属性，所以此处的this.c会指向Child.prototype.c，故执行结果为Child.prototype.c.demo的值变为child2.a的值5，而child2.a最终自增为6(5 + 1 = 6)。**\n\n9. 代码输出结果function SuperType()&#123;\n    this.property = true;\n&#125;\n\nSuperType.prototype.getSuperValue = function()&#123;\n    return this.property;\n&#125;;\n\nfunction SubType()&#123;\n    this.subproperty = false;\n&#125;\n\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function ()&#123;\n    return this.subproperty;\n&#125;;\n\nvar instance = new SubType();\nconsole.log(instance.getSuperValue());\n复制代码\n\n输出结果：true\n实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下： \n","slug":"代码输出题","date":"2022-04-10T12:23:34.000Z","categories_index":"知识点","tags_index":"面试","author_index":"LIYUNFU"},{"id":"50772cbc2a7ccf0256f62abf804cb4b7","title":"浏览器原理和计算机网络面试题","content":"计算机网络一、HTTP协议1. GET和POST的请求的区别Post 和 Get 是 HTTP 请求的两种方法，其区别如下：\n\n应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。\n发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。\n安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。\n参数类型： post 的参数传递支持更多的数据类型。\n\n2. POST和PUT请求的区别\nPUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）\nPOST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）\n\n3. 常见的HTTP请求头和响应头HTTP Request Header 常见的请求头：\n\nAccept:浏览器能够处理的内容类型\nAccept-Charset:浏览器能够显示的字符集\nAccept-Encoding：浏览器能够处理的压缩编码\nAccept-Language：浏览器当前设置的语言\nConnection：浏览器与服务器之间连接的类型\nCookie：当前页面设置的任何Cookie\nHost：发出请求的页面所在的域\nReferer：发出请求的页面的URL\nUser-Agent：浏览器的用户代理字符串\n\nHTTP Responses Header 常见的响应头：\n\nDate：表示消息发送的时间，时间的描述格式由rfc822定义\nserver:服务器名称\nConnection：浏览器与服务器之间连接的类型\nCache-Control：控制HTTP缓存\ncontent-type:表示后面的文档属于什么MIME类型\n\n常见的 Content-Type 属性值有以下四种：\n（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。\n（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。\n（3）application/json：服务器消息主体是序列化后的 JSON 字符串。\n（4）text/xml：该种方式主要用来提交 XML 格式的数据。\n4. HTTP状态码304是多好还是少好服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。\n状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。\n搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。\n产生较多304状态码的原因：\n\n页面更新周期长或不更新\n纯静态页面或强制生成静态html\n\n304状态码出现过多会造成以下问题：\n\n网站快照停止；\n收录减少；\n权重下降。\n\n5. 常见的HTTP请求方法\nGET: 向服务器获取数据；\nPOST：将实体提交到指定的资源，通常会造成服务器资源的修改；\nPUT：上传文件，更新数据；\nDELETE：删除服务器上的对象；\nHEAD：获取报文首部，与GET相比，不返回报文主体部分；\nOPTIONS：询问支持的请求方法，用来跨域请求；\nCONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；\nTRACE: 回显服务器收到的请求，主要⽤于测试或诊断。\n\n6. OPTIONS请求方法及使用场景OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。\nOPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。\nOPTIONS请求方法的主要用途有两个：\n\n获取服务器支持的所有HTTP请求方法；\n用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n\n7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？HTTP 1.0和 HTTP 1.1 有以下区别：\n\n连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。\n资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。\nhttp1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。\nhttp1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。\n\n8. HTTP 1.1 和 HTTP 2.0 的区别\n二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。\n多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。\n数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。\n头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。\n服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。\n\n【1】队头堵塞：\n\n\n\n\n\n\n\n\n\n队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。\n9. HTTP和HTTPS协议的区别HTTP和HTTPS协议的主要区别如下：\n\nHTTPS协议需要CA证书，费用较高；而HTTP协议不需要；\nHTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；\n使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；\nHTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。\n\n10. GET方法URL长度限制的原因实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。\nGET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）\n复制代码\n\n下面看一下主流浏览器对get方法中url的长度限制范围：\n\nMicrosoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。\nFirefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。\nSafari (Browser)：URL最大长度限制为 80,000 个字符。\nOpera (Browser)：URL最大长度限制为 190,000 个字符。\nGoogle (chrome)：URL最大长度限制为 8182 个字符。\n\n主流的服务器对get方法中url的长度限制范围：\n\nApache (Server)：能接受最大url长度为8192个字符。\nMicrosoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。\n\n根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。\n11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？（1）解析URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。\n（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。\n（3）DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。\n（4）获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。\n（5）TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。\n（6）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。\n（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。\n（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。\n（9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。\n12. 对keep-alive的理解HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是长连接。其使用方法如下：\n\nHTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送Connection: keep-alive字段。若想断开keep-alive连接，需发送Connection:close字段；\nHTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送Connection：close首部字段。\n\nKeep-Alive的建立过程：\n\n客户端向服务器在发送请求报文同时在首部添加发送Connection字段\n服务器收到请求并处理 Connection字段\n服务器回送Connection:Keep-Alive字段给客户端\n客户端接收到Connection字段\nKeep-Alive连接建立成功\n\n服务端自动断开过程（也就是没有keep-alive）：\n\n客户端向服务器只是发送内容报文（不包含Connection字段）\n服务器收到请求并处理\n服务器返回客户端请求的资源并关闭连接\n客户端接收资源，发现没有Connection字段，断开连接\n\n客户端请求断开连接过程：\n\n客户端向服务器发送Connection:close字段\n服务器收到请求并处理connection字段\n服务器回送响应资源并断开连接\n客户端接收资源并断开连接\n\n开启Keep-Alive的优点：\n\n较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；\n允许请求和应答的HTTP管线化；\n降低拥塞控制 （TCP连接减少了）；\n减少了后续请求的延迟（⽆需再进⾏握⼿）；\n报告错误⽆需关闭TCP连；\n\n开启Keep-Alive的缺点：\n\n长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。\n\n13. 页面有多张图片，HTTP是怎样的加载表现？\n在HTTP 1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。\n在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。\n\n14. HTTP2的头部压缩算法是怎样的？HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。\n具体来说:\n\n在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；\n首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；\n每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。 \n15. HTTP请求报文的是什么样的？请求报⽂有4部分组成:\n\n请求⾏\n请求头部\n空⾏\n请求体\n\n 其中： （1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 （2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔\n\nUser-Agent：产⽣请求的浏览器类型。\nAccept：客户端可识别的内容类型列表。\nHost：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。\n\n（3）请求体: post put等请求携带的数据 \n16. HTTP响应报文的是什么样的？请求报⽂有4部分组成:\n\n响应⾏\n响应头\n空⾏\n响应体\n\n\n\n响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。\n响应头：响应部⾸组成\n响应体：服务器响应的数据\n\n17. HTTP协议的优点和缺点HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。\nHTTP协议具有以下优点：\n\n支持客户端/服务器模式\n简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。\n无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。\n无状态：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。\n灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。\n\nHTTP协议具有以下缺点：\n\n无状态： HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。\n明文传输： 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。\n不安全\n\n（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；\n18. 说一下HTTP 3.0HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。 \n\n流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。\n集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。\n多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。\n\n\n\n快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。\n\n19. HTTP协议的性能怎么样HTTP 协议是基于 TCP/IP，并且使用了请求-应答的通信模式，所以性能的关键就在这两点里。\n\n长连接\n\nHTTP协议有两种连接模式，一种是持续连接，一种非持续连接。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。\n对于不同版本的采用不同的连接方式：\n\n在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。\n在HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。\n\n\n\n管道网络传输\n\nHTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。\n管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。\n\n队头堵塞\n\nHTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。\n队头阻塞的解决方案： （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。\n20. URL有哪些组成部分以下面的URL为例：**www.aspxfans.com:8080/news/index.…**\n从上面的URL可以看出，一个完整的URL包括以下几部分：\n\n协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符；\n域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用\n端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；\n虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；\n文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；\n锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；\n参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。\n\n21. 与缓存相关的HTTP请求头有哪些强缓存：\n\nExpires\nCache-Control\n\n协商缓存：\n\nEtag、If-None-Match\nLast-Modified、If-Modified-Since\n\n二、HTTPS协议1. 什么是HTTPS协议？超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。  HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。\n安全层的主要职责就是对发起的HTTP请求的数据进行加密操作 和 对接收到的HTTP的内容进行解密操作。\n2. TLS/SSL的工作原理TLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。\nTLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：\n\n基于散列函数验证信息的完整性\n对称加密算法采用协商的秘钥对数据加密\n非对称加密实现身份认证和秘钥协商\n\n\n（1）散列函数hash常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。\n特点： 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。\n（2）对称加密对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。\n常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。\n特点： 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。\n（3）非对称加密非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。\n常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。\n特点： 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。\n综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。\n3. 数字证书是什么？现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。\n首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。\n这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。 \n4. HTTPS通信（握手）过程HTTPS的通信过程如下：\n\n客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。\n服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。\n客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。\n服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。\n客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。\n\n5. HTTPS的特点HTTPS的优点如下：\n\n使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；\n使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；\nHTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；\n\nHTTPS的缺点如下：\n\nHTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；\nHTTPS协议握手阶段比较费时，增加页面的加载时间；\nSSL证书是收费的，功能越强大的证书费用越高；\nHTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；\nSSL证书需要绑定IP，不能再同一个IP上绑定多个域名。\n\n6. HTTPS是如何保证安全的？先理解两个概念：\n\n对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。\n⾮对称加密：\n\n\n私钥 + 公钥= 密钥对\n即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密\n因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅\n然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密\n\n⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。\n解决⽅案：\n结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。\n此时⼜带来⼀个问题，中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。\n所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。\n但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。\n数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。\n三、HTTP状态码状态码的类别：\n\n\n\n类别\n原因\n描述\n\n\n\n1xx\nInformational(信息性状态码)\n接受的请求正在处理\n\n\n2xx\nSuccess(成功状态码)\n请求正常处理完毕\n\n\n3xx\nRedirection(重定向状态码)\n需要进行附加操作一完成请求\n\n\n4xx\nClient Error (客户端错误状态码)\n服务器无法处理请求\n\n\n5xx\nServer Error(服务器错误状态码)\n服务器处理请求出错\n\n\n1. 2XX (Success 成功状态码)状态码2XX表示请求被正常处理了。\n（1）200 OK200 OK表示客户端发来的请求被服务器端正常处理了。\n（2）204 No Content该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。\n（3）206 Partial Content该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n2. 3XX (Redirection 重定向状态码)3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n（1）301 Moved Permanently永久重定向。 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。\n使用场景：\n\n当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。\n在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。\n\n（2）302 Found临时重定向。 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。\n使用场景：\n\n当我们在做活动时，登录到首页自动重定向，进入活动页面。\n未登陆的用户访问用户中心重定向到登录页面。\n访问404页面重新定向到首页。\n\n（3）303 See Other该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。\n303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。\n注意：\n\n当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。\n301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。\n\n（4）304 Not Modified浏览器缓存相关。 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。\n带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（if-match、if-none-match、if-modified-since、if-unmodified-since、if-range）中任意首部。\n状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。\n（5）307 Temporary Redirect307表示临时重定向。 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。\n307 会遵守浏览器标准，不会从 POST 变成 GET。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。\n3. 4XX (Client Error 客户端错误状态码)4XX 的响应结果表明客户端是发生错误的原因所在。\n（1）400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。\n（2）401 Unauthorized该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败\n返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n以下情况会出现401：\n\n401.1 - 登录失败。\n401.2 - 服务器配置导致登录失败。\n401.3 - 由于 ACL 对资源的限制而未获得授权。\n401.4 - 筛选器授权失败。\n401.5 - ISAPI/CGI 应用程序授权失败。\n401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。\n\n（3）403 Forbidden该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。\nIIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：\n\n403.1 - 执行访问被禁止。\n403.2 - 读访问被禁止。\n403.3 - 写访问被禁止。\n403.4 - 要求 SSL。\n403.5 - 要求 SSL 128。\n403.6 - IP 地址被拒绝。\n403.7 - 要求客户端证书。\n403.8 - 站点访问被拒绝。\n403.9 - 用户数过多。\n403.10 - 配置无效。\n403.11 - 密码更改。\n403.12 - 拒绝访问映射表。\n403.13 - 客户端证书被吊销。\n403.14 - 拒绝目录列表。\n403.15 - 超出客户端访问许可。\n403.16 - 客户端证书不受信任或无效。\n403.17 - 客户端证书已过期或尚未生效\n403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。\n403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。\n403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。\n\n（4）404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：\n\n404.0 -（无） – 没有找到文件或目录。\n404.1 - 无法在所请求的端口上访问 Web 站点。\n404.2 - Web 服务扩展锁定策略阻止本请求。\n404.3 - MIME 映射策略阻止本请求。\n\n（5）405 Method Not Allowed该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下\nAccess-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE\n复制代码\n\n4. 5XX (Server Error 服务器错误状态码)5XX 的响应结果表明服务器本身发生错误.\n（1）500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。\n（2）502 Bad Gateway该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：\n\n502.1 - CGI （通用网关接口）应用程序超时。\n502.2 - CGI （通用网关接口）应用程序出错。\n\n（3）503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。\n使用场景：\n\n服务器停机维护时，主动用503响应请求；\nnginx 设置限速，超过限速，会返回503。\n\n（4）504 Gateway Timeout该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。\n使用场景：代码执行时间超时，或者发生了死循环。\n5. 总结（1）2XX 成功\n\n200 OK，表示从客户端发来的请求在服务器端被正确处理\n204 No content，表示请求成功，但响应报文不含实体的主体部分\n205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容\n206 Partial Content，进行范围请求\n\n（2）3XX 重定向\n\n301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n302 found，临时性重定向，表示资源临时被分配了新的 URL\n303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源\n304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求\n\n（3）4XX 客户端错误\n\n400 bad request，请求报文存在语法错误\n401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n403 forbidden，表示对请求资源的访问被服务器拒绝\n404 not found，表示在服务器上没有找到请求的资源\n\n（4）5XX 服务器错误\n\n500 internal sever error，表示服务器端在执行请求时发生了错误\n501 Not Implemented，表示服务器不支持当前请求所需要的某个功能\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n\n6. 同样是重定向，307，303，302的区别？302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。\n四、DNS协议介绍1. DNS 协议是什么概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。\n2. DNS同时使用TCP和UDP协议？DNS占用53号端口，同时使用TCP和UDP协议。 （1）在区域传输的时候使用TCP协议\n\n辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。\nTCP是一种可靠连接，保证了数据的准确性。\n\n（2）在域名解析的时候使用UDP协议\n\n客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。\n\n3. DNS完整的查询过程DNS服务器解析域名的过程：\n\n首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步\n将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步\n本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址\n本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址\n本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果\n本地DNS服务器将返回结果保存在缓存中，便于下次使用\n本地DNS服务器将返回结果返回给浏览器\n\n比如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。\n4. 迭代查询与递归查询实际上，DNS解析是一个包含迭代查询和递归查询的过程。\n\n递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。\n迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。\n\n一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。\n5. DNS 记录和报文DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为\n（Name，Value，Type，TTL）\n复制代码\n\n其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。\n常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：\n\n如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。\n如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。\n如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。\n如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。\n\n五、网络模型1. OSI七层模型ISO为了更好的使网络应用更为普及，推出了OSI参考模型。 \n（1）应用层OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。\n\n在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(hyper text transfer protocol)(超文本传输协议)或者https.在后端设计数据接口时，我们常常使用到这个协议。\nFTP是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。\nSMTP是simple mail transfer protocol（简单邮件传输协议）。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。\n\n（2）表示层表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。\n在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。\n（3）会话层会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n（4）传输层传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。\n（5）网络层本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。\n（6）数据链路层将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。\n（7）物理层实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。\nOSI七层模型通信特点：对等通信 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。\n2. TCP/IP五层协议TCP/IP五层协议和OSI的七层协议对应关系如下： \n\n**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。\n\n传输层 (transport layer)\n：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：\n\n传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；\n用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。\n\n\n**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。\n\n**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。\n\n**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。\n\n\n从上图中可以看出，TCP/IP模型比OSI模型更加简洁，它把应用层/表示层/会话层全部整合为了应用层。\n在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。  在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议： \n同样，TCP/IP五层协议的通信方式也是对等通信： \n六、TCP与UDP1. TCP 和 UDP的概念及特点TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：\n（1）UDP\nUDP的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n它的特点如下：\n1）面向无连接\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n具体来说就是：\n\n在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n2）有单播，多播，广播的功能\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n3）面向报文\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n4）不可靠性\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n5）头部开销小，传输数据报文时是很高效的。 \nUDP 头部包含了以下几个数据：\n\n两个十六位的端口号，分别为源端口（可选字段）和目标端口\n整个数据报文的长度\n整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误\n\n因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。\n（2）TCP TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。\n它有以下几个特点：\n1）面向连接\n面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\n2）仅支持单播传输\n每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\n3）面向字节流\nTCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\n4）可靠传输\n对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\n5）提供拥塞控制\n当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。\n6）提供全双工通信\nTCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）\n2. TCP和UDP的区别\n\n\n\nUDP\nTCP\n\n\n\n是否连接\n无连接\n面向连接\n\n\n是否可靠\n不可靠传输，不使用流量控制和拥塞控制\n可靠传输（数据顺序和正确性），使用流量控制和拥塞控制\n\n\n连接对象个数\n支持一对一，一对多，多对一和多对多交互通信\n只能是一对一通信\n\n\n传输方式\n面向报文\n面向字节流\n\n\n首部开销\n首部开销小，仅8字节\n首部最小20字节，最大60字节\n\n\n适用场景\n适用于实时应用，例如视频会议、直播\n适用于要求可靠传输的应用，例如文件传输\n\n\n3. TCP和UDP的使用场景\nTCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\nUDP应用场景： 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。\n\n4. UDP协议为什么不可靠？UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：\n\n不保证消息交付：不确认，不重传，无超时\n不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞\n不跟踪连接状态：不必建立连接或重启状态机\n不进行拥塞控制：不内置客户端或网络反馈机制\n\n5. TCP的重传机制由于TCP的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。\nTCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。\n6. TCP的拥塞控制机制TCP的拥塞控制机制主要是以下四种机制：\n\n慢启动（慢开始）\n拥塞避免\n快速重传\n快速恢复\n\n（1）慢启动（慢开始）\n\n在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）\n思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。\n为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)\n当cnwd &lt; ssthresh，使用慢开始算法\n当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法\n当cnwd &gt; ssthresh，使用拥塞避免算法\n\n\n\n（2）拥塞避免\n\n拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。\n思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一\n无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:  其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。\n\n（3）快速重传\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量\n\n（4）快速恢复\n\n当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 \n\n7. TCP的流量控制机制一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。\n\n当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。\n当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）\n如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。\n如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。\n\n8. TCP的可靠传输机制TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。\nTCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。\n接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。\n发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。\n但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。\n9. TCP的三次握手和四次挥手（1）三次握手 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。\n刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。\n\n第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。\n\n\n\n\n\n\n\n\n\n\n首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。\n\n第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。\n\n\n\n\n\n\n\n\n\n\n在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y\n\n第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。\n\n\n\n\n\n\n\n\n\n\n确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。\n那为什么要三次握手呢？两次不行吗？\n\n为了确认双方的接收能力和发送能力都正常\n如果是用两次握手，则会出现下面这种情况：\n\n\n\n\n\n\n\n\n\n\n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\n简单来说就是以下三步：\n\n第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。\n第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。\n第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。\n\nTCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。\n（2）四次挥手 刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：\n\n第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。\n\n\n\n\n\n\n\n\n\n\n即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。\n\n第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。\n\n\n\n\n\n\n\n\n\n\n即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。\n\n第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。\n\n\n\n\n\n\n\n\n\n\n即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。\n\n第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。\n\n\n\n\n\n\n\n\n\n\n即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。\n那为什么需要四次挥手呢？\n\n\n\n\n\n\n\n\n\n因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。\n简单来说就是以下四步：\n\n第一次挥手： 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。\n第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。\n第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。\n第四次挥手： 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。\n\nTCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。\n最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。\n10. TCP粘包是怎么回事，如何处理?默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.\n如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.\n下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: A. 先接收到 data1, 然后接收到 data2 . B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. D. ⼀次性接收到了 data1 和 data2 的全部数据.\n其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:\n\n多次发送之前间隔⼀个等待时间：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.\n关闭 Nagle 算法：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)\n进⾏封包/拆包： 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。\n\n11. 为什么udp不会粘包？\nTCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据\nUDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。\n\n七、WebSocket1. 对 WebSocket 的理解WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。\nWebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。\nWebSocket原理：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。 \nWebSocket 特点的如下：\n\n支持双向通信，实时性更强\n可以发送文本，也可以发送二进制数据‘’\n建立在TCP协议之上，服务端的实现比较容易\n数据格式比较轻量，性能开销小，通信高效\n没有同源限制，客户端可以与任意服务器通信\n协议标识符是ws（如果加密，则为wss），服务器网址就是 URL\n与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n\nWebsocket的使用方法如下： \n在客户端中：\n// 在index.html中直接写WebSocket，设置服务端的端口号为 9999\nlet ws = new WebSocket('ws://localhost:9999');\n// 在客户端与服务端建立连接后触发\nws.onopen = function() &#123;\n    console.log(\"Connection open.\"); \n    ws.send('hello');\n&#125;;\n// 在服务端给客户端发来消息的时候触发\nws.onmessage = function(res) &#123;\n    console.log(res);       // 打印的是MessageEvent对象\n    console.log(res.data);  // 打印的是收到的消息\n&#125;;\n// 在客户端与服务端建立关闭后触发\nws.onclose = function(evt) &#123;\n  console.log(\"Connection closed.\");\n&#125;; \n复制代码\n\n2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。\n短轮询的基本思路： 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。\n长轮询的基本思路： 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。\nSSE 的基本思想： 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。\nWebSocket 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。\n上面的四个通信协议，前三个都是基于HTTP协议的。\n对于这四种即使通信协议，从性能的角度来看： WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： 短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket 所以，还是要根据具体的使用场景来判断使用哪种方式。\n浏览器原理一、浏览器安全1.  什么是 XSS 攻击？（1）概念XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。\nXSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。\n攻击者可以通过这种攻击方式可以进行以下操作：\n\n获取页面的数据，如DOM、cookie、localStorage；\nDOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；\n破坏页面结构；\n流量劫持（将链接指向某网站）；\n\n（2）攻击类型XSS 可以分为存储型、反射型和 DOM 型：\n\n存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。\n反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 \nDOM 型指的通过修改页面的 DOM 节点形成的 XSS。\n\n1）存储型 XSS 的攻击步骤：\n\n攻击者将恶意代码提交到⽬标⽹站的数据库中。\n⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。\n2）反射型 XSS 的攻击步骤：\n\n攻击者构造出特殊的 URL，其中包含恶意代码。\n⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。\n反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。\n3）DOM 型 XSS 的攻击步骤：\n\n攻击者构造出特殊的 URL，其中包含恶意代码。\n⽤户打开带有恶意代码的 URL。\n⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。\n2. 如何防御 XSS 攻击？可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：\n\n可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。\n使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。\n\n\n\n\n\n\n\n\n\n\n\nCSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。\n通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 \n\n\n对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。\n\n3. 什么是 CSRF 攻击？（1）概念CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。\nCSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。\n（2）攻击类型常见的 CSRF 攻击有三种：\n\nGET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。\nPOST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。\n链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。\n\n4. 如何防御 CSRF 攻击？CSRF 攻击可以使用以下方法来防护：\n\n进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）\n使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。\n对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。\n在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。\n\n5. 什么是中间人攻击？如何防范中间人攻击？中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。\n攻击过程如下:\n\n客户端发送请求到服务端，请求被中间⼈截获\n服务器向客户端发送公钥\n中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个伪造的公钥，发给客户端\n客户端收到伪造的公钥后，⽣成加密hash值发给服务器\n中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器\n服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端\n\n6. 有哪些可能引起前端安全的问题?\n跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；\niframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；\n跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击\n恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。\n\n7. 网络劫持有哪几种，如何防范？⽹络劫持分为两种:\n（1）DNS劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)\n\nDNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器\n302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容\n\n（2）HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)\nDNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。\n二、进程与线程1. 进程与线程的概念从本质上说，进程和线程都是 CPU 工作时间片的一个描述：\n\n进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。\n线程是进程中的更小单位，描述了执行一段指令所需的时间。\n\n进程是资源分配的最小单位，线程是CPU调度的最小单位。\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。\n如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。\n进程和线程之间的关系有以下四个特点：\n（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。\n（2）线程之间共享进程中的数据。\n（3）当一个进程关闭之后，操作系统会回收进程所占用的内存， 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n（4）进程之间的内容相互隔离。 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。\nChrome浏览器的架构图：  从图中可以看出，最新的 Chrome 浏览器包括：\n\n1 个浏览器主进程\n1 个 GPU 进程\n1 个网络进程\n多个渲染进程\n多个插件进程\n\n这些进程的功能：\n\n浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\nGPU 进程：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n所以，打开一个网页，最少需要四个进程：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。\n虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：\n\n更高的资源占用：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。\n更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。\n\n2. 进程和线程的区别\n进程可以看做独立应用，线程不能\n资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。\n通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。\n调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。\n\n3. 浏览器渲染进程的线程有哪些浏览器的渲染进程的线程总共有五种：  （1）GUI渲染线程 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。\n注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n（2）JS引擎线程 JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；\n注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n（3）时间触发线程 时间触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；\n注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；\n（4）定时器触发进程 定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；\n注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。\n（5）异步http请求线程\n\nXMLHttpRequest连接后通过浏览器新开一个线程请求；\n检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；\n\n4. 进程之前的通信方式（1）管道通信\n管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。\n管道的特点：\n\n只能单向通信\n只能血缘关系的进程进行通信\n依赖于文件系统\n生命周期随进程\n面向字节流的服务\n管道内部提供了同步机制\n\n（2）消息队列通信\n消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。\n使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。\n（3）信号量通信\n共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。\n（4）信号通信\n信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。\n（5）共享内存通信\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。\n（6）套接字通信\n上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。\n5. 僵尸进程和孤儿进程是什么？\n孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。\n僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。\n\n6. 死锁产生的原因？ 如果解决死锁的问题？所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。\n系统中的资源可以分为两类：\n\n可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；\n不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。\n\n产生死锁的原因：\n（1）竞争资源\n\n产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）\n产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁\n\n（2）进程间推进顺序非法\n若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁\n产生死锁的必要条件：\n\n互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。\n请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。\n不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。\n环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。\n\n预防死锁的方法：\n\n资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）\n只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）\n可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）\n资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）\n\n7. 如何实现浏览器内多个标签页之间的通信?实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：\n\n使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。\n使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。\n使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。\n使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。\n\n8. 对Service Worker的理解Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。\nService Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：\n// index.js\nif (navigator.serviceWorker) &#123;\n  navigator.serviceWorker\n    .register('sw.js')\n    .then(function(registration) &#123;\n      console.log('service worker 注册成功')\n    &#125;)\n    .catch(function(err) &#123;\n      console.log('servcie worker 注册失败')\n    &#125;)\n&#125;\n// sw.js\n// 监听 `install` 事件，回调中缓存所需文件\nself.addEventListener('install', e => &#123;\n  e.waitUntil(\n    caches.open('my-cache').then(function(cache) &#123;\n      return cache.addAll(['./index.html', './index.js'])\n    &#125;)\n  )\n&#125;)\n// 拦截所有请求事件\n// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据\nself.addEventListener('fetch', e => &#123;\n  e.respondWith(\n    caches.match(e.request).then(function(response) &#123;\n      if (response) &#123;\n        return response\n      &#125;\n      console.log('fetch source')\n    &#125;)\n  )\n&#125;)\n复制代码\n\n打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了：  在 Cache 中也可以发现所需的文件已被缓存： \n三、浏览器缓存1. 对浏览器的缓存机制的理解浏览器缓存的全过程：\n\n浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；\n下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；\n如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；\n服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；\n如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；\n\n 很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。\n2. 浏览器资源缓存的位置有哪些？资源缓存的位置一共有 3 种，按优先级从高到低分别是：\n\nService Worker：**Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。当 Service Worker 没有命中缓存的时候，需要去调用 fetch 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。**\nMemory Cache： Memory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。\nDisk Cache： Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。\n\nDisk Cache： Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：\n\n所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好\n可以推送 no-cache 和 no-store 的资源\n一旦连接被关闭，Push Cache 就被释放\n多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存\nPush Cache 中的缓存只能被使用一次\n浏览器可以拒绝接受已经存在的资源推送\n可以给其他域名推送资源****\n\n3. 协商缓存和强缓存的区别（1）强缓存使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\n强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。\n（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。\n（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，\nCache-Control可设置的字段：\n\npublic：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；\nprivate：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；\nno-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；\nno-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；\nmax-age=：设置缓存的最大有效期，单位为秒；\ns-maxage=：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；\nmax-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。\n\n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。\nno-cache和no-store很容易混淆：\n\nno-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；\nno-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。\n\n（2）协商缓存如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。\n上面已经说到了，命中协商缓存的条件有两个：\n\nmax-age=xxx 过期了\n值为no-store\n\n使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。\n协商缓存也可以通过两种方式来设置，分别是 http 头信息中的Etag 和Last-Modified属性。\n（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。\n（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。\n当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。\n总结：\n强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。\n4. 为什么需要浏览器缓存？对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。\n所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。\n使用浏览器缓存，有以下优点：\n\n减少了服务器的负担，提高了网站的性能\n加快了客户端网页的加载速度\n减少了多余网络数据传输\n\n5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？\n点击刷新按钮或者按 F5： 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。\n用户按 Ctrl+F5（强制刷新）： 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。\n地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。\n\n四、浏览器组成1. 对浏览器的理解浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。\nHTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。\n浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。\n\nshell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。\n内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。\n\n2. 对浏览器内核的理解浏览器内核主要分成两部分：\n\n渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。\nJS 引擎：解析和执行 javascript 来实现网页的动态效果。\n\n最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。\n3. 常见的浏览器内核比较\nTrident： 这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。\nGecko： 这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。\nPresto： Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。\nWebkit： Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。\nBlink： 谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。\n\n4. 常见浏览器所用内核（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；\n（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；\n（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；\n（4） Safari 浏览器内核：Webkit 内核；\n（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；\n（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；\n（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；\n（8） 百度浏览器、世界之窗内核：IE 内核；\n（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；\n（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。\n5. 浏览器的主要组成部分\n⽤户界⾯ 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。\n浏览器引擎 在⽤户界⾯和呈现引擎之间传送指令。\n呈现引擎 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n⽹络 ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。\n⽤户界⾯后端 ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。\nJavaScript 解释器。⽤于解析和执⾏ JavaScript 代码。\n数据存储 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。\n\n值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。\n五、浏览器渲染原理1. 浏览器的渲染过程浏览器渲染主要有以下步骤：\n\n首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。\n然后对 CSS 进行解析，生成 CSSOM 规则树。\n根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\n当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\n布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。\n\n大致过程如图所示： \n注意： 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n2. 浏览器渲染优化（1）针对JavaScript： JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：\n（1）尽量将JavaScript文件放在body的最后\n（2） body中间尽量不要写&lt;script&gt;标签\n（3）&lt;script&gt;标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：\n\nscript 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；\nasync 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；\ndefer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。\n\n**（2）针对CSS：**使用CSS有三种方式：使用**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：\n\nlink：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码\n@import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)\nstyle：GUI直接渲染\n\n外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。\n所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。\n（3）针对DOM树、CSSOM树： 可以通过以下几种方式来减少渲染的时间：\n\nHTML文件的代码层级尽量不要太深\n使用语义化的标签，来避免不标准语义化的特殊处理\n减少CSSD代码的层级，因为选择器是从左向右进行解析的\n\n（4）减少回流与重绘：\n\n操作DOM时，尽量在低层级的DOM节点进行操作\n不要使用table布局， 一个小的改动可能会使整个table进行重新布局\n使用CSS的表达式\n不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\n使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\n避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中\n将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\n将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。\n\n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。\n3. 渲染过程中遇到 JS 文件如何处理？JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。\n4. 什么是文档的预解析？Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。\n5. CSS 如何阻塞文档解析？理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。\n6. 如何优化关键渲染路径？为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n（1）关键资源的数量。\n（2）关键路径长度。\n（3）关键字节的数量。\n关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n优化关键渲染路径的常规步骤如下：\n（1）对关键路径进行分析和特性描述：资源数、字节数、长度。\n（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。\n（3）优化关键字节数以缩短下载时间（往返次数）。\n（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度\n7. 什么情况会阻塞渲染？首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\n当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。\n六、浏览器本地存储1. 浏览器本地存储方式及使用场景（1）CookieCookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。\nCookie的特性：\n\nCookie一旦创建成功，名称就无法修改\nCookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie\n每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb\n有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的\nCookie在请求一个新的页面的时候都会被发送过去\n\n如果需要域名之间跨域共享Cookie，有两种方法：\n\n使用Nginx反向代理\n在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId\n\nCookie的使用场景：\n\n最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。\n可以用来统计页面的点击次数\n\n（2）LocalStorageLocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。\nLocalStorage的优点：\n\n在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息\nLocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在\n仅储存在本地，不像Cookie那样每次HTTP请求都会被携带\n\nLocalStorage的缺点：\n\n存在浏览器兼容问题，IE8以下版本的浏览器不支持\n如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage\nLocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问\n\nLocalStorage的常用API：\n// 保存数据到 localStorage\nlocalStorage.setItem('key', 'value');\n\n// 从 localStorage 获取数据\nlet data = localStorage.getItem('key');\n\n// 从 localStorage 删除保存的数据\nlocalStorage.removeItem('key');\n\n// 从 localStorage 删除所有保存的数据\nlocalStorage.clear();\n\n// 获取某个索引的Key\nlocalStorage.key(index)\n复制代码\n\nLocalStorage的使用场景：\n\n有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可\n在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中\n\n（3）SessionStorageSessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。\nSessionStorage与LocalStorage对比：\n\nSessionStorage和LocalStorage都在本地进行数据存储；\nSessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage只有在同一浏览器的同一窗口下才能够共享；\nLocalStorage和SessionStorage都不能被爬虫爬取；\n\nSessionStorage的常用API：\n// 保存数据到 sessionStorage\nsessionStorage.setItem('key', 'value');\n\n// 从 sessionStorage 获取数据\nlet data = sessionStorage.getItem('key');\n\n// 从 sessionStorage 删除保存的数据\nsessionStorage.removeItem('key');\n\n// 从 sessionStorage 删除所有保存的数据\nsessionStorage.clear();\n\n// 获取某个索引的Key\nsessionStorage.key(index)\n复制代码\n\nSessionStorage的使用场景\n\n由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。\n\n2. Cookie有哪些字段，作用分别是什么Cookie由以下字段组成：\n\nName：cookie的名称\nValue：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；\nSize： cookie的大小\nPath：可以访问此cookie的页面路径。 比如domain是abc.com，path是/test，那么只有/test路径下的页面可以读取此cookie。\nSecure： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。\nDomain：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。\nHTTP： 该字段包含HTTPOnly 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。\nExpires/Max-size ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。\n\n总结： 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。\n3. Cookie、LocalStorage、SessionStorage区别浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。\n\ncookie： 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。\nsessionStorage： html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。\nlocalStorage： html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。\n\n上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。\n4. 前端储存的⽅式有哪些？\ncookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；\nlocalStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；\nsessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；\nWeb SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；\nIndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。\n\n5. IndexedDB有哪些特点？IndexedDB 具有以下特点：\n\n键值对储存：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n异步：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。\n支持事务：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n同源限制： IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n储存空间大：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。\n支持二进制储存：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。\n\n七、浏览器同源策略1. 什么是同源策略跨域问题其实就是浏览器的同源策略造成的。\n\n\n\n\n\n\n\n\n\n同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。\n下表给出了与 URL store.company.com/dir/page.ht… 的源进行对比的示例:\n\n\n\nURL\n是否跨域\n原因\n\n\n\nstore.company.com/dir/page.ht…\n同源\n完全相同\n\n\nstore.company.com/dir/inner/a…\n同源\n只有路径不同\n\n\nstore.company.com/secure.html\n跨域\n协议不同\n\n\nstore.company.com:81/dir/etc.htm…\n跨域\n端口不同 ( http:// 默认端口是80)\n\n\nnews.company.com/dir/other.h…\n跨域\n主机不同\n\n\n同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。\n同源政策主要限制了三个方面：\n\n当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。\n当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。\n当前域下 ajax 无法发送跨域请求。\n\n同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。\n2. 如何解决跨越问题（1）CORS下面是MDN对于CORS的定义：\n\n\n\n\n\n\n\n\n\n跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。\nCORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了。\n浏览器将CORS分为简单请求和非简单请求：\n简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：\n1）请求方法是以下三种方法之一：\n\nHEAD\nGET\nPOST\n\n2）HTTP的头信息不超出以下几种字段：\n\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n若不满足以上条件，就属于非简单请求了。\n（1）简单请求过程：\n对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：\nAccess-Control-Allow-Origin: http://api.bob.com  // 和Orign一直\nAccess-Control-Allow-Credentials: true   // 表示是否允许发送Cookie\nAccess-Control-Expose-Headers: FooBar   // 指定返回其他字段的值\nContent-Type: text/html; charset=utf-8   // 表示文档类型\n复制代码\n\n如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。\n在简单请求中，在服务器内，至少需要设置字段：Access-Control-Allow-Origin\n（2）非简单请求过程\n非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求。\n浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。\n预检请求使用的请求方法是OPTIONS，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：\n\nAccess-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。\nAccess-Control-Request-Headers： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。\n\n服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。\n服务器回应的CORS的字段如下：\nAccess-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址\nAccess-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法\nAccess-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段\nAccess-Control-Allow-Credentials: true   // 表示是否允许发送Cookie\nAccess-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒\n复制代码\n\n只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n在非简单请求中，至少需要设置以下字段：\n'Access-Control-Allow-Origin'  \n'Access-Control-Allow-Methods'\n'Access-Control-Allow-Headers'\n复制代码\n\n减少OPTIONS请求次数：OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。\nCORS中Cookie相关问题：在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：\n\n在请求中设置 withCredentials\n\n默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.\n// 原生 xml 的设置方式\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n// axios 设置方式\naxios.defaults.withCredentials = true;\n复制代码\n\n\nAccess-Control-Allow-Credentials 设置为 true\nAccess-Control-Allow-Origin 设置为非 *\n\n（2）JSONPjsonp的原理就是利用&lt;script&gt;标签没有跨域限制，通过&lt;script&gt;标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 1）原生JS实现：\n&lt;script>\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback';\n    document.head.appendChild(script);\n    // 回调执行函数\n    function handleCallback(res) &#123;\n        alert(JSON.stringify(res));\n    &#125;\n &lt;/script>\n复制代码\n\n服务端返回如下（返回时即执行全局函数）：\nhandleCallback(&#123;\"success\": true, \"user\": \"admin\"&#125;)\n复制代码\n\n2）Vue axios实现：\nthis.$http = axios;\nthis.$http.jsonp('http://www.domain2.com:8080/login', &#123;\n    params: &#123;&#125;,\n    jsonp: 'handleCallback'\n&#125;).then((res) => &#123;\n    console.log(res); \n&#125;)\n复制代码\n\n后端node.js代码：\nvar querystring = require('querystring');\nvar http = require('http');\nvar server = http.createServer();\nserver.on('request', function(req, res) &#123;\n    var params = querystring.parse(req.url.split('?')[1]);\n    var fn = params.callback;\n    // jsonp返回设置\n    res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;);\n    res.write(fn + '(' + JSON.stringify(params) + ')');\n    res.end();\n&#125;);\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n复制代码\n\nJSONP的缺点：\n\n具有局限性， 仅支持get方法\n不安全，可能会遭受XSS攻击\n\n（3）postMessage 跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n页面和其打开的新窗口的数据传递\n多窗口之间消息传递\n页面与嵌套的iframe消息传递\n上面三个场景的跨域数据传递\n\n用法：postMessage(data,origin)方法接受两个参数：\n\ndata： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\norigin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。\n\n1）a.html：(domain1.com/a.html)\n&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\">&lt;/iframe>\n&lt;script>       \n    var iframe = document.getElementById('iframe');\n    iframe.onload = function() &#123;\n        var data = &#123;\n            name: 'aym'\n        &#125;;\n        // 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');\n    &#125;;\n    // 接受domain2返回数据\n    window.addEventListener('message', function(e) &#123;\n        alert('data from domain2 ---> ' + e.data);\n    &#125;, false);\n&lt;/script>\n复制代码\n\n2）b.html：(domain2.com/b.html)\n&lt;script>\n    // 接收domain1的数据\n    window.addEventListener('message', function(e) &#123;\n        alert('data from domain1 ---> ' + e.data);\n        var data = JSON.parse(e.data);\n        if (data) &#123;\n            data.number = 16;\n            // 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');\n        &#125;\n    &#125;, false);\n&lt;/script>\n复制代码\n\n（4）nginx代理跨域nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。\n1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\nlocation / &#123;\n  add_header Access-Control-Allow-Origin *;\n&#125;\n复制代码\n\n2）nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。\nnginx具体配置：\n#proxy服务器\nserver &#123;\n    listen       81;\n    server_name  www.domain1.com;\n    location / &#123;\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    &#125;\n&#125;\n复制代码\n\n（5）nodejs 中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。\n1）非vue框架的跨域 使用node + express + http-proxy-middleware搭建一个proxy服务器。\n\n前端代码：\n\nvar xhr = new XMLHttpRequest();\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n// 访问http-proxy-middleware代理服务器\nxhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);\nxhr.send();\n复制代码\n\n\n中间件服务器代码：\n\nvar express = require('express');\nvar proxy = require('http-proxy-middleware');\nvar app = express();\napp.use('/', proxy(&#123;\n    // 代理跨域目标接口\n    target: 'http://www.domain2.com:8080',\n    changeOrigin: true,\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) &#123;\n        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');\n        res.header('Access-Control-Allow-Credentials', 'true');\n    &#125;,\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n&#125;));\napp.listen(3000);\nconsole.log('Proxy server is listen at port 3000...');\n复制代码\n\n2）vue框架的跨域\nnode + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。\nwebpack.config.js部分配置：\nmodule.exports = &#123;\n    entry: &#123;&#125;,\n    module: &#123;&#125;,\n    ...\n    devServer: &#123;\n        historyApiFallback: true,\n        proxy: [&#123;\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        &#125;],\n        noInfo: true\n    &#125;\n&#125;\n复制代码\n\n（6）document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)\n&lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\">&lt;/iframe>\n&lt;script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n&lt;/script>\n复制代码\n\n1）子窗口：(child.domain.com/a.html)\n&lt;script>\n    document.domain = 'domain.com';\n    // 获取父窗口中变量\n    console.log('get js data from parent ---> ' + window.parent.user);\n&lt;/script>\n复制代码\n\n（7）location.hash + iframe跨域实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。\n1）a.html：(domain1.com/a.html)\n&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\">&lt;/iframe>\n&lt;script>\n    var iframe = document.getElementById('iframe');\n    // 向b.html传hash值\n    setTimeout(function() &#123;\n        iframe.src = iframe.src + '#user=admin';\n    &#125;, 1000);\n    \n    // 开放给同域c.html的回调方法\n    function onCallback(res) &#123;\n        alert('data from c.html ---> ' + res);\n    &#125;\n&lt;/script>\n复制代码\n\n2）b.html：(.domain2.com/b.html)\n&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain1.com&#x2F;c.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    &#x2F;&#x2F; 监听a.html传来的hash值，再传给c.html\n    window.onhashchange &#x3D; function () &#123;\n        iframe.src &#x3D; iframe.src + location.hash;\n    &#125;;\n&lt;&#x2F;script&gt;\n复制代码\n\n3）c.html：(www.domain1.com/c.html)\n&lt;script>\n    // 监听b.html传来的hash值\n    window.onhashchange = function () &#123;\n        // 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));\n    &#125;;\n&lt;/script>\n复制代码\n\n（8）window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n1）a.html：(domain1.com/a.html)\nvar proxy = function(url, callback) &#123;\n    var state = 0;\n    var iframe = document.createElement('iframe');\n    // 加载跨域页面\n    iframe.src = url;\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() &#123;\n        if (state === 1) &#123;\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n        &#125; else if (state === 0) &#123;\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';\n            state = 1;\n        &#125;\n    &#125;;\n    document.body.appendChild(iframe);\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() &#123;\n        iframe.contentWindow.document.write('');\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    &#125;\n&#125;;\n// 请求跨域b页面数据\nproxy('http://www.domain2.com/b.html', function(data)&#123;\n    alert(data);\n&#125;);\n复制代码\n\n2）proxy.html：(domain1.com/proxy.html)\n中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)\n&lt;script>    \n    window.name = 'This is domain2 data!';\n&lt;/script>\n复制代码\n\n通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n（9）WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。\n原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。\n1）前端代码：\n&lt;div>user input：&lt;input type=\"text\">&lt;/div>\n&lt;script src=\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\">&lt;/script>\n&lt;script>\nvar socket = io('http://www.domain2.com:8080');\n// 连接成功处理\nsocket.on('connect', function() &#123;\n    // 监听服务端消息\n    socket.on('message', function(msg) &#123;\n        console.log('data from server: ---> ' + msg); \n    &#125;);\n    // 监听服务端关闭\n    socket.on('disconnect', function() &#123; \n        console.log('Server socket has closed.'); \n    &#125;);\n&#125;);\ndocument.getElementsByTagName('input')[0].onblur = function() &#123;\n    socket.send(this.value);\n&#125;;\n&lt;/script>\n复制代码\n\n2）Nodejs socket后台：\nvar http = require('http');\nvar socket = require('socket.io');\n// 启http服务\nvar server = http.createServer(function(req, res) &#123;\n    res.writeHead(200, &#123;\n        'Content-type': 'text/html'\n    &#125;);\n    res.end();\n&#125;);\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n// 监听socket连接\nsocket.listen(server).on('connection', function(client) &#123;\n    // 接收信息\n    client.on('message', function(msg) &#123;\n        client.send('hello：' + msg);\n        console.log('data from client: ---> ' + msg);\n    &#125;);\n    // 断开处理\n    client.on('disconnect', function() &#123;\n        console.log('Client socket has closed.'); \n    &#125;);\n&#125;);\n复制代码\n\n3. 正向代理和反向代理的区别\n正向代理：\n\n客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。\n\n反向代理：\n\n服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。\n两者区别如图示：  正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。\n4. Nginx的概念及其工作原理Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。\n传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。\nNginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。\n八、浏览器事件机制1. 事件是什么？事件模型？事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。\n事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：\n\nDOM0 级事件模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。\nIE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n2. 如何阻止事件冒泡\n普通浏览器使用：event.stopPropagation()\nIE浏览器使用：event.cancelBubble = true;\n\n3. 对事件委托的理解（1）事件委托的概念事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。\n使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。\n（2）事件委托的特点\n减少内存消耗\n\n如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：\n&lt;ul id=\"list\">\n  &lt;li>item 1&lt;/li>\n  &lt;li>item 2&lt;/li>\n  &lt;li>item 3&lt;/li>\n  ......\n  &lt;li>item n&lt;/li>\n&lt;/ul>\n复制代码\n\n如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。\n\n动态绑定事件\n\n给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。\n// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：\n// 给父层元素绑定事件\ndocument.getElementById('list').addEventListener('click', function (e) &#123;\n  // 兼容性处理\n  var event = e || window.event;\n  var target = event.target || event.srcElement;\n  // 判断是否匹配目标元素\n  if (target.nodeName.toLocaleLowerCase === 'li') &#123;\n    console.log('the content is: ', target.innerHTML);\n  &#125;\n&#125;);\n复制代码\n\n在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；\n（3）局限性当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。\n当然事件委托不是只有优点，它也是有缺点的，事件委托会影响页面性能，主要影响因素有：\n\n元素中，绑定事件委托的次数；\n点击的最底层元素，到绑定事件元素之间的DOM层数；\n\n在必须使用事件委托的地方，可以进行如下的处理：\n\n只在必须的地方，使用事件委托，比如：ajax的局部刷新区域\n尽量的减少绑定的层级，不在body元素上，进行绑定\n减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。\n\n4. 事件委托的使用场景场景：给页面的所有的a标签添加click事件，代码如下：\ndocument.addEventListener(\"click\", function(e) &#123;\n\tif (e.target.nodeName == \"A\")\n\t\tconsole.log(\"a\");\n&#125;, false);\n复制代码\n\n但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。\n这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：\ndocument.addEventListener(\"click\", function(e) &#123;\n\tvar node = e.target;\n\twhile (node.parentNode.nodeName != \"BODY\") &#123;\n\t\tif (node.nodeName == \"A\") &#123;\n\t\t\tconsole.log(\"a\");\n\t\t\tbreak;\n\t\t&#125;\n\t\tnode = node.parentNode;\n\t&#125;\n&#125;, false);\n复制代码\n\n5. 同步和异步的区别\n同步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。\n异步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。\n\n6. 对事件循环的理解因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。\n\nEvent Loop 执行顺序如下所示：\n\n首先执行同步代码，这属于宏任务\n当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行\n执行所有微任务\n当执行完所有微任务后，如有必要会渲染页面\n然后开始下一轮 Event Loop，执行宏任务中的异步代码\n\n7. 宏任务和微任务分别有哪些\n微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。\n宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。\n\n8. 什么是执行栈可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。  当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，foo 函数后执行，当执行完毕后就从栈中弹出了。\n平时在开发中，可以在报错中找到执行栈的痕迹：\nfunction foo() &#123;\n  throw new Error('error')\n&#125;\nfunction bar() &#123;\n  foo()\n&#125;\nbar()\n复制代码\n\n 可以看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的。当使用递归时，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题\nfunction bar() &#123;  bar()&#125;bar()\n复制代码\n\n\n9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？Node 中的 Event Loop 和浏览器中的是完全不相同的东西。\nNode 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。 \n（1）Timers（计时器阶段）：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。\n（2）Pending callbacks：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。\n（3）Idle/Prepare：仅供内部使用。\n（4）Poll（轮询阶段）：\n\n当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。\n当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。\n\n（5）Check（查询阶段）：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。\n（6）Close callbacks：执行一些关闭回调，比如socket.on(‘close’, …)等。\n下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是随机的\nsetTimeout(() => &#123;    console.log('setTimeout')&#125;, 0)setImmediate(() => &#123;    console.log('setImmediate')&#125;)\n复制代码\n\n对于以上代码来说，setTimeout 可能执行在前，也可能执行在后\n\n首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的\n进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调\n那么如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了\n\n当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：\nconst fs = require('fs')\nfs.readFile(__filename, () => &#123;\n    setTimeout(() => &#123;\n        console.log('timeout');\n    &#125;, 0)\n    setImmediate(() => &#123;\n        console.log('immediate')\n    &#125;)\n&#125;)\n复制代码\n\n在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。\n上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask \nsetTimeout(() => &#123;\n  console.log('timer21')\n&#125;, 0)\nPromise.resolve().then(function() &#123;\n  console.log('promise1')\n&#125;)\n复制代码\n\n对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。\n最后来看 Node 中的 process.nextTick，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。\nsetTimeout(() => &#123;\n console.log('timer1')\n Promise.resolve().then(function() &#123;\n   console.log('promise1')\n &#125;)\n&#125;, 0)\nprocess.nextTick(() => &#123;\n console.log('nextTick')\n process.nextTick(() => &#123;\n   console.log('nextTick')\n   process.nextTick(() => &#123;\n     console.log('nextTick')\n     process.nextTick(() => &#123;\n       console.log('nextTick')\n     &#125;)\n   &#125;)\n &#125;)\n&#125;)\n复制代码\n\n对于以上代码，永远都是先把 nextTick 全部打印出来。\n10. 事件触发的过程是怎样的事件触发有三个阶段：\n\nwindow 往事件触发处传播，遇到注册的捕获事件会触发\n传播到事件触发处时触发注册的事件\n从事件触发处往 window 传播，遇到注册的冒泡事件会触发\n\n事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 *body* 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event => &#123;\n    console.log('冒泡')\n  &#125;,\n  false\n)\nnode.addEventListener(\n  'click',\n  event => &#123;\n    console.log('捕获 ')\n  &#125;,\n  true\n)\n复制代码\n\n通常使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：\n\ncapture：布尔值，和 useCapture 作用一样\nonce：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听\npassive：布尔值，表示永远不会调用 preventDefault\n\n一般来说，如果只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。\nstopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。\nnode.addEventListener(\n  'click',\n  event => &#123;\n    event.stopImmediatePropagation()\n    console.log('冒泡')\n  &#125;,\n  false\n)\n// 点击 node 只会执行上面的函数，该函数不会执行\nnode.addEventListener(\n  'click',\n  event => &#123;\n    console.log('捕获 ')\n  &#125;,\n  true\n)\n复制代码\n\n九、浏览器垃圾回收机制1. V8的垃圾回收机制是怎样的V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\n（1）新生代算法\n新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\n在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。\n（2）老生代算法\n老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。\n先来说下什么情况下对象会出现在老生代空间中：\n\n新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。\nTo 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。\n\n老生代中的空间很复杂，有如下几个空间\nenum AllocationSpace &#123;\n  // TODO(v8:7464): Actually map this space's memory as read-only.\n  RO_SPACE,    // 不变的对象空间\n  NEW_SPACE,   // 新生代用于 GC 复制算法的空间\n  OLD_SPACE,   // 老生代常驻对象空间\n  CODE_SPACE,  // 老生代代码对象空间\n  MAP_SPACE,   // 老生代 map 对象\n  LO_SPACE,    // 老生代大空间对象\n  NEW_LO_SPACE,  // 新生代大空间对象\n  FIRST_SPACE = RO_SPACE,\n  LAST_SPACE = NEW_LO_SPACE,\n  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,\n  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE\n&#125;;\n复制代码\n\n在老生代中，以下情况会先启动标记清除算法：\n\n某一个空间没有分块的时候\n空间中被对象超过一定限制\n空间不能保证新生代中的对象移动到老生代中\n\n在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。\n清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。\n2. 哪些操作会造成内存泄漏？\n第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\n第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。\n\n","slug":"浏览器原理和计算机网络面试题","date":"2022-04-10T12:20:25.000Z","categories_index":"知识点","tags_index":"面试","author_index":"LIYUNFU"},{"id":"1cfec3e13a62702637234d5f7c53b3fc","title":"Webpack配置及打包vue","content":"\n 安装webpack``webpack-cli\n\nnpm install webpack webpack-cli -D\n\n\n 配置入口出口\n\n// webpack.config.js\nmodule.exports = &#123;\n  mode: 'development',\n  entry: './src/index.js',\n  output: &#123;\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, './dist')\n  &#125;\n&#125;\n\n\n 处理sass\n\n安装sass``sass-loader``postcss-loader``css-loader``style-loader\n\n\nnpm install sass sass-loader postcss-loader css-loader style-loader -D\n\n\n添加postcss.config.js\n\nmodule.exports = &#123;\n  plugins: [\n    require('postcss-preset-env')\n  ]\n&#125;\n\n\n添加rules\n\nmodule: &#123;\n  rules: [\n    &#123;\n      test: /.(s[ac]ss|css)$/,\n      use: [\n        &#123; loader: 'style-loader' &#125;,\n        &#123; loader: 'css-loader' &#125;,\n        &#123; loader: 'postcss-loader' &#125;,\n        &#123; loader: 'sass-loader' &#125;\n      ]\n    &#125;,\n  ]\n&#125;\n\n\n 处理图片等文件资源和字体\n\n\n  v5已经可以试用asset替代file-loader url-loader``raw-loader了\n  添加rules\n\nmodule: &#123;\n  rules: [\n    &#123;\n      test: /.(png|svg|jpg|jpeg|git)$/i,\n      type: \"asset\",\n      generator: &#123;\n        filename: \"img/[name].[hash:6][ext]\"\n      &#125;,\n      parser: &#123;\n        dataUrlCondition: &#123;\n          maxSize: 100 * 1024\n        &#125;\n      &#125;\n    &#125;,\n    &#123;\n      test: /.(woff2?|eot|ttf)$/,\n      type: \"asset/resource\",\n      generator: &#123;\n        filename: \"font/[name].[hash:6][ext]\"\n      &#125;\n    &#125;\n  ]\n&#125;,\n\n\n\n 自动清理dist目录\n\nnpm install clean-webpack-plugin -D\n\nconst &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')\n\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n\n\n 打包html\n\nnpm install html-webpack-plugin -D\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nplugins:[\n  new HtmlWebpackPlugin(&#123;\n        title: 'webpack案例',\n        template: './index.html'\n  &#125;),\n]\n\n\n 自定义模板需要数据填充，需要defineplugin 已内置\n\nnew DefinePlugin(&#123;\n      BASE_URL: &#39;&quot;.&#x2F;&quot;&#39;\n&#125;),\n\n\n\n 自动复制public的内容到dist\n\nnpm install copy-webpack-plugin -D\n\n    new CopyWebpackPlugin(&#123;\n      patterns: [\n        &#123;\n          from: 'public',\n          globOptions: &#123;\n            ignore: [\n              '**/.DS_Store',\n              '**/index.html'\n            ]\n          &#125;\n        &#125;\n      ]\n    &#125;)\n\n\n 支持ES6 安装babel\n\n\n\n\n\n 安装babel\n\n\n\nnpm install babel-loader @babel/core -D\n\n\n\n 安装预设\n\n\n\nnpm install @babel/preset-env\n\n\n\n 新增rules\n\n\n\n&#123;\n  test: /.m?js$/,\n  use: &#123;\n    loader: \"babel-loader\",\n    options: &#123;\n      presets: [\n        [\"@babel/preset-env\"]\n      ]\n    &#125;\n  &#125;\n&#125;\n\n\n\n 也可以在babel.config.js配置预设\n\n\n\nmodule.exports = &#123;\n  presets: [\n    [\"@babel/preset-env\"]\n  ]\n&#125;\n\n\\\n\\\n打包vue\\\n\n 添加@vue/compiler-sfc vue-loader\n\nni @vue/compiler-sfc vue-loader -D\n\nconst &#123; VueLoaderPlugin &#125; = require('vue-loader/dist/index')\n\n\n&#123;\n  test: /.vue$/,\n  loader: \"vue-loader\"\n&#125;\n\nnew VueLoaderPlugin()\n\n\n public/index.html\n\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\" />\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    &lt;title>hello&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;div id=\"app\">&lt;/div>\n  &lt;/body>\n&lt;/html>\n\n\n src/app.vue\n\n&lt;template>\n  &lt;div>\n    &lt;h1>aoo&lt;/h1>\n    &lt;p>hello&lt;/p>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\nexport default &#123;&#125;\n&lt;/script>\n\n&lt;style lang=\"scss\" scoped>&lt;/style>\n\n\n src/index.js\n\nimport &#123; createApp &#125; from 'vue/dist/vue.esm-bundler'\nimport App from './App.vue'\nimport './style.scss'\n\n// vue代码\ncreateApp(App).mount('#app')\n\n\n\\\n搭建本地服务器webpack-dev-server\n  安装\n\nnpm install webpack-dev-server -D\n\n\n  配置webpack.config.js\n\ndevServer: &#123;\n    static: &#123;\n      directory: path.join(__dirname, './')\n    &#125;,\n    compress: true,\n    hot: true,\n    //host: '0.0.0.0',  // 表示在同一个网段下所有主机\n    port: 8000,\n    open: true,\n    proxy: &#123;\n      \"/api\": &#123;\n        target: \"http://localhost:8888\",\n        pathRewrite: &#123;\n          \"^/api\": \"\"\n        &#125;,\n        secure: false,\n        changeOrigin: true   //修改源\n      &#125;\n    &#125;\n  &#125;,\n\n\n  配置package.json\n\n\"scripts\": &#123;\n    \"build\": \"webpack --watch\",\n    \"serve\": \"webpack serve\"\n  &#125;,\n\n\n  使用nr serve启动\\\n\n  开启HMR\n\n\n\n\n\n\n  修改webpack配置\n\n\n\n\n配置devServerdevServer: &#123;\n   static: &#123;\n     directory: path.join(__dirname, './')\n   &#125;,\n   compress: true,\n   hot: true,\n   //host: '0.0.0.0',  // 表示在同一个网段下所有主机\n   port: 8000,\n   open: true,\n   proxy: &#123;\n     \"/api\": &#123;\n       target: \"http://localhost:8888\",\n       pathRewrite: &#123;\n         \"^/api\": \"\"\n       &#125;,\n       secure: false,\n       changeOrigin: true   //修改源\n     &#125;\n   &#125;\n &#125;,\n\nresolve模块解析\n  extensions解析到文件时自动添加扩展名 即可以省略后缀引入\n  alias取别名\n\nresolve: &#123;\n    extensions: ['.js', '.json'],\n    alias: path.resolve(__dirname, './src/js')\n  &#125;\n\n\n\\\n分离不同环境的配置\n  webpack.comm.config.js\n\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst &#123; DefinePlugin &#125; = require(\"webpack\");\nconst &#123; VueLoaderPlugin &#125; = require('vue-loader/dist/index');\n\nmodule.exports = &#123;\n  target: \"web\",\n  entry: \"./src/main.js\",\n  output: &#123;\n    path: path.resolve(__dirname, \"../build\"),\n    filename: \"js/bundle.js\",\n  &#125;,\n  resolve: &#123;\n    extensions: [\".js\", \".json\", \".mjs\", \".vue\", \".ts\", \".jsx\", \".tsx\"],\n    alias: &#123;\n      \"@\": path.resolve(__dirname, \"../src\"),\n      \"js\": path.resolve(__dirname, \"../src/js\")\n    &#125;\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /.css$/,\n        use: [\"style-loader\", \"css-loader\", \"postcss-loader\"],\n      &#125;,\n      &#123;\n        test: /.less$/,\n        use: [\"style-loader\", \"css-loader\", \"less-loader\"],\n      &#125;,\n      // &#125;,\n      &#123;\n        test: /.(jpe?g|png|gif|svg)$/,\n        type: \"asset\",\n        generator: &#123;\n          filename: \"img/[name]_[hash:6][ext]\",\n        &#125;,\n        parser: &#123;\n          dataUrlCondition: &#123;\n            maxSize: 10 * 1024,\n          &#125;,\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.(eot|ttf|woff2?)$/,\n        type: \"asset/resource\",\n        generator: &#123;\n          filename: \"font/[name]_[hash:6][ext]\",\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.js$/,\n        loader: \"babel-loader\"\n      &#125;,\n      &#123;\n        test: /.vue$/,\n        loader: \"vue-loader\"\n      &#125;\n    ],\n  &#125;,\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      template: \"./public/index.html\",\n      title: \"哈哈哈哈\"\n    &#125;),\n    new DefinePlugin(&#123;\n      BASE_URL: \"'./'\",\n      __VUE_OPTIONS_API__: true,\n      __VUE_PROD_DEVTOOLS__: false\n    &#125;),\n    new VueLoaderPlugin()\n  ],\n&#125;;\n\n\n  webpack.dev.config.js\n\nconst &#123; merge &#125; = require('webpack-merge');\n\nconst commonConfig = require('./webpack.comm.config');\n\nmodule.exports = merge(commonConfig, &#123;\n  mode: \"development\",\n  devtool: \"source-map\",\n  devServer: &#123;\n    contentBase: \"./public\",\n    hot: true,\n    // host: \"0.0.0.0\",\n    port: 7777,\n    open: true,\n    // compress: true,\n    proxy: &#123;\n      \"/api\": &#123;\n        target: \"http://localhost:8888\",\n        pathRewrite: &#123;\n          \"^/api\": \"\"\n        &#125;,\n        secure: false,\n        changeOrigin: true\n      &#125;\n    &#125;\n  &#125;,\n&#125;)\n\n\n  webpack.prod.config.js\n\nconst &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst &#123;merge&#125; = require('webpack-merge');\n\nconst commonConfig = require('./webpack.comm.config');\n\nmodule.exports = merge(commonConfig, &#123;\n  mode: \"production\",\n  plugins: [\n    new CleanWebpackPlugin(),\n    new CopyWebpackPlugin(&#123;\n      patterns: [\n        &#123;\n          from: \"./public\",\n          globOptions: &#123;\n            ignore: [\n              \"**/index.html\"\n            ]\n          &#125;\n        &#125;\n      ]\n    &#125;),\n  ]\n&#125;)\n\n\n  package.json\n\n&quot;scripts&quot;: &#123;\n    &quot;build&quot;: &quot;webpack --config .&#x2F;config&#x2F;webpack.prod.config.js&quot;,\n    &quot;serve&quot;: &quot;webpack serve --config .&#x2F;config&#x2F;webpack.dev.config.js&quot;\n  &#125;,\n\n\\\n完整webpack配置\n  webpack.config.js\n\nconst path = require(\"path\");\nconst &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst &#123; DefinePlugin &#125; = require(\"webpack\");\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst &#123; VueLoaderPlugin &#125; = require('vue-loader/dist/index');\n\nmodule.exports = &#123;\n  target: \"web\",\n  mode: \"development\",\n  devtool: \"source-map\",\n  entry: \"./src/main.js\",\n  output: &#123;\n    path: path.resolve(__dirname, \"./build\"),\n    filename: \"js/bundle.js\",\n  &#125;,\n  devServer: &#123;\n    contentBase: \"./public\",\n    hot: true,\n    // host: \"0.0.0.0\",\n    port: 7777,\n    open: true,\n    // compress: true,\n    proxy: &#123;\n      \"/api\": &#123;\n        target: \"http://localhost:8888\",\n        pathRewrite: &#123;\n          \"^/api\": \"\"\n        &#125;,\n        secure: false,\n        changeOrigin: true\n      &#125;\n    &#125;\n  &#125;,\n  resolve: &#123;\n    extensions: [\".js\", \".json\", \".mjs\", \".vue\", \".ts\", \".jsx\", \".tsx\"],\n    alias: &#123;\n      \"@\": path.resolve(__dirname, \"./src\"),\n      \"js\": path.resolve(__dirname, \"./src/js\")\n    &#125;\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /.css$/,\n        use: [\"style-loader\", \"css-loader\", \"postcss-loader\"],\n      &#125;,\n      &#123;\n        test: /.less$/,\n        use: [\"style-loader\", \"css-loader\", \"less-loader\"],\n      &#125;,\n      // &#125;,\n      &#123;\n        test: /.(jpe?g|png|gif|svg)$/,\n        type: \"asset\",\n        generator: &#123;\n          filename: \"img/[name]_[hash:6][ext]\",\n        &#125;,\n        parser: &#123;\n          dataUrlCondition: &#123;\n            maxSize: 10 * 1024,\n          &#125;,\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.(eot|ttf|woff2?)$/,\n        type: \"asset/resource\",\n        generator: &#123;\n          filename: \"font/[name]_[hash:6][ext]\",\n        &#125;,\n      &#125;,\n      &#123;\n        test: /.js$/,\n        loader: \"babel-loader\"\n      &#125;,\n      &#123;\n        test: /.vue$/,\n        loader: \"vue-loader\"\n      &#125;\n    ],\n  &#125;,\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin(&#123;\n      template: \"./public/index.html\",\n      title: \"哈哈哈哈\"\n    &#125;),\n    new DefinePlugin(&#123;\n      BASE_URL: \"'./'\",\n      __VUE_OPTIONS_API__: true,\n      __VUE_PROD_DEVTOOLS__: false\n    &#125;),\n    // new CopyWebpackPlugin(&#123;\n    //   patterns: [\n    //     &#123;\n    //       from: \"public\",\n    //       to: \"./\",\n    //       globOptions: &#123;\n    //         ignore: [\n    //           \"**/index.html\"\n    //         ]\n    //       &#125;\n    //     &#125;\n    //   ]\n    // &#125;),\n    new VueLoaderPlugin()\n  ],\n&#125;;\n","slug":"Webpack配置及打包vue","date":"2022-04-10T12:08:54.000Z","categories_index":"知识点","tags_index":"工程化,vue","author_index":"LIYUNFU"},{"id":"46e88b89849dba43d2b30cc4164d9a11","title":"TS基础入门","content":"类型number类型let num:number=10\nlet num:number=10.1\nlet num:number=0b110  // 二进制\nlet num:number=0o555  // 八进制\nlet num:number=0xf23  // 十六进制\n\n\n\nboolean类型let flag:boolean=true\n\n\n\nstring类型let message:string='hello world'\n\n\n\nArray类型const names:string[]=['alen','john','bob']\nconst names:Array&lt;string> =['alen','john','bob']\n\n\n\nObject类型const myInfo:object=&#123;\n  name:'john',\n  age:18\n&#125;\n\n\n我们不能从myinfo中获取数据，也不能设置数据，只用来描述一个对象\n\nSymbol类型const s1:symbol=Symbol('title')\nconst s2:symbol=Symbol('title')\n\nconst person=&#123;\n  [s1]:'程序员',\n  [s2]:'老师'\n&#125;\n\n\n\nnull和undefined类型let n:null=null\nlet u:undefined=undefined\n\n\n\nany类型\n在某些情况下，我们无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以用any类型\n\nlet a:any='why'\na=123\na=true\n\nconst arr:any[]=['why',18]\n\n\n\nunknown类型\n用于描述不确定的变量\n\nfunction foo():string&#123;&#125;\nfunction bar():number&#123;&#125;\n\nconst flag=true\nlet result:unknown\n\nif(flag)&#123;\n  result=foo()\n&#125;else&#123;\n  result=bar()\n&#125;\n\nif(typeof result==='string')&#123;\n  console.log(result)\n&#125;\n\n\n\nvoid类型\n指定一个函数没有返回值，可以把null和undefined赋值给void，也就是函数可以返回null或者undefined\n函数没有写任何类型，默认返回值的类型就是void\n\nfunction sum(num1:number,num2:number):void&#123;\n  console.log(num1+num2)\n&#125;\n\n\n\nnever类型\nnever表示永远不会发生值得类型\n使用never指定死循环或者抛出异常得函数得值类型\n\nfunction handleMessage(message:number|string)&#123;\n  switch(typeof message)&#123;\n    case 'string':\n      console.info('foo')\n      break\n    case 'number':\n      console.info('bar')\n      break\n    default:\n      const check:never=message\n  &#125;\n&#125;\n\n\n\ntuple类型\ntuple和数组得区别\n\n数组通常存放相同类型得元素，不同类型得元素是不推荐放在数组中\n元素每个类型都有自己特性得类型，根据索引值获取到得值可以确定对应得类型\n\nconst info:[string,number,number]=['john',18,10]\n\ntuple的应用场景\ntuple通常可以作为返回的值，在使用的时候会非常的方便\nfunction useState&lt;T>(state:T):[T,(newState:T)=>void]&#123;\n\tlet currentState=state\n  const changeState=(newState:T)=>&#123;\n    currentState=newState\n  &#125;\n\treturn [currentState,changeState]\n&#125;\n\nconst [counter,setCounter]=useState(10)\n\n函数的返回值类型function sum(num1:number , num2:number):number&#123;\n  return num1+num2\n&#125;\n\n\n\n匿名函数的参数类型\n匿名函数可以自动推断出参数的类型\n\nconst names=['abc','def','ghi']\nnames.forEach(item=>&#123;\n  console.info(item.toUpperCase())\n&#125;)\n\n\n\n对象类型function printCoordinate(point:&#123;x:number,y:number&#125;)&#123;\n  console.info('x坐标',point.x)\n  console.info('y坐标',point.y)\n&#125;\nprintCoordinate(&#123;x:10,y:30&#125;)\n\n\n\n可选类型function printCoordinate(point:&#123;x:number,y:number,z?:number&#125;)&#123;\n  console.info('x坐标',point.x)\n  console.info('y坐标',point.y)\n  if(point.z)&#123;\n    console.info('z坐标',point.z)\n  &#125;\n&#125;\nprintCoordinate(&#123;x:10,y:30&#125;)\nprintCoordinate(&#123;x:20,y:30,z:40&#125;)\n\n\n\n联合类型\n联合类型是由两个或多个其他类型组成的类型\n表示可以是这些类型中的任何一个值\n联合类型中的每一个类型被称之位联合成员\n\nfunction printId(id:number|string)&#123;\n  console.log('你的id是',id)\n&#125;\nprintId(10)\nprintId('abc')\n\n\n\n类型别名\n编写对象类型和联合类型有时需要多次在其他地方使用，可以起别名\n\ntype Point=&#123;\n  x:number,\n  y:number\n&#125;\nfunction printPoint(point:Point)&#123;\n  console.info(point.x,point.y)\n&#125;\n\nfunction sumPoint(point:Point)&#123;\n  console.info(point.x+point.y)\n&#125;\n\nprintPoint(&#123;x:20,y:30&#125;)\nsumPoint(&#123;x:20,y:20&#125;)\n\ntype ID=number|string\nfunction printId(id:ID)&#123;\n  console.info('你的id',id)\n&#125;\n\n\n\n断言类型断言as\n有时候TS无法获取具体的类型信息，这时我们就需要使用类型断言\nTS只允许类型断言转换为更具体 或不太具体 的类型版本\n\nconst el=document.getElementById('box') as HTMLImageElement\n\nel.src='图片地址'\n\n\n\n非空断言\n当我们编写可选参数的时候，执行TS的编译阶段会报错\n\n这是因为传入的message有可能是undefined\nfunction printMessage(message?:string)&#123;\n  console.info(message:toUpperCase())\n&#125;\nprintMessage('hello')\n\n\n但是，我们确定传入的参数是有值的，这个时候我们可以使用非空类型断言\n\n非空断言使用的是! 表示可以确定某个标识符是有值得，跳过TS在编译阶段对他得检测\nfunction printMessage(message?:string)&#123;\n  console.info(message!.toUpperCase())\n&#125;\n\n\n\nJS新特性可选链的使用\n可选链操作符?. \n\n作用是当对象的熟悉不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行\ntype Person=&#123;\n  name:string,\n  friend?:&#123;\n    name:string,\n    age?:number,\n    girlFriend?:&#123;\n      name:string\n    &#125;\n  &#125;\n&#125;\n\nconst info:Person=&#123;\n  name:'why',\n  friend:&#123;\n    name:'kobe',\n    girlFriend:&#123;\n      name:'lily'\n    &#125;\n  &#125;\n&#125;\n\nconsole.info(info.friend?.name)\nconsole.info(info.friend?.age)\nconsole.info(info.friend?.girlFirend?.name)\n\n??和!! 的作用\n！！操作符\n\n将一个其他类型转换成boolean类型\n类似与Boolean的方式\n\n\n？？操作符\n\n空值合并操作符是一个逻辑操作符，当操作符的1左侧是null或者undefined时，返回其右侧操作数，否则返回左侧操作数\n\nconst message=\"\"\nlet flag=!!message  // true\n\nconst message='123'\nconst result=message??'321'\n\n字面量字面量类型\n多个类型联合起来，可以达到类似enum的效果\n\ntype Direction = 'TOP'|'BOTTOM'|'LEFT'|'RIGHT'\nfunction changeDeriction(direction:Direction)&#123;\n  console.info('转向',align)\n&#125;\n\nchangeDeriction('LEFT')\n\n\n\n字面量推理const info=&#123;\n  url:'https://baidu.com/abc',\n  method:'GET'\n&#125;\nfunction request(url:string,method:'GET'|'POST')&#123;\n  console.info(url,method)\n&#125;\nrequest(info.url,info.method)\n\n\n因为函数参数需要的时GET 或POST 字面量，所以不能将string赋值进去，解决方法\n\n// 方案1\nrequest(info.url,info.method as 'GET')\n\n// 方案2\nconst info=&#123;\n  url:'https://baidu.com',\n  method:'GET'\n&#125;as const\n\n\n\n函数函数类型type CalcFunc=(num1:number,num2:number)=>void\n\nfunction calc(fn:CalcFunc)&#123;\n  console.info(fn(20,30))\n&#125;\n\n\n\n参数的可选类型\n可选类型必须在必传参数的后面\n可选类型的类型是指定的类型和undefined联合\n\nfunction foo(x:number,y?:number)&#123;\n  console.info(x,y)\n&#125;\n\n\n\n默认参数function foo(x:number,y:number=6)&#123;\n  console.info(x,y)\n&#125;\nfoo(10)\n\n\n\n剩余参数function sum(...nums:number[])&#123;\n  let total=0\n  for(const num of nums)&#123;\n    total+=num\n  &#125;\n  return total\n&#125;\n\nconst result=sum(10,20,30)\n\n\n\nthis的类型\n某些时候可推导\n\nconst info=&#123;\n  name:'why',\n  asyHello()&#123;\n    console.info(this.name)\n  &#125;\n&#125;\ninfo.sayHello()\n\n\n不可推导时，需要指定\n\ntype NameType=&#123;\n  name:string\n&#125;\nfunction sayHello(this:NameType)&#123;\n  console.info(this.name)\n&#125;\n\n\n\n函数的重载function sum(a1:number,a2:number):number;\nfunction sum(a1:string,a2:string):string;\nfunction sum(a1:any,a2:any):any&#123;\n  return a1+a2\n&#125;\n\nconsole.info(sum(20,30))\nconsole.info(sum('aaa','bbb'))\n\n\n\n类类的定义class Person&#123;\n  name!:string\n  age:number\n  \n  constructor(name:string,age:number)&#123;\n    this.age=age\n  &#125;\n  \n  runing()&#123;&#125;\n&#125;\n\n\n\n如果我们不希望给属性初始化，可以使用name!:string 语法，加!\n\n类的继承class Student extends Person&#123;\n  sno:number\n  \n  constructor(name:string,age:number,sno:number)&#123;\n    super(name,age)\n    this.age=sno\n  &#125;\n  \n  studying()&#123;\n    console.info(this.name+'studying')\n  &#125;\n&#125;\n\n\n\n类的成员修饰符\npublic 任何地方可见，公有的属性或方法，默认编写的属性就是public\nprivate 修饰的是仅在同一类中可见、私有的属性或方法\nprotected 仅在自身和子类中可见\n\n只读属性readonly\n如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用readonly\n\nclass Person&#123;\n  readonly name:string\n  \n  constructor(name:string)&#123;\n    this.name=name\n  &#125;\n&#125;\n\nconst p=new Person('why')\nconsole.info(p.name)\n\np.name='code'  // error\n\n\n\ngetters/setters\n在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(getter)和设置(setter)的过程，这个时候我们可以使用存取器\nclass Person&#123;\n  private _name:string\n  \n  set name(newName)&#123;\n    this._name=newName\n  &#125;\n  get name()&#123;\n    return this._name\n  &#125;\n  \n  constructor(name:string)&#123;\n    this.name=name\n  &#125;\n&#125;\n\nconst p=new Person('why')\np.name='coder'\nconsole.info(p.name)\n\n静态成员class Student&#123;\n  static time:string='20:00'\n  \n  static attendClass()&#123;\n    console.info('去上课')\n  &#125;\n&#125;\n\nconsole.info(Student.time)\nStudent.attendClass()\n\n\n\n抽象类abstract\n抽象方法，必须存在于抽象类中\n抽象类是使用abstruct声明的类\n\n特点\n抽象类是不能被实例化的(也就是不能通过new创建)\n抽象方法必须被子类实现，否则该类必须是一个抽象类\n\nabstract class Shape&#123;\n  abstract getArea():number\n&#125;\n\nclass Circle extends Shape&#123;\n  private r:number\n  constructor(r:number)&#123;\n    super()\n    this.r=r\n  &#125;\n  getArea()&#123;\n    return this.r+this.r*3.14\n  &#125;\n&#125;\n\nclass Rectangle extends Shape&#123;\n  private width:number\n  private height:number\n  \n  constructor(width:number,height:number)&#123;\n    super()\n    this.width=width\n    this.height=height\n  &#125;\n  getArea()&#123;\n    return this.width+this.height\n  &#125;\n&#125;\n\nconst circle=new Circle(10)\nconst rectangle=new Reactangle(20,30)\nfunction calcArea(shape:Shape)&#123;\n  console.info(shape.getArea())\n&#125;\ncalcArea(circle)\ncalcArea(rectangle)\n\n\n\n类的类型class Person&#123;\n  name:string\n  constructor(name:string)&#123;\n    this.name=name\n  &#125;\n  runing()&#123;\n    console.info(this.name+'running')\n  &#125;\n&#125;\n\nconst p1:Person=new Person('why')\nconst p2:Person=&#123;\n  name:'kobe',\n  runing function()&#123;\n    console.info(this.name+'runing')\n  &#125;\n&#125;\n\n\n\n接口接口的声明interfacce Point&#123;\n  x:number\n  y:number\n&#125;\n\n\n\n可选属性interface Person&#123;\n  name:string\n  age?:number\n  friend?:&#123;\n    name:string\n  &#125;\n&#125;\n\nconst person:Person=&#123;\n  name:'why',\n  age:19,\n  friend:&#123;\n    name:'kobe'\n  &#125;\n&#125;\n\nconsole.info(person.name)\nconsole.info(person.friend?.name)\n\n\n\n只读属性\n接口中也可以定义只读属性\n\n这样就意味着我们在初始化之后，这个值是不可以被修改的\n\ninterface Person&#123;\n  readonly name:string\n  age?:number\n  readonly friend?:&#123;\n    name:string\n  &#125;\n&#125;\n\nconst person:Person=&#123;\n  name:'why',\n  age:19,\n  friend:&#123;\n    name:'kobe'\n  &#125;\n&#125;\n\nperson.name='code' //不可以设置\nperson.friend=&#123;&#125;  //不可以设置\n\nif(person.friend)&#123;\n  person.friend.name='123'  // 可以\n&#125;\n\n索引类型\n前面我们使用interface来定义对象类型，这个时候其中的属性名、类型、方法都是确定的，但是有时候我们会遇到类似下面的对象\n\ninterface FrontLanguage&#123;\n  [index:number]:string\n&#125;\n\nconst frontend:FrontLanguage=&#123;\n  1:'HTML',\n  2:'CSS',\n  3:'JS'\n&#125;\n\ninterface LanguageBirth=&#123;\n  [name:string]:number\n&#125;\n\nconst language:LanguageBirth=&#123;\n  \"Java\":1999,\n  \"JavaScript\":1000,\n  \"c\":1998\n&#125;\n\n\n\n函数类型\n前面我们都是通过interface来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型\n\ninterface CalcFunc&#123;\n  (num1:number,num2:number):number\n&#125;\n\nconst add:CalcFunc=(num1,num2)=>&#123;\n  return num1+num2\n&#125;\n\nconst sub:CalcFunc=(num1,num2)=>&#123;\n  return num1-num2\n&#125;\n\n\n推荐使用类型别名来定义函数\n\ntype CalcFunc=(num1:number,num2:number)=>number\n\n\n\n接口继承\n接口和类一样是可以进行继承的，也是使用extends关键字\n\n并且我们会发现，接口是支持多继承的\n\ninterface Person&#123;\n  name:string\n  eating:()=>void\n&#125;\n\ninterface Animal&#123;\n  runing:()=>void\n&#125;\n\ninterface Student extends Person,Animal&#123;\n  sno:number\n&#125;\n\nconst stu:Student=&#123;\n  sno:100,\n  name:'why',\n  eating:function()&#123;\n    \n  &#125;,\n  runing:function()&#123;&#125;\n&#125;\n\n接口实现\n接口定义后，也是可以被类实现的\n如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入\n这就是面向接口开发\n\n\n\ninterface ISwim&#123;\n  swimming:()=>void\n&#125;\n\ninterface IRun&#123;\n  runing:()=>void\n&#125;\n\nclass Person implements ISwim,IRun&#123;\n  swimming()&#123;\n    console.info('swimming')\n  &#125;\n  running()&#123;\n    console.info('running')\n  &#125;\n&#125;\n\nfunction swim(swimmer:ISwim)&#123;\n  swimmer.swimming()\n&#125;\n\nconst p=new Person()\nswim(p)\n\n\n\n\n\n交叉类型\n交叉类似表示需要满足多个类型的条件\n交叉类型使用&amp;符号\n在开发中进行交叉时，通常是对对象类型进行交叉的\n\ninterface Colorful&#123;\n  color:string\n&#125;\n\ninterface IRun&#123;\n  runing:()=>void\n&#125;\n\ntype NewType=Colorful&amp;IRun\n\nconst obj:NewType=&#123;\n  color:'red',\n  running:function()&#123;&#125;\n&#125;\n\n\n\ninterface和type的区别\ninterface可以重复的对某个接口来进行属性和方法\ntype定义的是别名，别名是不能重复的\n\ninterface IPerson&#123;\n  name:string\n  running:()=>void\n&#125;\n\ninterface IPerson&#123;\n  age:number\n&#125;\n\n\n枚举枚举类型enum Direction&#123;\n  LEFT,\n  RIGHT,\n  TOP,\n  BOTTOM\n&#125;\n\nfunction turnDirection(direction:Direction)&#123;\n  switch(direction)&#123;\n    case Direction.LEFT:\n      console.info('转向左边')\n      break;\n    case Direction.RIGHT:\n      console.info('转向右边')\n      break;\n    case Direction.TOP:\n      console.info('转向上边')\n      break;\n    case Direction.BOTTOM:\n      console.info('转向下边')\n      break;\n    default:\n      const myDirection:never=direction\n  &#125;\n&#125;\n\n\n\n\n\n泛型泛型接口interface IFoo&lt;T>&#123;\n  initialValue:T,\n  valueList:T[],\n  handleValue:(value:T)=>void\n&#125;\n\nconst foo:IFoo&lt;number>=&#123;\n  initialValue:0,\n  valueList:[0,1,2],\n  handleValue:function(value:number)&#123;\n    console.info(value)\n  &#125;\n&#125;\n\ninterface IFoo&lt;T=number>&#123;\n  initialValue:T,\n  valueList:T[],\n  handleValue:(value:T)=>void\n&#125;\n\n\n\n泛型类class Point&lt;T>&#123;\n  x:T\n  y:T\n  \n  constructor(x:T,y:T)&#123;\n    this.x=x\n    this.y=y\n  &#125;\n&#125;\n\nconst p1=new Point(10,20)\nconst p2=new Point&lt;number>(10,20)\nconst p3:Point&lt;number>=new Point(10,20)\n\n\n\n泛型约束\n有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中\n\n比如string和array都是有length的，或者某些对象也是会有length属性的\n那么只要是拥有length的属性都可以作为我们的参数类型\n\ninterface ILength&#123;\n  length:number\n&#125;\n\nfunction getLength&lt;T extends ILength>(args:T)&#123;\n  return args.length\n&#125;\n\nconsole.info(getLength('abc'))\nconsole.info(getLength(['abc','cba']))\nconsole.info(getLength(&#123;length:100,name:'why'&#125;))\n\n命名空间export namespace Time&#123;\n  export function format(time:string)&#123;\n    return '2022-01-01'\n  &#125;\n&#125;\nexport namespace Price&#123;\n  export function format(price:number)&#123;\n    return '222.22'\n  &#125;\n&#125;\n\n\n\n声明当一个模块引用的是另一个模块的数据时，没有引入需要声明\n声明变量、函数、类// \nlet wName='why'\nlet mAge=19\nlet mHeight=18\n\nfunction wFoo()&#123;\n  console.info('wfoo')\n&#125;\n\nfunction wBar()&#123;\n  console.info('wBar')\n&#125;\n\nfunction Person(name,age)&#123;\n  this.name=name\n  this.age=age\n&#125;\n\ndeclare let wName:string\ndeclare let wAge:number\ndeclare let wHeight:number\n\ndeclare function wFoo():void\ndeclare function wBar():void\n\ndeclare class Person&#123;\n  name:string\n  age:number\n  \n  constructor(name:string,age:number)\n&#125;\n\n\n\n声明模块\n我们也可以声明模块，比如lodash模块默认不能使用的情况，可以自己来声明这个模块\n\ndeclare module 'lodash'&#123;\n  export function join(args:any[]):any\n&#125;\n\n\n\n","slug":"TS基础入门","date":"2022-04-08T05:52:14.000Z","categories_index":"学习记录","tags_index":"TypeScript","author_index":"LIYUNFU"},{"id":"1b47919438b08a0e56e1fac60890eb9a","title":"HTML知识点","content":"1. 如何理解HTML语义化优点\n\n对机器友好，更适合搜索引擎的爬取，有利于SEO。支持读屏软件，根据文章可以自动生成目录\n对开发者友好，增强可读性，结构更加清晰，便于维护\n\n常见语义化标签\n&lt;header>头部&lt;/header>\n&lt;nav>导航栏&lt;/nav>\n&lt;section>区块(有语义化的div)&lt;/section>\n&lt;main>主要区域&lt;/main>\n&lt;article>主要内容&lt;/article>\n&lt;aside>侧边栏&lt;/aside>\n&lt;footer>底部&lt;/footer>\n\n\n\n2. 常见块级和内联元素块级元素\n\ndiv、h1、h2、table、ul、ol、p等\n\n内联元素\n\nspan、img、input、button等\n\n3. DOCTYPE(文档类型的作用)告诉浏览器（解析器）应该以什么样的文档类型（html或xhtml）定义来解析文档\n浏览器渲染页面的两种模式（可通过document.compatMode 获取）\nCSS1Compat：标准模式(Strick mode) ，默认模式，浏览器使用W3C标准解析渲染页面，在标准模式下，浏览器以其支持的最高标准呈现页面\nBackCompat：怪异模式(Qiock mode) ，浏览器以自己的怪异模式解析渲染页面，在怪异模式中，页面以一种比较宽松的向后兼容的方式显示\n触发怪异模式的方式\n\nIE浏览器\n不写DOCTYPE\nbox-sizing:border-box \n\n4. src和href的区别\nsrc：表示对资源的引用，指向的内容会被下载并嵌入到当前标签所在位置，如js脚本，当浏览器解析到该元素时，会暂停其他资源的下载和处理，指导该资源加载、编译、执行完毕，所以一半js脚本会放在页面底部\nhref：表示超文本引用，它指向一些网络资源，建立和当前元素或当前文档的链接关系，当浏览器识别到它指向的文件时，会并行下载资源，不会停止对当前文档的处理，常用在a、link等标签上\n\n5. script标签中defer和async的区别如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素怒，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\ndefer和async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，区别如下：\n\n执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行\n脚本是否并行执行：async属性，并行加载，并行执行；defer属性，并行加载，等到文档所有元素解析完成之后才执行，在DOMContentLoaded触发之前\n\n6. 常用的meta标签有哪些\ncharset ，用来描述HTML文档的编码类型\n\n&lt;meta charset=\"utf-8\">\n\n\nkeywords ，页面关键词\n\n&lt;meta name=\"keywords\" content=\"关键词\" />\n\n\ndescription ，页面描述\n\n&lt;meta name=\"description\" content=\"页面描述\" />\n\n\nrefresh ，页面重定向和刷新\n\n&lt;meta http-equiv=\"refresh\" content=\"0;url=\" />\n\n\nviewport ，适配移动端，可以控制视口的大小和比例\n\n&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1\" />\n\ncontent 参数有以下几种\n\nwidth：宽度(数值/device-width)\nheight：高度(数值/device-height)\ninitial-scale：初始缩放比例\nmaximum-scale ：最大缩放比例\nminimum-scale ：最小缩放比例\nuser-scalable：是否允许用户缩放(yes/no)\n\n\n搜索引擎索引方式\n\n&lt;meta name=\"robots\" content=\"index,follow\" />\n\ncontent 参数有以下几种\n\nall：文件将被检索，且页面上的链接可以被查询\nnone：文件不被检索，且页面上的链接不可以被查询\nindex：文件将被检索\nfollow：页面上的链接可以被查询\nnoindex：文件不被检索\nnofollow：页面上的链接不可以被查询\n\n7. HTML有哪些更新1. 语义化标签\nheader：头部\nnav：导航\nfooter：底部\narticle：文章内容\nsection：文档中的节\naside：侧边栏\n\n2. 媒体标签\naudio：音频\n\n&lt;audio src='' controls autoplay loop />\n\n属性\n\ncontrols 控制面板\nautoplay 自动播放\nloop 循环播放\n\n\nvideo：适配\n\n&lt;video src='' poster='imgs/aa.jpg' controls />\n\n属性\n\nposter 指定封面\ncontrols 控制面板\nwidth 宽度\nheight 高度\n\n\nsource标签，兼容不同的浏览器\n\n&lt;video>\n  &lt;source src='aa.flv' type='video/flv'>&lt;/source>\n  &lt;source src='aa.mp4' type='video/mp4'>&lt;/source>\n&lt;/video>\n\n3. 表单表单类型\n\nemail 能够验证当前输入的邮箱地址是否合法\nurl 验证url\nnumber 只能输入数字，自带点击增加减小箭头，max属性设置为最大值，min设置为最小值，value为默认值\nsearch 可以一键删除输入内容\nrange 可以提供一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值\ncolor 提供一个颜色拾取器\ntime 时间选择器\ndata 日期选择器\ndatatime 时间和日期\ndatatime-local 日期时间控件\nweek 周控件\nmonth 月控件\n\n表单属性\n\nplaceholder 提示信息\nautofocus 自动获取焦点\nautocomplete=&quot;on&quot;或autocomplete=&quot;off&quot; 必须有name属性，并提交过，可以自动填写\nrequired 不能为空\npattern&quot;&quot;里面写入想要的正则模式，例如手机号pattern=&quot;^(+86)?\\d&#123;10&#125;$&quot; \nmutiple 可以选择多个我呢见或者多个邮箱\nform=form表单的ID\n\n表单事件\n\n oninput 每当input里的输入库内容发生变化都会触发此事件\noninvalid 当验证不通过时触发此事件\n\n4. 进度条、度量器\nprogress 标签用来表示任务的进入，max表示最大，value表示已完成多少\n\nmeter 属性：用来显示剩余容量或剩余库存\n\nhigh/low 规定被视作高/低的范围\nmax/min 规定最大/小值\nvalue 规定当前度量值\n\n设置规则：min &lt; low &lt; hight &lt; max\n\n\n5. DOM查询操作\ndocument.querySelector()\ndocument.querySelectorAll()\n\n6. Web存储\nlocalStorage - 没有时间限制的数据存储\nsessionStorage - 针对一个session的数据存储\n\n7. 其他\n拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置，设置元素可拖放\n\n&lt;img draggable=\"true\" />\n\n\n画布：canvas元素使用JS在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas拥有多种绘制路径、矩形、字符以及添加图像的方法\n\n&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\">&lt;/canvas>\n\n\nSVG：可伸缩矢量图形，用来定义用于网络的基于矢量的图形，使用XML格式定义图形，图像的放大或改变尺寸的情况下其图像质量不会有损失，它是万维网联盟的标准\n地理位置：Geolocation用于定位用户的位置\n\n移除\n纯表现的元素：basefont，big，center，font，s，strike，tt，u\n对可用性产生负面影响的元素：frame，frameset，noframes\n\n8. img的srcset属性的作用响应式页面中经常用到根据屏幕密度设置不同的图片，这时就用到了img标签的srcset属性，srcset属性用于设置不同屏幕密度下，img会自动加载不同的图片，用法如下\n&lt;img src=\"images-128.png\" srcset=\"images-256.png 2x\" />\n\n&lt;img src=\"image-128.png\"\n     srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n     sizes=\"(max-width: 360px) 340px, 128px\" />\n\n\n\n其中srcset指定图片的地址和对应的图片质量，sizes 设置临界点，可以按需加载\n\n9. 说一下web workerweb worker为web内容在后台线程中运行脚本提供了一种简单的方法，线程可以执行任务而不干扰用户界面\n10. HTML5的离线存储怎么使用，它的工作原理是什么离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n原理： HTML5的离线存储是基于一个新建的.appcache 文件的缓存机制，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储下来，之后网络处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n使用方法\n\n创建一个和html同名的manifest文件，然后在页面头部加入manifest属性\n\n&lt;html lang=\"en\" manifest=\"index.manifest\">\n\n\n在cache.manifest 文件中编写需要离线存储的资源\n\nCACHE MANIFEST\n    #v0.11\n    CACHE:\n    js/app.js\n    css/style.css\n    NETWORK:\n    resourse/logo.png\n    FALLBACK:\n    / /offline.html\n\n\n\nCACHE 表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身页列出来\nNETWORK 表示在它下面列出来的资源只有在在线的情况下才能访问，它们不会被离线存储，所以在离线情况下无法使用这些资源，不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高\nFALLBACK 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html \n\n\n在离线状态时，操作window.applicationCache 进行离线缓存的操作\n\n如何更新缓存\n\n更新manifest文件\n通过javascript操作\n清除浏览器缓存\n\n注意事项\n\n浏览器对缓存数据的容量限制可能不一样（某些浏览器设置的限制是每个站点5MD）\n如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存\n引用manifest的html必须与manifest文件同源，在同一个域下\nFALLBACK中的资源必须和manifest文件同源\n当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源\n站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问\n当manifest文件发生改变时，资源请求本身也会触发更新\n\n11. 浏览器是如何对HTML5的离线存储资源进行管理和加载\n在线的情况下：浏览器发i西安html头部有manifest属性，它会请求manifest文件，如果是第一次访问页面，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线缓存。如果已经访问过页面并且资源已经进行离线缓存，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件和旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储\n离线的情况下浏览器会直接使用离线存储的资源\n\n12. title与h1的区别、b与strong的区别、i与em的区别\nstrong标签有语义，起到加强语气强调的效果，b标签没有语义，只是加粗标签，搜索引擎更侧重strong\ntitle属性没有明确意义只表示标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响\ni内容展示位斜体，em表示强调的文本\n\n13. iframe有哪些优点优点\n\n用来加载速度较慢的内容\n可以使脚本并行下载\n可以实现跨子域通信\n\n缺点\n\niframe会阻塞主页面的onload事件\n无法被一些搜索引擎识别\n会产生很多页面，不易管理\n\n14. label的作用是什么，如何使用用来定义表单控件的关系：点击label时，自动将焦点定位到与label相关的表单控件上\n\n使用方法  for控件的id  或者直接包裹\n\n&lt;label for=\"mobile\">Phone&lt;/label>\n&lt;input type=\"text\" id=\"mobile\" />\n\n&lt;label>\nPhone:&lt;input  type=\"text\" />\n&lt;/label>\n\n\n\n15. Canvas和SVG的区别SVG 可伸缩矢量图形，是基于XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加JS事件处理器，在SVG中，每个被绘制的图形均被视作对象，如果SVG对象的属性发生变化，那么浏览器能够自动重现图形\n特点\n\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序(比如谷歌地图)\n复杂度高会减慢渲染速度(任何过度使用DOM的应用都不快)\n不适合游戏应用\n\nCanvas 画布，通过JS来绘制2D图形，是逐像素进行渲染的，其位置发生改变，就会重新进行渲染\n特点\n\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以.png或.jpg格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被反复重绘\n\n16. head标签有什么用，其中什么标签必不可少标签用于定义文档的头部，它是所有头部元素的容器，head中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等\n可在head中用的标签\n\n&lt;base&gt;\n&lt;link&gt;\n&lt;meta&gt;\n&lt;script&gt;\n&lt;style&gt;\n&lt;title&gt; 必需\n\n17. 浏览器乱码的原因是什么，如何解决产生乱码的原因：\n\n网页源代码是gbk 的编码，而内容中的中文字是utf-8 编码的，编码不匹配乱码\nhtml 页面编码是gbk ，而程序从数据库中调出呈现是utf-8编码的内容也会造成乱码\n浏览器不能自动检测网页编码，造成乱码\n\n解决办法：\n\n使用软件编辑HTML网页内容\n使用网页涉资编码类型，如果数据库和网页不匹配编码，可以对中文进行转码，使用转码函数\n如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换\n\n18. 渐进增强和优雅降级之间的区别**渐进增强(progressice enhancement)**主要针对低版本的浏览器进行页面重构，保证基本的功能的情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验\n**优雅降级(graceful degradation)**一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容\n19. 说一下HTML5 drag API\ndragstart 事件主体是被拖放元素，在开始拖放被拖放元素时触发\ndrag 事件主体是被拖放元素，在正在拖放被拖放元素时触发\ndragenter 事件主体时目标元素，在被拖放元素进入某元素时触发\ndragover 事件主体是目标元素，在被拖放元素进入某元素时触发\ndragleave 事件主体时目标元素，在被拖放元素移出目标元素时触发\ndrop 事件主体时目标元素，在目标元素完全接受被拖放元素时触发\ndragend 事件主体是被拖放元素，在整个拖放操作结束时触发\n\n20. 网页开发中，如何实现图片的懒加载描述：懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片\n直接将懒加载这事交给浏览器做，为图片加一个属性即可\n&lt;img src=\"kity.png\" loading=\"lazy\" />\n\n\n\n21. 浏览器中如何实现剪切板复制内容的功能描述：在一些博客系统中，可以复制代码，它是怎么实现的\n目前最为推荐的方式是用第三方库Clipboard API进行实现feross/clipboard-copy: Lightweight copy to clipboard for the web (github.com)\nnavigator.clipboard.writeText(text)\n\n复制\ndocument.execCommand(\"copy\")\n\n\n\n22. localhost:3000和localhost:5000的cookie信息是否共享根据同源策略，cookie是区分端口的，但是浏览器实现来说，cookie 区分域，而不区分端口，也就是说同一个ip下的cookie是共享的\n23. 什么是CSRF攻击CSRF跨站请求伪造，又称one-click-attack 顾名思义，通过恶意引导用户一次点击劫持cookie进行攻击，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\n\n使用JSON API，当进行CSRF攻击时，请求体通过&lt;form&gt; 构建，请求头application/www-form-urlencoded 它难以发送JSON数据被服务器所理解\nCSRF Token，生成一个随机的token，切勿放在cookie中，每次请求手动携带该token进行校验\nSameSite Cookie，设置为Lax或者Strict，禁止发送第三方Cookie\n\n24. 在浏览器中如何监听剪切板中内容通过Clipboard API 可以获取剪切板中内容，但需要获取到clipboard-read 权限\n// 是否有读取权限\nconst result=await navigator.permission.query(&#123;name:'clipboard-read'&#125;)\n\n// 获取剪切板内容\nconst text=await navigator.clipboard.readText()\n\n\n\n25. 如何把json数据转化为demo.json并下载文件json视为字符串，可以使用DataURL 进行下载，Text-&gt;DataURL \n除了使用DataURL，还可以转化为Object URL进行下载\nText - &gt; Blob -&gt; Object URL \n可以把以下代码直接粘贴到控制台下载文件\nfunction download(url, name) &#123;\n  const a = document.createElement(\"a\");\n  a.download = name;\n  a.rel = \"noopener\";\n  a.href = url;\n  // 触发模拟点击\n  a.dispatchEvent(new MouseEvent(\"click\"));\n  // 或者 a.click()\n&#125;\n\nconst json = &#123;\n  a: 3,\n  b: 4,\n  c: 5,\n&#125;;\nconst str = JSON.stringify(json, null, 2);\n\n// 方案一：Text -> DataURL\nconst dataUrl = `data:,$&#123;str&#125;`;\ndownload(dataUrl, \"demo.json\");\n\n// 方案二：Text -> Blob -> ObjectURL\nconst url = URL.createObjectURL(new Blob(str.split(\"\")));\ndownload(url, \"demo1.json\");\n\n总结\n\n模拟下载，可以通过新建一个&lt;a href=&quot;url&quot; download&gt; 标签并设置url 即download 属性来下载\n可以通过把json 转化为dataurl 来构造URL\n可以通过把json转化为Blob 再转化为ObjectURL 来构造URL\n\n26. 介绍requestIdleCallback及使用场景requestIdleCallback 维护一个队列，将在浏览器空闲时间内执行，属于后台任务API，可以使用setTimeout 来模拟实现\nconst rIC = window[\"requestIdleCallback\"] || ((f) => setTimeout(f, 1));\n\n在rIC 中执行任务时需要注意以下几点：\n\n执行重计算而非紧急任务\n空闲回调任务时间应该小于50ms，最好更少\n空闲回调中不要操作DOM，因为它本来就是利用的重排重绘后的空闲时间，重新操作DOM又会造成重绘重排\n\nReact的时间分片便是基于类似rIC而实现，然而因为rIC的见同行及50ms流畅问题，React自制了一个实现scheduler \n27. 如何计算白屏时间和首屏时间白屏时间: window.performance.timing.domLoading - window.performance.timing.navigationStart\n首屏时间: window.performance.timing.domInteractive - window.performance.timing.navigationStart\n28. 什么是重排重绘，如何减少重排重绘重排（Reflow）：元素的位置发生变动时发生重排，也叫回流\n重绘（Repaint）：元素的样式发生变动，位置不变。\n重排必定造成重绘，有以下方法\n\n使用DocumentFragment 进行DOM操作，不过现在原生操作很少，基本用不到\nCSS样式尽量批量修改\n避免使用table布局\n为元素提前设置好宽高，不因多次渲染改变位置\n\n29.  什么时Data URLData URL时将图片转换为base64直接嵌入到网页中，使用&lt;img src=&quot;data:[MIME type];base 64&quot; /&gt; 这种方式引用图片，不需要再发送请求获取图片，缺点\n\nbase64编码后的图片会比原来的体积大三分之一左右\nData URL形式的图片不会缓存下来，每次访问页面都要被下载一次，可以将Data URL写入到CSS文件中随着CSS被缓存下来\n\n30. textarea如何禁止拉伸使用CSS眼视光hi可以避免拉伸\ntextarea&#123;\n  resize:none\n&#125;\n\n\n\n31. 在Canvas中如何处理跨域的图片img.setAttribute('crossOrigin','anonymous')\n\n\n\n32. 如何取消请求的发送\nXHR使用xhr.abort() \n\nconst xhr=new XMLHttpRequest(),method=\"GET\",url=\"https://www.baidu.com\";\nxhr.open(method,url,true)\n\nxhr.end()\n\n// 取消发送请求\nxhr.abort()\n\n\nfetch使用AbortController\n\nconst controller = new AbortController()\nconst signal = controller.signal\n\nconst downloadBtn = document.querySelector('.download');\nconst abortBtn = document.querySelector('.abort');\n\ndownloadBtn.addEventListener('click', fetchVideo);\n\n// 点击取消按钮时，取消请求的发送\nabortBtn.addEventListener('click', function() &#123;\n  controller.abort();\n  console.log('Download aborted');\n&#125;);\n\nfunction fetchVideo() &#123;\n  ...\n  fetch(url, &#123;signal&#125;).then(function(response) &#123;\n    ...\n  &#125;).catch(function(e) &#123;\n   // 请求被取消之后将会得到一个 AbortError\n    reports.textContent = 'Download error: ' + e.message;\n  &#125;)\n&#125;\n\n\nAxios使用cancelToken 取消\n\nconst CancelToken=axios.CancelToken\nconst source=CancelToken.source()\n\naxios\n  .get('/user/1234',&#123;\n  cancelToken:souce.token\n&#125;)\n\t.catch(function(thrown)&#123;\n  if(axios.isCancel(thrown))&#123;\n    console.log('request canceled',thrown.message)\n  &#125;else&#123;\n    // handle error\n  &#125;\n&#125;)\n\naxios.post(\n\t'/user/123',\n  &#123;\n    name:'new name'\n  &#125;,\n  &#123;\n    cancelToken:source.token\n  &#125;\n)\n\nsource.cancel('operation canceled by the user')\n\n\n","slug":"HTML知识点","date":"2022-03-15T01:13:09.000Z","categories_index":"知识点","tags_index":"HTML,面试","author_index":"LIYUNFU"},{"id":"50ba5796497ecb4fe11ec2fa6f32ff0a","title":"常用算法","content":"题目1 - 将一个数组旋转k步\n输入数组[1,2,3,4,5,6,7]\n\nk=3,即旋转3步\n\n输出[5,6,7,1,2,3,4]\n\n\nconst arr = [1, 2, 3, 4, 5, 6, 7]\nfunction rotate2(arr, k) &#123;\n  const length = arr.length\n  if (!k || length === 0) return arr\n  const step = Math.abs(k % length)   // abs 取绝对值\n\n  const part1 = arr.slice(-step)\n  const part2 = arr.slice(0, length - step)\n  const part3 = [...part1, ...part2]\n  return part3\n&#125;\n\nconst arr2 = rotate2(arr, 3)\nconsole.log(arr2)\n\n\n\n题目2 - 快速排序\n用JavaScipt 实现快速排序，并说明时间复杂度\n\n找到中间位置midValue\n\n遍历数组，小于midValue放在left，否则放在right\n\n继续递归，最后concat拼接，返回\n\n\nfunction quickSort(arr:number[]):number[]&#123;\n  const length=arr.length\n  if(length===0)return arr\n  \n  const midIndex=Math.floor(length/2)\n  const midValue=arr.slice(midIndex,midIndex+1)[0]\n  \n  const left:number[]=[]\n  const right:number[]=[]\n  \n  for(let i=0;i&lt;length;i++)&#123;\n    if(i!==midIndex)&#123;\n      const n=arr[i]\n      if(n&lt;midValue)&#123;\n        // 小于midValue 则放在left\n        left.push(n)\n      &#125;else&#123;\n        // 大于 midValue 则放在right\n        right.push(n)\n      &#125;\n    &#125;\n  &#125;\n  \n  return quickSort(left).concat([midValue],quickSort(right))\n&#125;\n\nconst arr=[1,6,2,7,3,8,4,9,5]\nconsole.log(quickSort(arr))\n\n\n\n题目3 - 判断字符串是否括号匹配\n一个字符串s可能包含{} () [] 三种括号\n\n判断s是否是括号匹配的\n\n如(a{b}c)匹配，而{a(b或{a(b}c) 就不匹配\n\n\nfunction isMatch(left, right) &#123;\n  if (left === '[' &amp;&amp; right == ']') return true\n  if (left === '&#123;' &amp;&amp; right == '&#125;') return true\n  if (left === '(' &amp;&amp; right == ')') return true\n  return false\n&#125;\nfunction matchBracket(str) &#123;\n  const length = str.length\n  if (length === 0) return true\n\n  const stack = []\n\n  const leftSymbols = '&#123;[('\n  const rightSymbols = '&#125;])'\n\n  for (let i = 0; i &lt; length; i++) &#123;\n    const s = str[i]\n    if (leftSymbols.includes(s)) &#123;\n      // 左括号\n      stack.push(s)\n    &#125; else if (rightSymbols.includes(s)) &#123;\n      // 右括号，判断栈顶\n      console.log('右括号' + s)\n      const top = stack[stack.length - 1]\n      if (isMatch(top, s)) &#123;\n        stack.pop()\n      &#125; else &#123;\n        return false\n      &#125;\n    &#125;\n  &#125;\n  return stack.length === 0\n&#125;\n\nconst str = '&#123;a(b[c])&#125;'\nconsole.log(matchBracket(str))\n\n\n\n题目4 - 反转单向链表\n输入一个单向链表，输出它的反转(头变尾，尾变头)\n\ninterface ILinkListNode &#123;\n  value: number,\n  next?: ILinkListNode\n&#125;\n // 反转链表\nfunction reverseLinkList(listNode: ILinkListNode): ILinkListNode &#123;\n  // 定义三个指针\n  let prevNode: ILinkListNode | undefined = undefined\n  let curNode: ILinkListNode | undefined = undefined\n  let nextNode: ILinkListNode | undefined = listNode\n\n  // 以nextNode为主 遍历链表\n  while (nextNode) &#123;\n    // 第一个元素 删掉next 防止循环引用\n    if (curNode &amp;&amp; !prevNode) &#123;\n      delete curNode.next\n    &#125;\n\n    // 反转指针\n    if (curNode &amp;&amp; prevNode) &#123;\n      curNode.next = prevNode\n    &#125;\n\n    // 整体向后移动\n    prevNode = curNode\n    curNode = nextNode\n    nextNode = nextNode?.next\n  &#125;\n\n  // 当nextNode空时\n  curNode!.next = prevNode\n\n  return curNode\n&#125;\n  // 创建链表\nfunction createLinkList(arr: number[]): ILinkListNode &#123;\n  const length = arr.length\n  if (length === 0) throw new Error('arr is empty')\n\n  let curNode: ILinkListNode = &#123;\n    value: arr[length - 1]\n  &#125;\n  for (let i = length - 2; i >= 0; i--) &#123;\n    curNode = &#123;\n      value: arr[i],\n      next: curNode\n    &#125;\n  &#125;\n\n  return curNode\n&#125;\n\nconst arr = [100, 200, 300, 400, 500]\nconst list = createLinkList(arr)\nconsole.log(list)\n\nconst list1 = reverseLinkList(list)\nconsole.log(list1)\n\n\n\n题目5 - 用链表实现队列interface ILinkListNode &#123;\n  value: number,\n  next?: ILinkListNode\n&#125;\n\nclass MyQueue &#123;\n  private head: ILinkListNode | null = null\n  private tail: ILinkListNode | null = null\n  private len = 0\n  // 入队 在tail位置\n  add(n: number) &#123;\n    const newNode: ILinkListNode = &#123;\n      value: n,\n      next: null\n    &#125;\n    // 处理head\n    if (this.head === null) &#123;\n      this.head = newNode\n    &#125;\n\n    // 处理tail\n    const tailNode = this.tail\n    if (tailNode) &#123;\n      tailNode.next = newNode\n    &#125;\n    this.tail = newNode\n\n    // 记录长度\n    this.len++\n  &#125;\n  // 出队 在head位置\n  delete(): number | null &#123;\n    const headNode = this.head\n    if (headNode == null) return null\n    if (this.len &lt;= 0) return null\n\n    // 取值\n    const value = headNode.value\n\n    //处理head\n    this.head = headNode.next\n\n    // 记录长度\n    this.len--\n\n    return value\n  &#125;\n  get length(): number &#123;\n    // length要单独存储 不能遍历链表来存取 \n    return this.len\n  &#125;\n&#125;\n\nconst q = new MyQueue()\n\nq.add(100)\nq.add(200)\nq.add(300)\nconsole.log('length1', q.length)\nconsole.log(q.delete())\n\n\n\n题目6 - 用两个栈实现一个队列class MyQueue &#123;\n  private stack1: number[] = []\n  private stack2: number[] = []\n\n  /**\n   * 入队\n   */\n  add(n: number) &#123;\n    this.stack1.push(n)\n  &#125;\n\n  /**\n   * 出队\n   */\n  delete(): number | null &#123;\n    let res\n\n    const stack1 = this.stack1\n    const stack2 = this.stack2\n\n    // 将stack1 所有元素移动到stack2中\n    while (stack1.length) &#123;\n      const n = stack1.pop()\n      if (n != null) &#123;\n        stack2.push(n)\n      &#125;\n    &#125;\n\n    // stack2 pop\n    res = stack2.pop()\n\n    // 将stack2所有元素还给stack1\n    while (stack2.length) &#123;\n      const n = stack2.pop()\n      if (n != null) &#123;\n        stack1.push(n)\n      &#125;\n    &#125;\n    return res || null\n  &#125;\n  get length(): number &#123;\n    return this.stack1.length\n  &#125;\n&#125;\n\n\n\n题目7 - 用JS实现二分查找\n递归 - 代码逻辑更加清晰\n\n非递归 - 性能更好\n\n时间复杂度O(logn)\n\n循环查找\n\n凡有序必二分，凡二分，时间复杂度必包含O(logn)\n\n\nfunction binarySearch1(arr: number[], target: number): number &#123;\n  const length = arr.length\n  if (length === 0) return -1\n\n  let startIndex = 0  // 开始位置\n  let endIndex = length - 1  // 结束位置\n\n  while (startIndex &lt;= endIndex) &#123;\n    const midIndex = Math.floor((startIndex + endIndex) / 2)\n    const midValue = arr[midIndex]\n    if (target &lt; midValue) &#123;\n      // 目标值较小 则继续在左侧查找\n      endIndex = midIndex - 1\n    &#125; else if (target > midValue) &#123;\n      // 目标值较大，则继续在右侧查找\n      startIndex = midIndex + 1\n    &#125; else &#123;\n      // 相等 返回\n      return midIndex\n    &#125;\n  &#125;\n  return -1\n&#125;\n\n// 功能测试\nconst nums = [10, 20, 30, 40, 50, 60]\nconsole.log(binarySearch1(nums, 50))\n\n\n递归查找\n\nfunction binarySearch2(arr: number[], target: number, startIndex?: number, endIndex?: number) &#123;\n  const length = arr.length\n  if (length === 0) return -1\n\n  // 开始和结束的范围\n  if (startIndex == null) startIndex = 0\n  if (endIndex == null) endIndex = length - 1\n\n  // 如果start 和 end相遇，则结束\n  if (startIndex > endIndex) return -1\n\n  // 中间位置\n  const midIndex = Math.floor((startIndex + endIndex) / 2)\n  const midValue = arr[midIndex]\n\n  if (target &lt; midValue) &#123;\n    // 目标值较小 则继续在左侧查找\n    return binarySearch2(arr, target, startIndex, midIndex - 1)\n  &#125; else if (target > midValue) &#123;\n    // 目标值较大 则继续在右侧查找\n    return binarySearch2(arr, target, midIndex + 1, endIndex)\n  &#125; else &#123;\n    // 相等 返回\n    return midIndex\n  &#125;\n&#125;\n\n\n\n题目8 - 给一个数组，找出其中和为n的两个元素\n有一个递增的数组[1,2,4,7,11,15] 和一个n=15\n数组中有两个数，和是n，即4+11===15\n\nfunction findTowNumber(arr: number[], n: number): number[] &#123;\n  const res: number[] = []\n\n  const length = arr.length\n\n  let i = 0  // 头\n  let j = length - 1  //尾\n\n  while (i &lt; j) &#123;\n    const n1 = arr[i]\n    const n2 = arr[j]\n    const sum = n1 + n2\n\n    if (sum > n) &#123;\n      // sum大于n 则j要向前移动\n      j--\n    &#125; else if (sum &lt; n) &#123;\n      // sum小于n 则i要向后移动\n      i++\n    &#125; else &#123;\n      // 相等\n      res.push(n1)\n      res.push(n2)\n      break\n    &#125;\n  &#125;\n  return res\n&#125;\n\nconst nums = [1, 2, 4, 7, 11, 15]\nconsole.info(findTowNumber(nums, 15))\n\n\n\n题目9 - 求二叉搜索树的第k小值\n\n二叉搜索树BST即左边小于根，右边大于根\n\ninterface ITreeNode &#123;\n  value: number\n  left: ITreeNode | null\n  right: ITreeNode | null\n&#125;\n\nconst arr: number[] = []\nfunction preOrderTraverse(node: ITreeNode) &#123;\n  if (node == null) return\n  // console.log(node.value)\n  arr.push(node.value)\n  preOrderTraverse(node.left)\n  preOrderTraverse(node.right)\n&#125;\n\nfunction inOrderTraverse(node: ITreeNode | null) &#123;\n  if (node == null) return\n  inOrderTraverse(node.left)\n  // console.log(node.value)\n  arr.push(node.value)\n  inOrderTraverse(node.right)\n&#125;\n\nfunction postOrderTraverse(node: ITreeNode | null) &#123;\n  if (node == null) return\n  postOrderTraverse(node.left)\n  postOrderTraverse(node.right)\n  // console.log(node.value)\n  arr.push(node.value)\n&#125;\n\nfunction getKthValue(node: ITreeNode, k: number): number | null &#123;\n  inOrderTraverse(node)\n  console.log(arr)\n\n  return arr[k - 1] | null\n&#125;\nconst tree: ITreeNode = &#123;\n  value: 5,\n  left: &#123;\n    value: 3,\n    left: &#123;\n      value: 2,\n      left: null,\n      right: null\n    &#125;,\n    right: &#123;\n      value: 4,\n      left: null,\n      right: null\n    &#125;\n  &#125;,\n  right: &#123;\n    value: 7,\n    left: &#123;\n      value: 6,\n      left: null,\n      right: null\n    &#125;,\n    right: &#123;\n      value: 8,\n      left: null,\n      right: null\n    &#125;\n  &#125;\n&#125;\n\nconsole.log(getKthValue(tree, 3))\n\n\n\n题目10 - 求斐波那契数列的弟n值\n用JS计算斐波那契数列的第n个值\n注意时间复杂度\n\nfunction fibonacci(n:number):number&#123;\n  if(n&lt;=0) return 0\n  if(n===1)return 1\n  \n  let n1=0\n  let n2=1\n  let res=0\n  \n  for(let i=2;i&lt;=n;i++)&#123;\n    res=n1+n2\n    \n    n1=n2\n    n2=res\n  &#125;\n  return res\n&#125;\n\nconsole.log(fibonacci(3))\n\n\n\n题目11 - 青蛙跳台阶\n一只青蛙，一次可跳1级，也可跳2级\n问：青蛙跳到n级台阶，总共有多少种方式\n\nvar numWays = function(n) &#123;\n    if(n&lt;=0)return 1\n    if(n===1) return 1\n    \n    let n1=1\n    let n2=1\n    let res=0\n\n    for(let i=2;i&lt;=n;i++)&#123;\n        res=(n1+n2)%(1e9+7)\n        n1=n2\n        n2=res\n    &#125;\n    return res\n&#125;;\n\n\n\n题目12 - 将数组中的0移动到末尾\n如输入[1,0,3,0,11,0] ， 输出[1,3,11,0,0,0]\n\n只移动0，其他顺序不变\n\n必须在原数组进行操作\n\n\nfunction moveZero(arr:number[]):void&#123;\n  const length=arr.length\n  if(length===0) return\n  \n  let i\n  j=-1  //指向第一个0\n  for(i=0;i&lt;length;i++)&#123;\n    if(arr[i]===0)&#123;\n      // 第一个0\n      if(j&lt;0)&#123;\n        j=i\n      &#125;\n    &#125;\n    if(arr[i]!==0&amp;&amp;j>=0)&#123;\n      const n=arr[i]\n      arr[i]=arr[j]\n      arr[j]=n\n      \n      j++\n    &#125;\n  &#125;\n&#125;\n\nconst arr=[1,0,1,1,4,5,0,1,0,0,0,1,2]\nmoveZero(arr)\nconsole.log(arr)\n\n\n\n题目13 - 求字符串中连续最多的字符，以及次数\n如，输入’abbccddeeee1234’ ,计算得出\n连续最多的字符是’e’ 4次\n\n双指针\n\n定义指针i和j，j不动，i继续移动\n\n如果i和 j的值一直相等，则i继续移动\n\n直到i和j的值不相等，记录处理，让j追上i，继续第一步\n\n\nfunction findContinuousChar(str:string):IRes&#123;\n  const res:IRes=&#123;\n    char:'',\n    length:0\n  &#125;\n  \n  const length=str.length\n  if(length===0)return res\n  \n  let tempLength=0  // 临时记录当前连续字符的长度\n  let i=0\n  let j=0\n  \n  for(;i&lt;length;i++)&#123;\n    if(str[i]===str[j])&#123;\n      tempLength++\n    &#125;\n    \n    if(str[i]!==str[j]||i===length-1)&#123;\n      // 不相等 或者i到了字符串的末尾\n      if(tempLength>res.length)&#123;\n        res.char=str[j]\n        res.length=tempLength\n      &#125;\n      tempLength=0  //reset\n      \n      if(i&lt;length-1)&#123;\n        j=i  //让j追上 i\n        i-- // 细节\n      &#125;\n    &#125;\n  &#125;\n  \n  return res\n&#125;\n\nconsole.log(findContinuousChar(\"abaabbbbccddee\"))\n\n\n\n题目14 - 获取1-10000之前所有的对称数(回文数)function findPalindromeNumber(max:number):number[]&#123;\n  const res:number[]=[]\n  if(max&lt;=0)return res\n  \n  for(let i=1;i&lt;=max;i++)&#123;\n    let n=i\n    let rev=0  //存储反转数\n    \n    // 生成反转数\n    while(n>0)&#123;\n      rev=rev*10+n%10\n      n=Math.floor(n/10)\n    &#125;\n    if(i===rev)res.push(i)\n  &#125;\n  return res\n&#125;\n\nconsole.log(findPalindromeNumber(200))\n\n/*\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]\n*/\n\n\n\n题目15 - 高效的英文单词前缀匹配\n有一个英文单词库（数组），里面有几十万个英文单词\n\n输入一个字符串，快速判断是不是某一个单词的前缀\n\n（说明思路，不用写代码）\n\n\n实现方法\n\n将二十六个字母拆分匹配成一个26叉树  -  这一步很长时间才更新一次，不算进算法中\n\n使用hash key查找即可，例如str.a.c.b.c.d\n\n有明确范围的数据(如26个英文字母)，考虑使用哈希表(对象)\n\n\n题目16 - 数字千分位格式化\n将数字千分位格式化，输出字符串\n\n如输入数字12050100，输出字符串12，050，100\n\n（注意：逆序判断）\n\n\n常见思路\n\n使用数组\n\nfunction format(n: number): string &#123;\n    n = Math.floor(n) // 只考虑整数\n\n    const s = n.toString()\n    const arr = s.split('').reverse()\n    return arr.reduce((prev, val, index) => &#123;\n        if (index % 3 === 0) &#123;\n            if (prev) &#123;\n                return val + ',' + prev\n            &#125; else &#123;\n                return val\n            &#125;\n        &#125; else &#123;\n            return val + prev\n        &#125;\n    &#125;, '')\n&#125;\n\n\n使用字符串（推荐）\n\nfunction format(n: number): string &#123;\n    n = Math.floor(n) // 只考虑整数\n\n    let res = ''\n    const s = n.toString()\n    const length = s.length\n\n    for (let i = length - 1; i >= 0; i--) &#123;\n        const j = length - i\n        if (j % 3 === 0) &#123;\n            if (i === 0) &#123;\n                res = s[i] + res\n            &#125; else &#123;\n                res = ',' + s[i] + res\n            &#125;\n        &#125; else &#123;\n            res = s[i] + res\n        &#125;\n    &#125;\n\n    return res\n&#125;\n\n\n\n题目17 - 切换字母大小写\n输入一个字符串，切换其中字母的大小写\n如，输入字符串12bBc34，输出字符串12AbC34\n\n常见思路\n\n正则表达式\nASCII表\n\nfunction switchLetterCase(s:string):string&#123;\n  const res=''\n  \n  const length=s.length\n  if(length===0)return res\n  \n  for(let i=0;i&lt;length;i++)&#123;\n    const c=s[i]\n    const code=c.charCodeAt(0)\n    \n    if(code>=65&amp;&amp;code&lt;=90)&#123;\n      res+=c.toLowerCase()\n    &#125;else if(code>=97&amp;&amp;code&lt;=122)&#123;\n      res+=c.toUpperCase()\n    &#125;else&#123;\n      res+=c\n    &#125;\n  &#125;\n  \n  return res\n&#125;\n\nconsole.log(switchLetterCase('12bBc34'))\n\n\n\n题目18 - 为什么0.1+0.2!==0.3计算机使用二进制存储数据\n\n整数转换二进制没有误差，如9转换为二进制是1001\n\n而小数可能无法用二进制准确表达，如0.2转换为0.20000001\n\n可以用math.js库\n\n\n持续更新中……","slug":"常用算法","date":"2022-03-14T10:17:13.000Z","categories_index":"知识点","tags_index":"算法,数据结构","author_index":"LIYUNFU"},{"id":"ce895751a313319f06b50d562f5dd5db","title":"ES6新特性","content":"let&amp;const解构赋值数组新特性\nArray.of() ：将一组值转化为数组，返回一个新数组，并且不考虑参数的数量或类型\ncopyWithin() ：把指定位置的成员复制到其他位置，返回原数组\nfind() ：返回第一个符合条件的值\nfindIndex() ：返回第一个符合条件的索引\nkeys() ： 对键名的1遍历，返回一个遍历器对象，可用for-of 循环\nvalues() ：与keys() 用法一样，不过是对键值的遍历\nentries() ：与keys() 用法一样，不过是对 键值对的遍历\nArray.from() ： 从一个类数组或可迭代对象中新建一个新的数组实例\nfill() ： 使用定制的元素填充数组，返回原数组\nincludes() ：判断是否包含某一个元素，返回布尔值，对NaN有效，但不能定位，第二个参数开始寻找位置\nflatMap() ：方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组\nflat() ： 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，默认值为1(应用：数组扁平化(当输入Infinity 自动解到最底层))\n\nlet arr = [1, 2, 3, 4, 5]\n\n//Array.of()\nlet arr1 = Array.of(1, 2, 3);\nconsole.log(arr1) // [1, 2, 3]\n\n//copyWithin(): 三个参数 (target, start = 0, end = this.length)\n// target: 目标的位置\n// start: 开始位置，可以省略，可以是负数。\n// end: 结束位置，可以省略，可以是负数，实际位置是end-1。\nconsole.log(arr.copyWithin(0, 3, 5)) // [4, 5, 3, 4, 5]\n\n//find()\nconsole.log(arr.find((item) => item > 3 )) // 4\n\n//findIndex()\nconsole.log(arr.findIndex((item) => item > 3 )) // 3\n\n// keys()\nfor (let index of arr.keys()) &#123;\n    console.log(index); // 一次返回 0 1 2 3 4\n&#125;\n\n// values()\nfor (let index of arr.values()) &#123;\n    console.log(index); // 一次返回 1 2 3 4 5\n&#125;\n\n// entries()\nfor (let index of arr.entries()) &#123;\n    console.log(index); // 一次返回 [0, 1] [1, 2] [2, 3] [3, 4] [4, 5]\n&#125;\n\n let arr = [1, 2, 3, 4, 5]\n\n// Array.from(): 遍历的可以是伪数组，如 String、Set结构，Node节点\nlet arr1 = Array.from([1, 3, 5], (item) => &#123;\n    return item * 2;\n&#125;)\nconsole.log(arr1) // [2, 6, 10] \n\n// fill(): 三个参数 (target, start = 0, end = this.length)\n// target: 目标的位置\n// start: 开始位置，可以省略，可以是负数。\n// end: 结束位置，可以省略，可以是负数，实际位置是end-1。\nconsole.log(arr.fill(7)) // [7, 7, 7, 7, 7]\nconsole.log(arr.fill(7, 1, 3)) // [1, 7, 7, 4, 5]\n\nlet arr = [1, 2, 3, 4]\n\n//includes()\nconsole.log(arr.includes(3)) // true\nconsole.log([1, 2, NaN].includes(NaN)); // true\n\nlet arr = [1, 2, 3, 4]\n\n// flatMap()\nconsole.log(arr.map((x) => [x * 2])); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\nconsole.log(arr.flatMap((x) => [x * 2])); // [ 2, 4, 6, 8 ]\nconsole.log(arr.flatMap((x) => [[x * 2]])); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\n\nconst arr1 = [0, 1, 2, [3, 4]];\nconst arr2 = [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr1.flat()); // [ 0, 1, 2, 3, 4 ]\nconsole.log(arr2.flat(2)); // [ 0, 1, 2, [ 3, 4 ] ]\nconsole.log(arr2.flat(Infinity)); // [ 0, 1, 2, 3, 4 ]\n\n字符串新特性\nUnicode：大括号包含表示Unicode字符\ncodePointAt() ： 返回字符对应码点，与fromCharCode() 对应\nString.fromCharCode() ：将对应的码点返回为字符，与codePointAt() 对应\nString.raw() ：返回把字符串所有变量替换且对斜杠进行转义的结果\nstartsWith() ： 返回布尔值，表示参数字符串是否存在元字符串的头部\nendsWith ：返回布尔值，表示参数字符串是否存在源字符串的头部\nrepart() ：返回一个新字符串，表示将原字符串重复n次\nincludes() ：返回布尔值，表示是否找到了参数字符串\ntrimStart() ：方法从字符串的开头删除空格，trimLeft() 是此方法的别名\ntrimEnd() ：方法从字符串的末端删除空格，trimRight() 是此方法的别名\npadStart() ： 用于头部补全\npadEnd() ： 用于尾部补全\nJSON.stringify() : 可返回不符合UTF-8标准的字符串\nreplace() ：仅替换一个 字符串中某模式的首个实例\nreplaceAll() ： 返回一个新字符串，该字符串中用一个替换项替换了原字符串所有匹配了模式的部分\n模式可以是一个字符串或一个正则表达式，而替换项可以是一个字符串或一个应用于每个匹配项的函数\n\n//Unicode\nconsole.log(\"a\", \"\\u0061\"); // a a\nconsole.log(\"d\", \"\\u&#123;4E25&#125;\"); // d 严\n\nlet str = 'Domesy'\n\n//codePointAt()\nconsole.log(str.codePointAt(0)) // 68\n\n//String.fromCharCode()\nconsole.log(String.fromCharCode(68)) // D\n\n//String.raw()\nconsole.log(String.raw`Hi\\n$&#123;1 + 2&#125;`); // Hi\\n3\nconsole.log(`Hi\\n$&#123;1 + 2&#125;`); // Hi 3\n\nlet str = 'Domesy'\n\n//startsWith()\nconsole.log(str.startsWith(\"D\")) // true\nconsole.log(str.startsWith(\"s\")) // false\n\n//endsWith()\nconsole.log(str.endsWith(\"y\")) // true\nconsole.log(str.endsWith(\"s\")) // false\n\n//repeat(): 所传的参数会自动向上取整，如果是字符串会转化为数字\nconsole.log(str.repeat(2)) // DomesyDomesy\nconsole.log(str.repeat(2.9)) // DomesyDomesy\n\n// 遍历：for-of\n for(let code of str)&#123;\n   console.log(code) // 一次返回 D o m e s y\n &#125;\n \n //includes()\n console.log(str.includes(\"s\")) // true\n console.log(str.includes(\"a\")) // false\n \n // trimStart()\n const string = \"   Hello world!   \";\n console.log(string.trimStart()); // \"Hello world!   \"\n console.log(string.trimLeft()); // \"Hello world!   \"\n \n // trimEnd()\n const string = \"   Hello world!   \";\n console.log(string.trimEnd()); // \"   Hello world!\"\n console.log(string.trimRight()); // \"   Hello world!\"\n\nlet str = 'Domesy'\n\n//padStart(): 会以空格的形式补位吗，这里用0代替，第二个参数会定义一个模板形式，会以模板进行替换\nconsole.log(\"1\".padStart(2, \"0\")); // 01\nconsole.log(\"8-27\".padStart(10, \"YYYY-0M-0D\")); //  YYYY-08-27\n \n// padEnd()：与padStart()用法相同\nconsole.log(\"1\".padEnd(2, \"0\")); // 10\n\n//JSON.stringify() 升级\nconsole.log(JSON.stringify(\"\\uD83D\\uDE0E\")); // 😎\nconsole.log(JSON.stringify(\"\\u&#123;D800&#125;\")); // \\ud800\n\nlet str = \"Hi！，这是ES6~ES12的新特性，目前为ES12\"\n\nconsole.log(str.replace(\"ES\", \"SY\")); // Hi！，这是SY6~ES12的新特性，目前为ES12\nconsole.log(str.replace(/ES/g, \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\n\nconsole.log(str.replaceAll(\"ES\", \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\nconsole.log(str.replaceAll(/ES/g, \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\n\n\n\n","slug":"ES6新特性","date":"2022-03-12T10:48:14.000Z","categories_index":"知识点","tags_index":"ES6,前瞻","author_index":"LIYUNFU"},{"id":"deb07f2084ce5c6636760b3189f1eaa0","title":"git命令备忘录","content":"\ngit init 初始化版本库\ngit add 每次提交前都要添加\ngit commit -m “修改信息”  \ngit log 打印提交记录\ngit diff readme  查看版本区别\ngit reset 回到某个版本  git reset --hard  版本代号\ngit reflog 打印操作记录 再使用git reset 版本号可以到未来\n工作区的文件git add之后到了暂存区，暂存区git commit一次性提交到master分支\ngit diff HEAD -- readme.txt 查看工作区和版本库里面最新版本的区别\ngit checkout -- readme.txt 丢弃工作区的修改，从暂存区恢复\ngit reset HEAD readme.txt暂存区回到上一个版本\ngit remote add origin git@github.com:michaelliao/learngit.git 关联远程仓库\ngit push -u origin master第一次推送\ngit push origin master以后推送\ngit remote -v查看远程仓库\ngit remote rm origin解除远程仓库\ngit switch -c dev创建并切换到新的dev分支\ngit switch master切换到master分支\ngit branch查看分支\ngit branch -d dev删除分支\ngit merge dev将dev分支合并到当前分支上\ngit merge --no-ff -m &quot;merge with no-ff&quot; dev合并分支并禁用快速合并\ngit stash把当前工作现场储存下来，方便下一次恢复现场继续工作 \ngit stash pop恢复现场，并把stash内容删除\ngit cherry-pick &lt;commit&gt;  如果当前也有bug 就把原先的提交复制到这儿一份\n命令git push origin &lt;tagname&gt;可以推送一个本地标签；\n命令git push origin --tags可以推送全部未推送过的本地标签；\n命令git tag -d &lt;tagname&gt;可以删除一个本地标签；\n命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。\n\n","slug":"git命令备忘录","date":"2022-03-05T03:08:36.000Z","categories_index":"知识点","tags_index":"git,备忘录","author_index":"LIYUNFU"},{"id":"6f0689131b9192e324f81c8459e5c263","title":"ajax基本使用及跨域过程","content":"ajax\n是什么：ajax是Asynchronous JavaScript and XML（异步 JavaScript 和 XMl）的简写\n异步：异步得像服务器发送请求，在等待响应的过程中，不会阻塞当前页面，浏览器可以做自己的事情。直到成功获取响应后，浏览器才开始处理响应数据\nAjax 需要服务器环境，非服务器环境下，很多浏览器无法正常使用ajax\n\nXMLHttpRequest//创建xhr对象\nconst xhr=new XMLHttpRequest();\n\n//监听事件，处理响应\nxhr.addEventListener('readystatechange',()=>&#123;&#125;,false)\n//或\nxhr.onreadystatechange=()=>&#123;&#125;\n\n//处理响应\nxhr.onreadystatechange=()=>&#123;\n    if(xhr.readyState!==4)return;\n    \n    //http code\n    //获取到响应后，响应的内容会自动填充xhr对象的属性\n    if(xhr.status>=200&amp;&amp;xhr.status&lt;300||xhr.status===304)&#123;\n        console.log(xhr.responseText)\n    &#125;\n&#125;\n\n/*\nreadystatechange 事件监听readyState这个状态的变化\n0: 未初始化，尚未调用open()\n1: 启动，已经调用open() 但尚未调用send()\n2: 发送，已经调用send() 但尚未接收到响应\n3: 接收，已经接收到部分响应数据\n4: 完成，已经接收到全部响应数据，而且已经可以在浏览器中使用了\n*/\n\n//准备发送请求\nxhr.open(\n\t'HTTP 方法 GET、POST、PUT、DELETE',\n    '地址 URL',\n    true //是否异步\n)\n\n//发送请求 send的参数是通过请求体携带的数据 只有post能携带请求体\nxhr.send(null)\n\n属性\nresponseType 和 response 属性\nxhr.onreadystatechange = () => &#123;\n  if (xhr.readyState != 4) return;\n  if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n    // 文本形式的响应内容\n    // responseText 只能在没有设置 responseType 或者 responseType = '' 或 'text' 的时候才能使用\n    // console.log('responseText:', xhr.responseText);\n    // 可以用来替代 responseText\n    console.log('response:', xhr.response);\n    // console.log(JSON.parse(xhr.responseText));\n  &#125;\n&#125;;\n\nxhr.responseType = 'text';\ntimeout属性\n//设置请求的超时时间（单位ms） 在发送之前\n xhr.open('GET', url, true);\n\nxhr.timeout = 10000;\n\nxhr.send(null);\nwithCredentials属性\n//指定使用ajax发送请求时是否携带cookie\nxhr.open('GET', url, true);\n\nxhr.withCredentials = true;\n\nxhr.send(null);\n\n方法\nabort() 终止当前请求\nxhr.open('GET', url, true);\nxhr.send(null);\nxhr.abort();\n//放在发送之后\nsetRequestHeader()设置请求头消息\nxhr.setRequestHeader(头部字段的名称, 头部字段的值);\nxhr.setRequestHeader('Content-Type','application/json')\n\n事件\nload事件 响应数据可用时触发\nxhr.onload=()=>&#123;&#125;\nxhr.addEventListener('load',()=>&#123;&#125;)\n//代替readystatechange 可以有效减少判断标识为4 的状态\nerror事件 请求发生错误时触发\nxhr.addEventListener(\n  'load',\n  () => &#123;\n    if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n      console.log(xhr.response);\n    &#125;\n  &#125;,\n  false\n);\nxhr.addEventListener(\n  'error',\n  () => &#123;\n    console.log('error');\n  &#125;,\n  false\n)\nabort事件 调用abort方法后触发\nxhr.addEventListener(\n  'abort',\n  () => &#123;\n    console.log('abort');\n  &#125;,\n  false\n);\n\nJson不支持undefined\n\nJSON.parse()\n将json字符串转化为JS的数据类型，对象或者数组\n\n\nJSON.stringify()\n将JS的基本数据类型，对象或者数组转化为JSON的字符串\n\n\n\nCORS\n使用CORS 跨域的过程\n① 浏览器发送请求\n② 后端在响应头中添加Access-Control-Allow-Origin 头信息\n③ 浏览器接收到响应\n④ 如果是同域下的请求，浏览器不会额外做什么，这次前后端通信就圆满了\n⑤ 如果是跨域请求，浏览器会从响应头中查找是否允许跨域访问\n⑥ 如果允许跨域，通信圆满完成\n⑦ 如果没找到或步包含想要跨域的域名，就丢弃响应结果\n\n\n","slug":"ajax基本使用及跨域过程","date":"2022-03-05T03:06:30.000Z","categories_index":"知识点","tags_index":"ajax,跨域","author_index":"LIYUNFU"},{"id":"c123efc46127ac74fdea33d3d47fa7a0","title":"远程服务器安装Docker并配置数据库","content":"Docker命令安装docker-desktop点击前往官网下载，一直下一步安装即可\n如果出现错误，说明wsl内核未更新到wsl2，点击下载安装之后重启docker-desktop即可\n查看已安装docker版本docker --version\n安装docker-compose\n\n\n\n\n\n\n\n\nDocker Compose是一个工具，旨在帮助定义和共享多容器应用程序。使用Compose，我们可以创建一个YAML文件来定义服务，并且使用单个命令，可以启动所有内容或将其全部拆解。使用 Compose的最大优点是，您可以在文件中定义应用程序堆栈，将其保留在项目存储库的根目录下（现在是受版本控制的），并轻松地让其他人能够为您的项目做出贡献。有人只需要克隆你的存储库并启动撰写应用。事实上，你现在可能会在GitHub/GitLab上看到相当多的项目在做这件事。\n简单来说就是 docker-compose能够让你自定义一个YAML配置文件，能够一键启动所有任务安装了docker desktop的自带docker-compose不需要再安装了\n\nLinux安装教程 https://docs.docker.com/compose/install/\n\n安装mongo使用Docker Hub搜索mongo 点击进入mongo-Docker Hub\ndocker pull mongo:4  #可接版本号也可不接\n\n查看本地下载了哪些镜像docker images\n\n运行mongo映射到宿主机上docker run -d --name some-mongo -p 10050:27017 mongo:4\n\n运行MYSQL映射到宿主机上docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -p 10051:3306 -d mysql:5.6\n\n查看当前运行的服务docker ps\n\n在Linux机器中需要放行端口 10050方案一 直接关闭防火墙#ubuntu\nservice ufw stop\n#centos\nservice firewalld stop\n\n方案二 放行指定端口# ubuntu\nufw allow Port 端口号\n\n#centos\nfirewall-cmd --zone&#x3D;public --add-port&#x3D;10050&#x2F;tcp --permanent\n\n重载防火墙firewall-cmd --reload\n\n提交自己的images提交到docker仓库docker commit id号  liyunfu&#x2F;mysql:1.0\ndocker push liyunfu&#x2F;mysql:1.0 \n\n拉取自己的imagesdocker pull liyunfu&#x2F;mysql:1.0\n\n删除imagesdocker image rm id号\n\n\n\ndocker-compose编写YML文件version: '3'\nservices:\n  mysql1:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10052:3306\n\n  mysql2:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10053:3306\n\n执行YMLdocker-compose up\n\n\n\nLinux连接远程服务器ssh -p 27822 root@server.bontor.cn   # ssh -p 端口  用户名@服务器地址\n\n查看操作系统版本lsb_release -a\n\n查看内核版本uname -a\n\n检查文件系统磁盘空间占用情况df -Th  # 后缀变为以G为单位 不加以字节为单位\n\n目录结构&#x2F;home  主目录\n&#x2F;etc   软件配置文件\n&#x2F;sys   系统目录\n&#x2F;usr   系统可执行文件\n&#x2F;var   日志文件 不断增长大小\n\nCPU和内存top #查看正在运行的进程 已经cpu占用情况 和内存使用情况\n\n文档型：文件相关命令(touch，cat，echo，rm，vi，cd)touch test.txt \nvi test.txt\ncd &#x2F;home\ncat test.txt\necho &quot;123123&quot;&gt;&gt;test.txt  #两个箭头追加 一个箭头覆盖  \n\n硬件型：磁盘/进程/服务/网络查看进程ps -ef | grep docker  #查询并使用grep筛选 docker进程\n\n强制关闭进程kill -9 进程的PID\n\n查看服务的状态service sshd status\n\n关闭服务service sshd stop  #关闭sshd服务\n\n重启服务service sshd restart\n\n功能型：压缩/解压，下载，远程下载wget 资源地址\n\n解压tar zxvf app.tar.gz\n\n压缩tar zcvf app.tar.gz app\n\n\n\n修改默认SSH端口查看默认监听端口netstat -anlp | grep sshd\n\n修改默认监听端口vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config\n#删除#  修改port 22 为 port 27001\n\n#centos修改之后必须运行\nsemanage port -a -t ssh_port_t -p tcp 27001   \n#提示没有该命令\nyum whatprovides semanage\n#找到拥有命令的包安装\nyum install -y policycoreutils-python\n#查看端口\nsemanage port -l | grep ssh\n\n#删除端口\nsemanage port -d -t ssh_port_t -p tcp 22\n","slug":"远程服务器安装Docker并配置数据库","date":"2022-03-05T03:02:36.000Z","categories_index":"实战","tags_index":"数据库,Docker","author_index":"LIYUNFU"},{"id":"417b0753cea51755f39f949bc1137c41","title":"Webpack5搭建标准开发环境","content":"Webpack安装&amp;使用安装npm install webpack webpack-cli -D\n\n使用方式方式一.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version\n\n方式二npx webpack --version\n\n\n\n入口(entry)\n\n\n\n\n\n\n\n\n**入口起点(entry point)*指示 webpack 应该使用哪个模块，来作为构建其内部依赖图*的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。\n出口(output)\n\n\n\n\n\n\n\n\noutput 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist\nconst config = &#123;\n    entry: './src/index.js',\n    output: &#123;\n        filename: 'bundle.js',\n        path: path.join(__dirname, './dist')\n    &#125;\n&#125;\n\n\nloader\n\n\n\n\n\n\n\n\nloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。\n让webpack处理CSS文件\n\n\n\n\n\n\n\n\nwebpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这种情况下，以 .css 结尾的全部文件，都将被提供给 style-loader 和 css-loader。\n\n下载依赖loader\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\n编写规则，匹配哪些后缀使用哪些loader  webpack.config.js\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.css$/,\n            use:['style-loader','css-loader']\n        &#125;\n    ]\n&#125;\nloader链式传递，先从后面的loader开始\n\n\n让webpack处理scss文件\n下载依赖loader\nnpm install sass-loader node-sass -D\n编写规则\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.(scss|sass)$/,\n            use:['style-loader','css-loader','sass-loader']\n        &#125;\n    ]\n&#125;,\n\nfile-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。\n让webpack处理图片\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test: /\\.(png|jpg|svg|gif)$/,\n    use:['file-loader']\n&#125;\n可以在index.js中引入\nimport Icon from './icon.jpg';\n\n//将图像添加到我们现有的div\nconst myIcon = new Image();\nmyIcon.src = Icon;\nelement.appendChild(myIcon);\n也可在index.scss中引入\n.hello&#123;\n  color: red;\n  background: url(\"./icon.jpg\");\n&#125;\n\n让webpack处理字体\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test:/\\.(woff|woff2|eot|ttf|otf)$/,\n    use:['file-loader']\n&#125;\n在index.scss中引入\n@font-face &#123;\n  font-family: 'Myfont';\n  src: url(\"./myfont.TTF\") format('ttf');\n  font-weight: 600;\n  font-style: normal;\n&#125;\n.hello&#123;\n  color: red;\n  font-family: Myfont;\n&#125;\n\n让webpack处理CSV、TSV 、XML\n下载依赖loader\nnpm install csv-loader xml-loader -D\n编写规则\n&#123;\n    test:/\\.(csv|tsv)$/,\n    use:['csv-loader']\n&#125;,\n&#123;\n    test:/\\.xml$/,\n    use:['xml-loader']\n&#125;\n在src下创建data.xml并在index.js中引入\n\ndata.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;note>\n    &lt;to>mary&lt;/to>\n    &lt;from>john&lt;/from>\n    &lt;heading>reminder&lt;/heading>\n    &lt;body>call cindy on tuesday&lt;/body>\n&lt;/note>\n\n\nindex.js\n\nimport Data from './data.xml';\n\nconsole.log(Data);\n\n插件(plugins)\n\n\n\n\n\n\n\n\nloader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。\n使用plugins处理html\n下载依赖plugins\nnpm install html-webpack-plugin -D\n由于插件可以携带参数/选项，所以必须在webpack配置中，向plugins属性传入new实例\n\n```js//处理src下的html文件plugins: [\n    new HtmlWebpackPlugin(&#123;template: &quot;./src/index.html&quot;&#125;)\n\n],\n\n## 模式(mode)\n\n&gt; 通过选择 &#96;development&#96; 或 &#96;production&#96; 之中的一个，来设置 &#96;mode&#96; 参数，你可以启用相应模式下的 webpack 内置的优化\n\n&#96;&#96;&#96;jsx\nmodule.exports &#x3D; &#123;\n  mode: &#39;production&#39;\n&#125;;\n\n模块热替换过程在应用程序中置换模块\n应用程序代码要求HMR runtime检查更新\nHMR runtime(异步)下载更新，然后通知应用程序代码\n应用程序代码要求HMR runtime应用更新\nHMR runtime(同步)应用更新\n\n在编译器中除了普通资源，编译器需要发出update，以允许更新之前的版本到新的版本，update由两部分组成：\n\n更新后的manifest(JSON)\n一个或多个更新后的chunk(JavaScript)\n\n配置标准开发环境ni babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;plugin-transform-runtime -D\nni @babel&#x2F;runtime \n\n创建.babelrc&#123;\n  \"presets\": [\n    \"@babel/preset-env\"\n  ],\n  \"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n  ]\n&#125;\n\n在webpack.config.js中rules添加规则&#123;\n    test:/\\.js$/,\n    loader: \"babel-loader\"\n&#125;\n\n\n\n\n\n\n\n\n\n\n第一里程碑\n自动清理dist目录webpack5.x之后在输出中添加clean:true即可\noutput: &#123;\n    filename: &#39;bundle.js&#39;,\n    path: path.join(__dirname, &#39;.&#x2F;dist&#39;),\n    clean: true\n&#125;,\n\n\nCleanWebpackPlugin does not clean in Webpack 5 - fsou (nilmap.com)\n复制资源到dist目录\n引入对应插件\n\nnpm install --save-dev copy-webpack-plugin\n\n\n编写新的plugin语法，旧语法有问题，因为CopyWebpackPlugin构造函数还支持其他选项\n\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nnew CopyWebpackPlugin(\n    &#123;\n        patterns: [\n            &#123;\n                from: path.join(__dirname, 'assets')\n                to: 'assets'\n            &#125;\n        ]\n    &#125;\n)\n\n\n\n\n\n\n\n\n\n\n\n错误信息：[webpack-cli] Invalid options object. Copy Plugin has been initialized using an options object that does not match the API schema.\n对js和css压缩 丑化JS和CSS压缩css和js\n安装依赖\nni css-minimizer-webpack-plugin -D\nni terser-webpack-plugin -D   &#x2F;&#x2F;让他来增强...扩展运算符\nni mini-css-extract-plugin -D  &#x2F;&#x2F;支持头部单独引用不许安装\n引入对应插件 \nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserJSPlugin=require('terser-webpack-plugin')\nrules\n&#123;\n    test: /\\.(scss|sass)$/,\n    use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']\n&#125;,\noptimization\noptimization: &#123;\n    minimize: true,  //设置开发环境可用，若不设置默认false只能支持生产环境\n    minimizer: [\n        `...`,   //使用扩展运算符增强\n        new CssMinimizerPlugin(),\n      \tnew TerserJSPlugin()\n    ]\n&#125;,\nplugins\nnew MiniCssExtractPlugin(&#123;\n    filename: '[name].css',\n    chunkFilename:'[id].css',\n&#125;),\nnew MiniCssExtractPlugin(),\nnew TerserJSPlugin()\n\n","slug":"Webpack5搭建标准开发环境","date":"2022-03-05T03:00:17.000Z","categories_index":"实战","tags_index":"Webpack,前端工程化","author_index":"LIYUNFU"},{"id":"fe45cec90ec11b72673f92c41490ffd7","title":"基于koa-generator实现验证码功能","content":"第一步\n全局安装koa-generator\n\n```shellnpm install -g koa-generator\n\n- 生成基本框架\n\n- &#96;&#96;&#96;shell\n  koa2 apiname    \n  # 使用koa2后面接目录名即可自动创建名为apiname的目录\n根据命令行提示，进入创建的文件夹，执行npm install\n\n```shellcd apinamenpm install\n\n- 下载依赖完成之后，可以启动看看\n\n- &#96;&#96;&#96;shell\n  npm run start\n打开浏览器访问3000端口\n\n```shellhttp://localhost:3000\n\n- 如果浏览器中页面显示出数据即创建成功，可以进入下一步\n\n\n\n### 第二步\n\n- 在根目录下新建&#96;src&#96;目录\n\n- 将&#96;public&#96; 、&#96;routes&#96; 、&#96;views&#96; 、&#96;app.js&#96;拖入&#96;src&#96;目录\n\n- 修改&#96;bin&#x2F;www&#96;中的&#96;var app &#x3D; require(&#39;..&#x2F;app&#39;);&#96;为&#96;var app &#x3D; require(&#39;..&#x2F;src&#x2F;app&#39;);&#96;\n\n- 改造后目录\n\n- &#96;&#96;&#96;shell\n  |- bin\n    |- www\n  |-node_modules\n  |-src\n    |-public\n    |-routes\n    |-views\n    |-app.js\n  |-package.json\n在src目录下创建目录controller\n\n\n第三步\n安装用于聚合router的包\n\n安装koa-combine-routers包\n\n```shellnpm install koa-combine-routers\n\n- 安装&#96;svg-captcha&#96;  包 用于生成&#96;svg&#96;验证码\n\n- &#96;&#96;&#96;shell\n  npm install svg-captcha\n在controller目录下创建publicController.js 用于生成验证码 并输入以下代码\n\n```jsconst svgCaptcha = require(“svg-captcha”);\nfunction  publicController(ctx) {  //创建一个新验证码svg对象  const newCaptcha = svgCaptcha.create({\nsize: 4,  //验证码长度\nignoreChars: &quot;0o1il&quot;, //排除易混淆的几个0o1il字符\ncolor: true,   //验证码有颜色\nnoise: Math.floor(Math.random() * 5), //干扰线\nwidth: 150,  \nheight: 50,\n\n  });  ctx.body = {\nmsg: newCaptcha.data,\n\n  };}\nmodule.exports = publicController;\n\n- 在&#96;routes&#96;目录下新建&#96;publicRouter.js &#96; 输入以下代码\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;koa-router&quot;)();\n  const getCaptcha &#x3D; require(&quot;..&#x2F;controller&#x2F;PublicController&quot;);\n  \n  router.get(&quot;&#x2F;getCaptcha&quot;, getCaptcha);\n  \n  module.exports &#x3D; router;\n在routes目录下新建routes.js 输入以下代码\n\n```jsconst combineRoutes=require(‘koa-combine-routers’)\nconst aRoutes=require(‘./publicRouter’)\nmodule.exports=combineRoutes(  aRoutes   //如果有多个 可以引入多个，并写在此处用逗号隔开)\n\n- 在&#96;app.js&#96;引入&#96;routes.js&#96; 并使用\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;.&#x2F;routes&#x2F;routes&quot;);\n  app.use(router())\n实现跨域请求，下载并引入koa2-cors包\n\n```shellnpm install koa2-cors\nconst cors = require(“koa2-cors”);\n//cors配置app.use(  cors({\norigin: &quot;http://localhost:8080&quot;, //前端origin\ncredentials: true, //允许跨域带cookie\n\n  }));\n\n\n\n### 第四步\n\n使用&#96;vue&#96;项目，尝试请求验证码  下载&#96;axios&#96;包\n\n&#96;&#96;&#96;vue\n&lt;template&gt;\n\t&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div class&#x3D;&quot;svg&quot; @click&#x3D;&quot;getCaptcha&quot; v-html&#x3D;&quot;svg&quot;&gt;验证码&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nconst axios &#x3D; require(&#39;axios&#39;)\nexport default &#123;\n  name: &#39;app&#39;,\n  data () &#123;\n    return &#123;\n      svg: &#39;&#39;\n    &#125;\n  &#125;,\n  mounted () &#123;\n    this.getCaptcha()\n  &#125;,\n  methods: &#123;\n    getCaptcha () &#123;\n      axios.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;getCaptcha&#39;).then((res) &#x3D;&gt; &#123;\n        if (res.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          this.svg &#x3D; res.data.msg\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n","slug":"基于koa-generator实现验证码功能","date":"2022-03-05T02:56:54.000Z","categories_index":"实战","tags_index":"Koa","author_index":"LIYUNFU"},{"id":"2dd921bc2e0b67b467ed4b61518bdc3d","title":"MongoDB的CRUD","content":"MongoDB初见\nDocker中MongoDB数据的备份与恢复#备份\ndocker exec -it 镜像名 mongodump -h 地址 -u root -p example -o 备份到的地址\ndocker exec -it some-mongo mongodump -h localhost -u root -p example -o &#x2F;temp&#x2F;test\n\n\n\n是什么\n存储文档的非关系型数据库\n\n\n\n可以将多个不同的内容添加到一个集合里面，如果想要添加字段，直接添加，不会报错\n\nMongoDB的CRUD创建文档创建一个文档\n自己提供文档主键_id值，容易出现错误，可以省略文档_id字段，让它自动生成，collection为集合\n\ndb.collection.insertOne(\n\t&#123;\n\t_id: &quot;account1&quot;,\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\ndb.collection.insertOne(\n\t&#123;\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\n创建多个文档\nordered参数用来决定mongoDB是否要按顺序来写入这些文档\nordered:false 表示可以打乱文档写入顺序，以便优化写入的操作\nordered:true(默认值)按顺序执行，如果第一条插入数据错误，那么第二天不会执行\n\n\n\ndb.accounts.insertMany(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t,\n\t&#123;\n\t\tordered:false  &#x2F;&#x2F;可选\n\t&#125;\n)\n\n\n创建单个或多个文档\nsave命令运行时调用insert   db.collection.save \n\ndb.accounts.insert(\n\t&#123;\n\tname: &quot;alice1&quot;,\n\tbalance: 100\n\t&#125;,\n)\n\ndb.accounts.insert(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t\n)\n\n\n\ninsertOne 、insertMany 、insert的区别\n正确和错误返回的结果不同\n\ninsertOne和insertMany命令不支持db.collection.explain()名\n\ninsert支持db.collection.explain命令\n\n\n读取文档读取全部文档\n既不筛选，也不投射\ndb.accounts.find()\n更清晰的显示文档\ndb.accounts.find().pretty()\n\n匹配查询\n读取alice的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;&#125;)\n读取alice的余额为100元的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;,balance: 100&#125;)\n读取复合主键的文档\ndb.accounts.find(&#123;&quot;_id.type&quot;: &quot;savings&quot;&#125;)\n\n比较操作符\n\n\n操作符\n含义\n\n\n\n$eq\n相等查询值的文档\n\n\n$ne\n不等查询值的文档\n\n\n$gt\n大于查询值的文档\n\n\n$gte\n大于或等于查询值的文档\n\n\n$lt\n小于查询值的文档\n\n\n$lte\n小于或等于查询值的文档\n\n\n$in\n与任一查询值相等的文档\n\n\n$nin\n与任何查询值都不等的文档\n\n\n\n读取不属于alice的银行账户文档\ndb.accounts.find(&#123;name: &#123;$ne:&quot;alice&quot;&#125;&#125;)\n读取余额大于500的银行账户文档\ndb.accounts.find(&#123;balance: &#123;$gt:500&#125;&#125;)\n读取用户名字排在fred之前的银行账户文档\ndb.accounts.find(&#123;name: &#123;$lt:&quot;fred&quot;&#125;&#125;)\n读取alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$in:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n读取既不是alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$nin:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n\n逻辑操作符\n\n\n逻辑操作符\n含义\n\n\n\n$not\n筛选条件不成立的文档\n\n\n$and\n多个条件全部成立的文档\n\n\n$or\n至少一个筛选条件成立的文档\n\n\n$nor\n多个筛选条件全部不成立的文档\n\n\n\n读取余额不小于500的银行账户文档  \ndb.accounts.find(&#123;balance:&#123;$not:&#123;$lt:500&#125;&#125;&#125;)\n读取余额大于100并且用户姓名排在fred之后的银行账户文档\ndb.accounts.find(&#123;$and:[&#123;balance:&#123;$gt:100&#125;&#125;,&#123;name:&#123;$gt:&quot;fred&quot;&#125;&#125;]&#125;)\n读取余额大于100并且小于500的银行账户文档\ndb.accounts.find(&#123;balance:&#123;$lt:500,$gt:100&#125;&#125;&#125;)\n读取属于alice或者charlie的银行账户文档\ndb.accounts.find(&#123;\n\t$or:[\n\t\t&#123;name:&#123;$eq:&quot;alice&quot;&#125;&#125;,\n\t\t&#123;name:&#123;$eq:&quot;charlie&quot;&#125;&#125;\n\t]\n&#125;)\n读取既不属于alice和charlie且余额不小于100的银行账户文档\ndb.accounts.find(&#123;\n\t$nor:[\n\t\t&#123;name:&quot;alice&quot;&#125;,\n\t\t&#123;name:&quot;charlie&quot;&#125;,\n\t\t&#123;balance:&#123;$lt:100&#125;&#125;\n\t]\n&#125;)\n\n字段操作符\n\n\n操作符\n含义\n\n\n\n$exists\n包含查询字段的文档\n\n\n$type\n字段类型符合查询值的文档\n\n\n\n读取包含账户类型字段的银行账户文档\ndb.accounts.find(&#123;&quot;_id.type&quot;:&#123;$exists:true&#125;&#125;)\n读取文档主键是字符串的银行账户文档\ndb.accounts.find(&#123;_id:&#123;$type:&quot;string&quot;&#125;&#125;)\n\n数组操作符\n\n\n操作符\n含义\n\n\n\n$all\n数组字段中包含所有查询值的文档\n\n\n$elemMatch\n数组字段中至少存在一个值满足筛选条件的文档\n\n\n\n读取联系地址位于中国北京的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$all:[&quot;china&quot;,&quot;beijing&quot;]&#125;&#125;)\n读取联系电话范围在100000和200000之间的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$elemMatch:&#123;$gt:&quot;100000&quot;,$lt:&quot;200000&quot;&#125;&#125;&#125;)\n\n正则操作符\n读取用户姓名以c或者j开头的银行账号文档\ndb.accounts.find(&#123;name:&#123;$in:[&#x2F;^c&#x2F;,&#x2F;^j&#x2F;]&#125;&#125;)\n读取用户姓名包含LIE(不区分大小写)的银行账户文档\ndb.accounts.find(&#123;name:&#123;$regex:&#x2F;LIE&#x2F;,$options:&#39;i&#39;&#125;&#125;)\n\n文档游标\n查询语句默认返回的是文档游标，默认只显示前二十条\n\n游标函数var cursor=db.accounts.find()\n\n\ncursor.hasNext() cursor.next()\n\n```jsvar myCursor=db.accounts.find({name:”alice”})while(myCursor.hasNext()){  printjson(myCursor.next())}  //只要还有就把剩余文档打印出来\n\n- &#96;cursor.forEach()&#96;\n\n- &#96;&#96;&#96;js\n  var myCursor&#x3D;db.accounts.find(&#123;name:&quot;alice&quot;&#125;)\n  myCursor.forEach(printjson)   &#x2F;&#x2F;每篇文档被打印\ncursor.limit()\n\ncursor.skip()\n\n```jsdb.accounts.find({name:”alice”}).limit(1)  //只返回第一篇文档db.accounts.find({name:”alice”}).skip(1)   //跳过第一篇 只显示第二篇和第三篇\n\n- &#96;cursor.count()&#96;\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count()   &#x2F;&#x2F;返回3\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count(true)  &#x2F;&#x2F;返回1\n  &#x2F;&#x2F;默认不接收limit和skip返回的结果\ncursor.sort()\n\n按照余额从大到小，用户名按字母顺序排序\n\n```jsdb.accounts.find().sort({balance:-1,name:1})\n\n\n\n#### 游标注意事件\n\n- &#96;cursor.skip()&#96;在&#96;cursor.limit()&#96;之前执行\n- &#96;cursor.sort()&#96;在&#96;cursor.skip()&#96;和&#96;cursor.limit()&#96;之前执行\n\n\n\n#### 文档投影\n\n- 只返回银行账户文档中的用户姓名\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;&#125;,&#123;name:1&#125;)\n\n\n只返回银行账户文档中的用户姓名(不包含文档主键)\n\ndb.accounts.find(&#123;&#125;,&#123;name:1,_id:0&#125;)\n\n\n除了文档主键之外，我们不可以在投影文档中混合使用包含和不包含这两种投影操作要么在投影文档中列出所有应该包含的字段，要么列出所有不应该包含的字段\n\n\n更新文档","slug":"MongoDB的CRUD","date":"2022-03-05T02:54:11.000Z","categories_index":"实战","tags_index":"MongoDB,数据库,Mongoose","author_index":"LIYUNFU"},{"id":"b9b69e275d0ea3fd4374ffde1f72e980","title":"JSX如何\"摇身一变\"成为DOM的","content":"JSX代码如何变成DOM抛出问题\n  JSX的本质是什么，它和JS之间到底是什么关系？\n\n  为什么要用JSX？不用会有什么后果？\n\n  JSX背后的功能模块是什么，这个功能模块都做了那些事\n\n\n尝试解答\n  JSX的本质是JS的拓展，但是浏览器不能天然支持JSX，所以需要Babel将它编译为React.createElement()的调用，语法糖返回一个叫React Element的JS对象\n\n\n\n  既然最后编译为React.createElement()的调用，为什么不直接使用React.createElement()呢？\n答：\n  由于实现同样的功能的情况下，JSX代码层次分明，语言简练，而React.createElement()代码繁重\n  JSX语法糖允许前端开发者使用我们最为熟悉的类HTML标签语法来创建虚拟DOM，在降低学习成本的同时，也提升了研发效率和研发体验\n\n\n\n\\\n\n  \n\n\\\ncreateElement解析&#x2F;**\n  React的创建元素方法\n *&#x2F;\n\nfunction createElement(type, config, children) &#123;\n  &#x2F;&#x2F; propName用于储存后面需要用到的元素属性\n  var propName;\n  &#x2F;&#x2F; props用于储存元素属性的键值对集合\n  var props &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; key、ref、self、source均为React元素的属性\n  var key &#x3D; null;\n  var ref &#x3D; null;\n  var self &#x3D; null;\n  var source &#x3D; null;\n\n  &#x2F;&#x2F; config 对象中存储的是元素的属性\n  if (config !&#x3D; null) &#123;\n    &#x2F;&#x2F; 进来之后的第一件事，依次对ref、key、self和source属性赋值\n    if (hasValidRef(config)) &#123;\n      ref &#x3D; config.ref;\n\n      &#123;\n        warnIfStringRefCannotBeAutoConverted(config);\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 此处将key 值字符串化\n    if (hasValidKey(config)) &#123;\n      key &#x3D; &#39;&#39; + config.key;\n    &#125;\n\n    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;\n    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source; &#x2F;&#x2F; Remaining properties are added to a new props object\n\n    &#x2F;&#x2F; 接着就是要把config里面的属性都一个一个挪到props对象里面\n    for (propName in config) &#123;\n      if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;\n        props[propName] &#x3D; config[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; childrenLength 指的是当前元素的子元素的个数，减去的2是type和config两个参数占用的长度\n  var childrenLength &#x3D; arguments.length - 2;\n\n  &#x2F;&#x2F; 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;\n    &#x2F;&#x2F; 直接把这个值赋值给props.children\n    props.children &#x3D; children;\n  &#125; else if (childrenLength &gt; 1) &#123;\n    &#x2F;&#x2F; 处理嵌套多个子元素的情况\n    &#x2F;&#x2F; 声明一个数组，把所有剩余对象参数都遍历传入，最后把数组赋值给props.children对象\n    var childArray &#x3D; Array(childrenLength);\n\n    for (var i &#x3D; 0; i &lt; childrenLength; i++) &#123;\n      childArray[i] &#x3D; arguments[i + 2];\n    &#125;\n\n    &#123;\n      if (Object.freeze) &#123;\n        Object.freeze(childArray);\n      &#125;\n    &#125;\n\n    props.children &#x3D; childArray;\n  &#125; &#x2F;&#x2F; Resolve default props\n\n  &#x2F;&#x2F; 处理defaultProps\n  if (type &amp;&amp; type.defaultProps) &#123;\n    var defaultProps &#x3D; type.defaultProps;\n\n    for (propName in defaultProps) &#123;\n      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;\n        props[propName] &#x3D; defaultProps[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#123;\n    if (key || ref) &#123;\n      var displayName &#x3D; typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39; ? type.displayName || type.name || &#39;Unknown&#39; : type;\n\n      if (key) &#123;\n        defineKeyPropWarningGetter(props, displayName);\n      &#125;\n\n      if (ref) &#123;\n        defineRefPropWarningGetter(props, displayName);\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n&#125;\n\n参数说明：\n  type:用于标识节点的类型，它可以是HTML标签字符串，也可以是React组件类型\n\n  config: 以对象形式传入，组件所有的属性都会以键值对的形式存储在config对象中\n\n  children: 以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的”子节点””子元素”\n\n\n例子DOM结构\n&lt;ul className&#x3D;&quot;list&quot; id&#x3D;&quot;lis&quot;&gt;\n  &lt;li key&#x3D;&#123;1&#125;&gt;&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&#123;2&#125;&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact.createElement语法糖\nReact.createElement(&quot;ul&quot;, &#123;\n  &#x2F;&#x2F; 传入属性键值对\n  className: &quot;list&quot;,\n  id: &quot;lis&quot;\n  &#x2F;&#x2F; 从第三个入参开始往后，传入的参数都是children\n&#125;, React.createElement(&quot;li&quot;, &#123;\n  key: 1\n&#125;), React, createElement(&quot;li&quot;, &#123;\n  key: 2\n&#125;))\n\n流程\n 处理key、ref、self、source四个属性值\n\n 遍历config，筛选出可以提进props里的属性\n\n 提取子元素，推入props.children\n\n 格式化defaultProps\n\n 将以上数据作为入参，发起ReactElement调用\n\n\n总结createElement就像是开发者和ReactElement调用之间的一个“转换器”，在开发者出接收相对简单的参数，然年后将这些参数按照ReactElement的预期做一层格式化，最终通过调用ReactElement来实现元素的创建\nReactElement解析var ReactElement &#x3D; function (type, key, ref, self, source, owner, props) &#123;\n  var element &#x3D; &#123;\n    &#x2F;&#x2F; 用来标识该对象是一个ReactElement\n    $$typeof: REACT_ELEMENT_TYPE,\n    &#x2F;&#x2F; 内置属性赋值\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    &#x2F;&#x2F; 记录创建该元素的组件\n    _owner: owner\n  &#125;;\n\n  return element;\n&#125;;\n\nReactElement只做了一件事情，就是组装，把传入的参数按照一定的规范，组装进element对象里，并把它返回给React.createElement，最终React.createElement又把它交回到开发者手中\n\nrender初识function render(element, container, callback) &#123;\n  if (!isValidContainer(container)) &#123;\n    &#123;\n      throw Error( &quot;Target container is not a DOM element.&quot; );\n    &#125;\n  &#125;\n\n  &#123;\n    var isModernRoot &#x3D; isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer &#x3D;&#x3D;&#x3D; undefined;\n\n    if (isModernRoot) &#123;\n      error(&#39;You are calling ReactDOM.render() on a container that was previously &#39; + &#39;passed to ReactDOM.createRoot(). This is not supported. &#39; + &#39;Did you mean to call root.render(element)?&#39;);\n    &#125;\n  &#125;\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n&#125;\n\n参数说明\n  element:需要渲染的元素(ReactElement)\n\n  container:元素挂载的目标容器(一个真实DOM)\n\n  callback: 回调函数，可选参数，可以用来处理渲染结束后的逻辑\n\n\n总结\n","slug":"JSX如何变成DOM","date":"2022-02-27T09:46:50.000Z","categories_index":"React源码","tags_index":"React,源码","author_index":"LIYUNFU"},{"id":"bdee22d1805781f30b666804c7635df8","title":"flex布局","content":"flex容器属性改变主轴方向flex-directionflex-direction: row默认\nflex-direction: row-reverse\nflex-direction: column\nflex-direction: column-reverse\n换行flex-wrapflex-wrap: nowrap默认\nflex-wrap: wrap\nflex-wrap: wrap-reverse\n缩写flex-flow: [flex-direction] [flex-wrap]flex-flow: column wrap\n主轴对齐justify-contentjustify-content: flex-start默认\njustify-content: flex-end\njustify-content: space-around 平均分配  每个方块的margin-left+margin-right+width相等\njustify-content: space-between 两边没有空隙 中间空隙平均分配\njustify-content: space-evenly所有空隙平均分配\n交叉轴整体对齐align-content 必须要有折行属性才能生效  \nalign-content: stretch默认\n如果交叉轴上的宽度未设置则自动拉伸填满交叉轴\n\n\n\n若交叉轴上的宽度已经设置则效果和flex-start一样\n\n\n\n\nalign-content: flex-start\nalign-content: flex-end\nalign-content: center\n其他属性 space-around``space-between``space-evenly和主轴属性类似交叉轴每一行对齐 align-itemsalign-items: stretch默认align-items: flex-start\nalign-items: flex-end\nalign-items: center\nalign-items: baseline 内容以小写x为基线对齐\n内联与块的上下左右居中布局内联上下左右居中\n块级上下左右居中\n不定项居中布局\n均分列布局\n子项分组布局复杂模式 使用div嵌套\n简单方式 margin-right: auto\nflex子项属性扩展比例flex-grow一个子元素时\n默认值为0\n\n比例值大于等于1，沾满剩余所有空间\n\n比例值为0.5，占剩余空间的一半\n\n\n\n\n多个子元素时\n只有一个有flex-grow时\n\n\n\n两个都有flex-grow时\n\n\n\n当多个元素加起来小于1时，还有剩余空间\n\n\n收缩比例flex-shrink\n默认值为1，溢出部分完全收缩，小数按比例收缩\n\n\n默认情况当有两个及以上需要收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，默认情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-2/5*(200+300-400)=160\n\nbox2收缩后所占尺寸：300-3/5*(200+300-400)=240\n\n\n\n不同比例收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，比例情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-4/7*(200+300-400)=142\n\nbox2收缩后所占尺寸：300-3/7*(200+300-400)=257\n\n\n\n指定flex元素在主轴上的初始大小flex-basis\n当主轴方向是水平时，覆盖水平宽度\n\n当主轴方向是垂直时，覆盖垂直高度\n\n可选值：0% auto 200px 100%  0  \n\n\n\nflex-basis: auto默认值\nflex-basis: 0表示占据最小宽度，会竖起来\nflex缩写flex: 1\nflex: 0\nflex: auto\n改变某个子项的排序位置order\norder: 0当前位置保持不变\n\norder: -1向前排\n\norder: 1向后拍\n\n\n\n控制单独某一个元素交叉轴的布局align-self\n等高布局 内容填充两边也等高\n两列或三列布局  两边固定宽度 中间自适应\nSticky Footer布局 内容空页脚在最底部 内容满也在最底部\n溢出项布局\n\n","slug":"flex布局","date":"2022-02-12T13:46:33.000Z","categories_index":"","tags_index":"CSS,布局","author_index":"LIYUNFU"},{"id":"6436dbae418d43dcb9001fac6bd76e96","title":"布局中的尺寸与位置","content":"相对长度单位&emsp;&emsp;相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应。以下列出了常见相对单位。\n\n\n\n单位\n名称\n\n\n\nem\n在font-size中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小\n\n\nex\n字符“x”的高度\n\n\nch\n数字“0”的宽度\n\n\nrem\n根元素的字体大小\n\n\nlh\n元素的line-height\n\n\nvw\n视窗宽度的1%\n\n\nvh\n视窗高度的1%\n\n\nvmin\n视窗较小尺寸的1%\n\n\nvmax\n视图大尺寸的1%\n\n\nmargin-top传递的现象与解决方案现象：为子元素设置margin-top后，会把父元素一块带下来&lt;div class=\"box1\">\n  &lt;div class=\"box2\">&lt;/div>\n&lt;/div>\n\n.box1&#123;\n  width: 200px;\n  height: 200px;\n  background: pink;\n&#125;\n.box2&#123;\n  width: 100px;\n  height: 100px;\n  background: skyblue;\n  margin-top: 30px;\n&#125;\n\n\n解决方案1： 为父元素加边框\n解决方案2：格式化上下文BFC\n解决方案3：使用padding替代margin\n自适应盒模型的特性当子盒子不写宽度的时候，添加padding，margin，border等，向内缩\n\n标准盒模型和怪异盒模型\n标准盒模型content-box：width，height=content\n怪异盒模型border-box：width，height=content+padding+border\n\n常见清除浮动的方案clear属性 清除上下\nBFC 清除父组件塌陷\n空标签.clearfix::after{}.clearfix::after&#123;\n\tcontent:\"\";\n  clear:both;\n  display:block;\n&#125;\n\n浮动特性注意点\n只会影响后面的元素\n\n文本不会被浮动元素覆盖\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n浮动放不下，会自动换行\n\n\n定位相对定位position：ralative\n相对定位的元素是在文档中的正常位置偏移给定的值\n\n不影响其他元素布局\n\n相对于自身进行偏移\n\n\n绝对定位position：absolute\n脱离标准文档流，不占据空间\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n绝对定位元素相对于最近的非static祖先元素定位，当这样的祖先元素不存在时，则相对于可视区定位\n\n\n固定定位position：fixed粘性定位position：sticky\n粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位\n\n详解display属性display-outside外部值定义自身元素的外部表现，而不影响其内的子元素\n\nblock：表示块级盒子\ninline：表示内联盒子\n\ndisplay-inside内部值定义子元素布局的\n\ntable：带有内部表格布局的块级盒子\n\nflex：带有内部弹性布局的块级盒子\n\ngrid：带有内部网格布局的块级盒子\n\n\nglobal全局值\ninherit：继承父元素的display属性\n\ninitial：不管父元素怎么设定，恢复到浏览器最初时的display属性\n\nunset：unset混合了inherit和initial，如果父元素设值了，就用父元素的设定，如果父元素没有设值，就用浏览器的缺省设定\n\n\n书写模式与逻辑属性writing-mode书写模式\nhorizontal-tb：水平方向自上而下的书写方式\n\nvertical-lr：垂直方向自左而右的书写方式\n\nvertical-rl：垂直方向自右而左的书写方式\n\n\n\nBFC块级格式化上下文概念：\n可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何，都不会影响到外部\n\n触发条件：\nfloat的值不是none\n\nposition的值不是static或relative\n\ndisplay的值是inline-block、table-cel、flex、table-caption或inline-flex\n\noverflow的值不是visible\n\n\nBFC的应用：\n解决margin-top传递问题   在父元素上加\n\n解决纵向margin重叠问题\n\n\n\n\n\n解决浮动高度塌陷  在父元素上加\n\n\n","slug":"布局中的尺寸与位置","date":"2022-02-11T13:28:00.000Z","categories_index":"","tags_index":"布局,css","author_index":"LIYUNFU"},{"id":"72f191bcb7ec59bd5f1454660b2b3dff","title":"西瓜音乐小程序开发第二天","content":"✅ 引入第三方 UI 库 vant✅ 封装 banner 请求✅ 实时获取组件高度解决不同屏幕中的 swiper 样式问题✅ 使用节流函数优化性能\n\n今日完成效果\n\n\n\\\n引入 vantUI 库步骤如下\n 第一步进入微信开发工具，点开详情，勾选使用 npm 模块，并调低基础库，由于当前测试基础库2.22.0无法正常显示 vant 中的van-search标签，遂调低基础库至2.21.2\n\n\n\n 打开终端，初始化package.json并且安装 vant 依赖 npm i @vant/weapp\n\n\n\n\\\n\n 点击工具菜单中的构建 npm，等待构建完成，自动产生miniprogram_npm这就是小程序依赖的包\n\n\n\n\n 最后删除 app.json 中的style:v2防止样式冲突\n\n使用第三方 UI 库\n 在pages/home-music/index.json中导入需要的search组件\n\n&#123;\n  &quot;usingComponents&quot;: &#123;\n    &quot;van-search&quot;: &quot;@vant&#x2F;weapp&#x2F;search&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 在pages/home-music/index.wxml中使用search组件\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n\n这里使搜索框无法输入，绑定了点击方法，使用户点击搜索框跳转到搜索页面，index.js 中实现方法即可，shape属性可以设置为圆角或者方角\n\n&#x2F;**\n  * 事件处理\n  *&#x2F;\n handleSearchClick: function () &#123;\n   wx.navigateTo(&#123;\n     url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n   &#125;);\n &#125;,\n\n\n效果如图\n\n\n\\\n封装 banner 请求新建 service/api_music.jsimport hyRequest from &quot;.&#x2F;index&quot;;\nexport function getBanners() &#123;\n  return hyRequest.get(&quot;&#x2F;banner&quot;, &#123;\n    type: 2,\n  &#125;);\n&#125;\n\n\ntype 的值有四种：0 代表 PC 1 代表 Android 2 代表 Iphone 3 代表 pad\n\n\\\n请求数据并渲染到页面\n 根据官方文档可知，可以通过以下示例获得每次渲染完成的组件的rect\n\n\n\n 新建utils/query-rect.js用以获取组件高度\n\nexport default function (selector) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 获取图片的高度(如何获取组件高度)\n    const query &#x3D; wx.createSelectorQuery();\n    query.select(selector).boundingClientRect();\n    query.exec((res) &#x3D;&gt; &#123;\n      resolve(res);\n    &#125;);\n  &#125;);\n&#125;\n\n\n 在pages/home-music/index.js中定义数据和方法，并调用\n\n&#x2F;&#x2F; pages&#x2F;home-music&#x2F;index.js\nimport &#123; getBanners &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_music&quot;;\nimport queryRect from &quot;..&#x2F;..&#x2F;utils&#x2F;query-rect&quot;;\nimport throttle from &quot;..&#x2F;..&#x2F;utils&#x2F;throttle&quot;;\n\nconst throttleQueryRect &#x3D; throttle(queryRect);\n\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    swiperHeight: 0,\n    banners: &#123;&#125;,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getPageData();\n  &#125;,\n\n  &#x2F;**\n   * 事件处理\n   *&#x2F;\n  handleSearchClick: function () &#123;\n    wx.navigateTo(&#123;\n      url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 网络请求\n   *&#x2F;\n  getPageData: function () &#123;\n    getBanners().then((res) &#x3D;&gt; &#123;\n      this.setData(&#123; banners: res.banners &#125;);\n    &#125;);\n  &#125;,\n\n  handleSwiperImageLoaded: function () &#123;\n    &#x2F;&#x2F; 获取图片的高度\n    throttleQueryRect(&quot;#swiper-img&quot;).then((res) &#x3D;&gt; &#123;\n      const rect &#x3D; res[0];\n      this.setData(&#123;\n        swiperHeight: rect.height,\n      &#125;);\n    &#125;);\n  &#125;,\n&#125;)\n\n\n 在pages/home-music/index.wxml中调用数据，并绑定image加载完成的方法bindonload\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n&lt;!-- 轮播图 --&gt;\n&lt;swiper class&#x3D;&quot;swiper&quot; style&#x3D;&quot;height:&#123;&#123;swiperHeight&#125;&#125;&quot; indicator-dots autoplay circular&gt;\n  &lt;block wx:for&#x3D;&quot;&#123;&#123;banners&#125;&#125;&quot; wx:key&#x3D;&quot;bannerId&quot;&gt;\n    &lt;swiper-item class&#x3D;&quot;swiper-item&quot; &gt;\n      &lt;image id&#x3D;&quot;swiper-img&quot; class&#x3D;&quot;image&quot; mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#123;&#123;item.pic&#125;&#125;&quot;  bindload&#x3D;&quot;handleSwiperImageLoaded&quot; &#x2F;&gt;\n    &lt;&#x2F;swiper-item&gt;\n  &lt;&#x2F;block&gt;\n&lt;&#x2F;swiper&gt;\n\n参数说明:\n\ncircular无限滑动\nmode高度自适应\n\n\n\n\nbindload当image标签加载完成时执行\nindicator-dots显示小圆点\n\n上面用到的节流函数utils/throttle.js\nexport default function throttle(\n  fn,\n  interval &#x3D; 1000,\n  options &#x3D; &#123; leading: true, trailing: false &#125;\n) &#123;\n  &#x2F;&#x2F; 1.记录上一次的开始时间\n  const &#123; leading, trailing, resultCallback &#125; &#x3D; options;\n  let lastTime &#x3D; 0;\n  let timer &#x3D; null;\n\n  &#x2F;&#x2F; 2.事件触发时, 真正执行的函数\n  const _throttle &#x3D; function (...args) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 2.1.获取当前事件触发时的时间\n      const nowTime &#x3D; new Date().getTime();\n      if (!lastTime &amp;&amp; !leading) lastTime &#x3D; nowTime;\n\n      &#x2F;&#x2F; 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数\n      const remainTime &#x3D; interval - (nowTime - lastTime);\n      if (remainTime &lt;&#x3D; 0) &#123;\n        if (timer) &#123;\n          clearTimeout(timer);\n          timer &#x3D; null;\n        &#125;\n\n        &#x2F;&#x2F; 2.3.真正触发函数\n        const result &#x3D; fn.apply(this, args);\n        if (resultCallback) resultCallback(result);\n        resolve(result);\n        &#x2F;&#x2F; 2.4.保留上次触发的时间\n        lastTime &#x3D; nowTime;\n        return;\n      &#125;\n\n      if (trailing &amp;&amp; !timer) &#123;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n          timer &#x3D; null;\n          lastTime &#x3D; !leading ? 0 : new Date().getTime();\n          const result &#x3D; fn.apply(this, args);\n          if (resultCallback) resultCallback(result);\n          resolve(result);\n        &#125;, remainTime);\n      &#125;\n    &#125;);\n  &#125;;\n\n  _throttle.cancel &#x3D; function () &#123;\n    if (timer) clearTimeout(timer);\n    timer &#x3D; null;\n    lastTime &#x3D; 0;\n  &#125;;\n\n  return _throttle;\n&#125;\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第二天","date":"2022-02-10T07:54:45.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"},{"id":"27fc989783c0d00e7c3b706a3747978d","title":"西瓜音乐小程序开发第一天","content":"\n✅ 初始化项目\n✅ 配置 tabbar\n✅ 封装请求函数\n✅ 分层架构二次封装请求函数\n✅ 封装格式化方法 (utils/format.wxs)\n✅ 封装视频列表 item 组件\n✅ 完成视频列表页展示\n今日完成效果如下\n\n\n\\\n初始化项目\n\n\\\n删除无关项目文件\n删除 pages 目录下的 index 和 logs，删除 utils 目录下的 util.js\n初始化 app.js 为\n\n&#x2F;&#x2F; app.js\nApp(&#123;\n\n&#125;)\n\n\n初始化 app.json 为\n\n&#123;\n  &quot;pages&quot;: [\n\n  ],\n  &quot;window&quot;: &#123;\n    &quot;backgroundTextStyle&quot;: &quot;light&quot;,\n    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,\n    &quot;navigationBarTitleText&quot;: &quot;Weixin&quot;,\n    &quot;navigationBarTextStyle&quot;: &quot;black&quot;\n  &#125;,\n  &quot;style&quot;: &quot;v2&quot;,\n  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,\n  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;\n&#125;\n\n\n初始化 app.wxss 为\n\n&#x2F;**app.wxss**&#x2F;\n\n\n目前为止编译器/模拟器会报错\n\n\n\\\n配置 tabbar新建两个页面\n 在 pages 右键创建文件夹home-music和home-video\n 在home-video和home-music上右键新建page为index\n\n\n\n\n 小程序开发工具会自动在目录下创建四个文件，并自动在app.json中添加 url\n \n\n\n\n\n \n\n导入静态资源 assets\n 在文件管理器中打开项目，复制已经准备好的 assets 资源到根目录\n \n\n\\\n在app.json中配置 tabbar&quot;tabBar&quot;: &#123;\n    &quot;list&quot;: [\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-music&#x2F;index&quot;,\n        &quot;text&quot;: &quot;音乐&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_active.png&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-video&#x2F;index&quot;,\n        &quot;text&quot;: &quot;视频&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_active.png&quot;\n      &#125;\n    ]\n  &#125;,\n\n\n\n效果\n\n\n\\\n封装请求函数由于微信小程序给我们提供的wx.request请求许多参数都可以复用，所以可以封装一个请求函数\n\n 在根目录下新建service文件夹\n 新建service/index.js\n\nconst BASE_URL &#x3D; &quot;http:&#x2F;&#x2F;123.207.32.32:9001&quot;;\nclass HYRequest &#123;\n  request(url, method, params) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      wx.request(&#123;\n        url: BASE_URL + url,\n        method: method,\n        data: params,\n        success: function (res) &#123;\n          resolve(res.data);\n        &#125;,\n        fail: function (err) &#123;\n          reject(err);\n        &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  get(url, params) &#123;\n    return this.request(url, &quot;GET&quot;, params);\n  &#125;\n  post(url, data) &#123;\n    return this.request(url, &quot;POST&quot;, data);\n  &#125;\n&#125;\n\nconst hyRequest &#x3D; new HYRequest();\nexport default hyRequest;\n\n二次封装请求函数某些动作需要反复调用请求函数，但是有不变的参数，没必要每次传递，可以再封装一次\n\n 新建service/api_video.js\n\nimport hyRequest from &#39;.&#x2F;index&#39;\nexport function getTopMV(offset,limit&#x3D;10)&#123;\n  return hyRequest.get(&#39;&#x2F;top&#x2F;mv&#39;,&#123;\n    offset,\n    limit\n  &#125;)\n&#125;\n\n\n 由于我们的 api 后台需要接收两个参数，一个是偏移量，一个是数量，我们默认每次截取十个即可\n\n调用请求获得数据\n 在home-video/index.js中引入 getTopMV 方法\n\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\n\n\n 在home-video/index.js的 data 中定义两个变量\n\ndata: &#123;\n   topMVs: [],   &#x2F;&#x2F;用以保存请求到的数据列表\n   hasMore: true,  &#x2F;&#x2F; 判断还有没有更多数据能够请求\n &#125;,\n\n\n 封装专属于home-video的网络请求方法，用以在不同操作下复用\n\n&#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n\n 当生命周期 onLoad 执行时，调用请求方法\n\n&#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n\n 当下拉刷新时调用请求方法\n\n&#x2F;**\n  * 下拉刷新\n  *&#x2F;\n onPullDownRefresh: function () &#123;\n   this.getTopMVData(0);\n &#125;,\n\n\n 当页面触底时调用请求方法\n\n&#x2F;**\n * 页面上拉触底事件的处理函数\n *&#x2F;\nonReachBottom: function () &#123;\n  this.getTopMVData(this.data.topMVs.length);\n&#125;,\n\n\n home-video/index.js完整代码\n\n&#x2F;&#x2F; pages&#x2F;home-video&#x2F;index.js\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    topMVs: [],\n    hasMore: true,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n  &#x2F;**\n   * 封装事件处理的方法\n   *&#x2F;\n  handleVideoItemClick: function (event) &#123;\n    const id &#x3D; event.currentTarget.dataset.item.id;\n\n    &#x2F;&#x2F; 页面跳转\n    wx.navigateTo(&#123;\n      url: &#96;&#x2F;pages&#x2F;detail-video&#x2F;index?id&#x3D;$&#123;id&#125;&#96;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 下拉刷新\n   *&#x2F;\n  onPullDownRefresh: function () &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面初次渲染完成\n   *&#x2F;\n  onReady: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面显示\n   *&#x2F;\n  onShow: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面隐藏\n   *&#x2F;\n  onHide: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面卸载\n   *&#x2F;\n  onUnload: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面相关事件处理函数--监听用户下拉动作\n   *&#x2F;\n  onPullDownRefresh: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面上拉触底事件的处理函数\n   *&#x2F;\n  onReachBottom: function () &#123;\n    this.getTopMVData(this.data.topMVs.length);\n  &#125;,\n\n  &#x2F;**\n   * 用户点击右上角分享\n   *&#x2F;\n  onShareAppMessage: function () &#123;&#125;,\n&#125;);\n\n遍历数据到页面前面我们已经请求到数据了，可以直接在home-video/index.wxml中调用，由于列表的 item 也可以复用，我们将它封装成一个 component\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;!-- &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt; --&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\\\n封装 item 组件\n 在根目录下新建文件夹components/video-item-v1，右键video-item-v1新建component为 index\n \n\n\n\n\n 可以看到component的 index.js 和普通组件不同，其中有一个专门接收父组件传递过来数据的函数\n\n&#x2F;**\n  * 组件的属性列表\n  *&#x2F;\n properties: &#123;\n\n &#125;,\n\n\n 可以在这儿定义接收的数据，就可以直接在 wxml 页面中使用了\n\n&#x2F;**\n   * 组件的属性列表\n   *&#x2F;\n  properties: &#123;\n    item:&#123;\n      type:Object,\n      default:&#123;&#125;\n    &#125;\n  &#125;,\n\n\n 由于服务器返回的数据里面播放量和 时间都需要转换格式，我们可以在 utils 目录下定义一个format.wxs用于格式化数据，wxml 中只能调用 wxs 定义的方法\n\nfunction formatCount(count) &#123;\n  var counter &#x3D; parseInt(count);\n  if (counter &gt; 100000000) &#123;\n    return (counter &#x2F; 100000000).toFixed(1) + &quot;亿&quot;;\n  &#125; else if (counter &gt; 10000) &#123;\n    return (counter &#x2F; 10000).toFixed(1) + &quot;万&quot;;\n  &#125; else &#123;\n    return counter + &quot;&quot;;\n  &#125;\n&#125;\n\nfunction padLeftZero(time) &#123;\n  time &#x3D; time + &quot;&quot;;\n  return (&quot;00&quot; + time).slice(time.length);\n&#125;\nfunction formatDuration(duration) &#123;\n  duration &#x3D; duration &#x2F; 1000;\n\n  var minute &#x3D; Math.floor(duration &#x2F; 60);\n  &#x2F;&#x2F; 计算秒钟\n  var second &#x3D; duration % 60;\n\n  return padLeftZero(minute) + &quot;:&quot; + padLeftZero(second);\n&#125;\n&#x2F;&#x2F; commonjs\nmodule.exports &#x3D; &#123;\n  formatCount: formatCount,\n  formatDuration: formatDuration,\n&#125;;\n\n\n 现在我们可以在 wxml 中使用父组件传递过来的数据了\n\n&lt;!--components&#x2F;video-item-v1&#x2F;index.wxml--&gt;\n&lt;wxs src&#x3D;&quot;..&#x2F;..&#x2F;utils&#x2F;format.wxs&quot; module&#x3D;&quot;format&quot;&gt;&lt;&#x2F;wxs&gt;\n&lt;view class&#x3D;&quot;item&quot;&gt;\n  &lt;view class&#x3D;&quot;album&quot;&gt;\n    &lt;image class&#x3D;&quot;images&quot; src&#x3D;&quot;&#123;&#123;item.cover&#125;&#125;&quot; mode&#x3D;&quot;widthFix&quot; &#x2F;&gt;\n    &lt;view class&#x3D;&quot;info&quot;&gt;\n      &lt;view class&#x3D;&quot;count&quot;&gt;&#123;&#123;format.formatCount(item.playCount)&#125;&#125;&lt;&#x2F;view&gt;\n      &lt;view class&#x3D;&quot;duration&quot;&gt;&#123;&#123;format.formatDuration(item.mv.videos[0].duration)&#125;&#125;&lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class&#x3D;&quot;content&quot;&gt;\n    &#123;&#123;item.name&#125;&#125; - &#123;&#123;item.artisName&#125;&#125;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\n 为 item 组件配置样式\n\n&#x2F;* components&#x2F;video-item-v1&#x2F;index.wxss *&#x2F;\n.item &#123;\n  width: 100%;\n  margin-bottom: 30rpx;\n&#125;\n\n.album &#123;\n  position: relative;\n  border-radius: 12rpx;\n  overflow: hidden;\n  display: flex;\n&#125;\n\n.album .image &#123;\n  width: 100%;\n&#125;\n\n.info &#123;\n  position: absolute;\n  padding: 0 10rpx;\n  box-sizing: border-box;\n  width: 100%;\n  bottom: 8rpx;\n  display: flex;\n  justify-content: space-between;\n  color: #fff;\n  font-size: 24rpx;\n&#125;\n\n.info .count &#123;\n  padding-left: 36rpx;\n  position: relative;\n&#125;\n\n.info .count::before &#123;\n  content: &quot;&quot;;\n  position: absolute;\n  left: -2rpx;\n  top: 4rpx;\n  width: 30rpx;\n  height: 24rpx;\n  background-size: cover;\n  background-image: url(&quot;data:image&#x2F;jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAYCAQAAABHYIU0AAAM82lDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY0dyYXlHYW1tYTJfMgAAWIWlVwdYU8kWnluS0BJ6lRI60gwoXUqkBpBeBFGJIZBACDEFAbEhiyu4dhHBsqKiKIsdgcWGBQtrB7sLuigo6+IqNixvEopYdt&#x2F;7vnfzzb3&#x2F;nXPOnDpnbgBQ5TAFAh4KAMjki4WBUfSEKQmJVNJdIAe0gTKwB8pMlkhAj4gIhSyAn8Vng2+uV+0AkT6v2UnX+pb+rxchhS1iwedxOHJTRKxMAJCJAJC6WQKhGAB5MzhvOlsskOIgiDUyYqJ8IU4CQE5pSFZ6GQWy+Wwhl0UNFDJzqYHMzEwm1dHekRohzErl8r5j9f97ZfIkI7rhUBJlRIfApz20vzCF6SfFrhDvZzH9o4fwk2xuXBjEPgCgJgLxpCiIgyGeKcmIpUNsC3FNqjAgFmIviG9yJEFSPAEATCuPExMPsSHEwfyZYeEQu0PMYYl8EyG2griSw2ZI8wRjhp3nihkxEEN92DNhVpSU3xoAfGIK289&#x2F;cB5PzcgKkdpgAvFBUXa0&#x2F;7DNeRzfsEFdeHs6MzgCYguIX7J5gVGD6xD0BOII6ZrwneDH54WFDvpFKGWLZP7Cd0K7mBMjzZkjAEQTsTAmatA2YkwqN4ABcQDEORxhUNSgv8SjAp6szmBMiO+FkqjYQR9JAWx+rHRNaV0sYAr9AwdjRWoCcQgTsEEWmAnvLMAHnYAKRIALsmUoDTBBJhxUaIEtHIGQiw+HEHKIQIaMQwi6RujDElIZAaRkgVTIyYNyw7NUkALlB+Wka2TBIX2Trtstm2MN6bOHw9dwO5DANw7ohXQORJNBh2wmB9qXCZ++cFYCaWkQj9YyKB8hs3XQBuqQ9T1DWrJktjBH5D7b5gvpfJAHZ0TDnuHaOA0fD4cHHop74jSZlBBy5AI72fxE2dyw1s+eS33rGdE6C9o62vvR8RqO4QkoJYbvPOghfyg+ImjNeyiTMST9lZ8r9CRWAkHpskjG9KoRK6gFwhlc1qXlff+StW+1232Rt&#x2F;DRdSGrlJRv6gLqIlwlXCbcJ1wHVPj8g9BG6IboDuEu&#x2F;N36blSyRmKQBkfWSAWwv8gNG3LyZFq+tfNzzgbX+WoFBBvhpMtWkVIz4eDKeEQj+ZNALIb3VJm03Ve5C&#x2F;xab0t+kw6gti89fg5Qa1Qazn6Odhten3RNqSU&#x2F;lb9CTyCYXpU&#x2F;wBZ8pkrzwF4c9ioMFNjS9tJ6adtoNbQXtPufOWg3aH&#x2F;S2mhbIOUptho7hB3BGrBGrBVQ4VsjdgJrkKEarAn+9v1Dhad9p8KlFcMaqmgpVTxUU6Nrf3Rk6aOiJeUfjnD6P9Tr6IqRZux&#x2F;s2j0Ol92BPbnXUcxpThQSBRrihOFTkEoxvDnSPGByJRiQgmlaENqEMWS4kcZMxKP4VrnDWWY+8X+HrQ4AVKHK4Ev6y5MyCnlYA75+7WP1C+8lHrGHb2rEDLcVdxRPeF7vYj6xc6KhbJcMFsmL5Ltdr5MTvBF&#x2F;YlkXQjOIFNlOfyObbgh7oAzYAcKB1ScjjvhPkN4sCsN9yVZpnBvSPXC&#x2F;XBXaR&#x2F;7oi+w&#x2F;qv1o3cGm+hOtCT6Ey0&#x2F;04l+xCBiAHw6SOeJ44jBELtJucTsHLH0kPfNEuQKuWkcMZUOv3LYVAafZW9LdaQ5wNNN+s00+CnwIlL2LYRotbIkwuzBOVx6IwAF+D2lAXThqWoKT2s7qNUFeMAz0x+ed+EgBuZ1OvSDA+0Wwsjmg4WgCJSAFWAtKAebwTZQDWrBfnAYNMEeewZcAJdBG7gDz5Mu8BT0gVdgAEEQEkJG1BFdxAgxR2wQR8QV8UL8kVAkCklAkpE0hI9IkHxkEVKCrELKkS1INbIPaUBOIOeQK8gtpBPpQf5G3qEYqoRqoAaoBToOdUXpaAgag05D09BZaB5aiC5Dy9BKtAatQ0+gF9A2tAN9ivZjAFPEtDBjzA5zxXyxcCwRS8WE2DysGCvFKrFa2ANasGtYB9aLvcWJuDpOxe1gFoPwWJyFz8Ln4UvxcnwnXoefwq&#x2F;hnXgf&#x2F;pFAJugTbAjuBAZhCiGNMJtQRCglVBEOEU7DDt1FeEUkErVgflxg3hKI6cQ5xKXEjcQ9xOPEK8SHxH4SiaRLsiF5ksJJTJKYVERaT6ohHSNdJXWR3sgpyhnJOcoFyCXK8eUK5Erldskdlbsq91huQF5F3lzeXT5cPkU+V365&#x2F;Db5RvlL8l3yAwqqCpYKngoxCukKCxXKFGoVTivcVXihqKhoouimGKnIVVygWKa4V&#x2F;GsYqfiWyU1JWslX6UkJYnSMqUdSseVbim9IJPJFmQfciJZTF5GriafJN8nv6GoU+wpDEoKZT6lglJHuUp5piyvbK5MV56unKdcqnxA+ZJyr4q8ioWKrwpTZZ5KhUqDyg2VflV1VQfVcNVM1aWqu1TPqXarkdQs1PzVUtQK1baqnVR7qI6pm6r7qrPUF6lvUz+t3qVB1LDUYGika5Ro&#x2F;KJxUaNPU01zgmacZo5mheYRzQ4tTMtCi6HF01qutV+rXeudtoE2XZutvUS7Vvuq9mudMTo+OmydYp09Om0673Spuv66GbordQ&#x2F;r3tPD9az1IvVm623SO63XO0ZjjMcY1pjiMfvH3NZH9a31o&#x2F;Tn6G&#x2F;Vb9XvNzA0CDQQGKw3OGnQa6hl6GOYbrjG8Khhj5G6kZcR12iN0TGjJ1RNKp3Ko5ZRT1H7jPWNg4wlxluMLxoPmFiaxJoUmOwxuWeqYOpqmmq6xrTZtM&#x2F;MyGyyWb7ZbrPb5vLmruYc83XmLeavLSwt4i0WWxy26LbUsWRY5lnutrxrRbbytpplVWl1fSxxrOvYjLEbx162Rq2drDnWFdaXbFAbZxuuzUabK7YEWzdbvm2l7Q07JTu6XbbdbrtOey37UPsC+8P2z8aZjUsct3Jcy7iPNCcaD55udxzUHIIdChwaHf52tHZkOVY4Xh9PHh8wfv74+vHPJ9hMYE&#x2F;YNOGmk7rTZKfFTs1OH5xdnIXOtc49LmYuyS4bXG64arhGuC51PetGcJvkNt+tye2tu7O72H2&#x2F;+18edh4ZHrs8uidaTmRP3DbxoaeJJ9Nzi2eHF9Ur2etnrw5vY2+md6X3Ax9TnxSfKp&#x2F;H9LH0dHoN&#x2F;dkk2iThpEOTXvu6+871Pe6H+QX6Fftd9Ffzj&#x2F;Uv978fYBKQFrA7oC&#x2F;QKXBO4PEgQlBI0MqgGwwDBotRzegLdgmeG3wqRCkkOqQ85EGodagwtHEyOjl48urJd8PMw&#x2F;hhh8NBOCN8dfi9CMuIWRG&#x2F;RhIjIyIrIh9FOUTlR7VEq0fPiN4V&#x2F;SpmUszymDuxVrGS2OY45bikuOq41&#x2F;F+8aviO6aMmzJ3yoUEvQRuQn0iKTEusSqxf6r&#x2F;1LVTu5KckoqS2qdZTsuZdm663nTe9CMzlGcwZxxIJiTHJ+9Kfs8MZ1Yy+2cyZm6Y2cfyZa1jPU3xSVmT0sP2ZK9iP071TF2V2p3mmbY6rYfjzSnl9HJ9ueXc5+lB6ZvTX2eEZ+zI+MSL5+3JlMtMzmzgq&#x2F;Ez+KeyDLNysq4IbARFgo5Z7rPWzuoThgirRIhomqherAH&#x2F;YLZKrCQ&#x2F;SDqzvbIrst&#x2F;Mjpt9IEc1h5&#x2F;TmmuduyT3cV5A3vY5+BzWnOZ84&#x2F;yF+Z1z6XO3zEPmzZzXPN90fuH8rgWBC3YuVFiYsfC3AlrBqoKXi+IXNRYaFC4ofPhD4A+7iyhFwqIbiz0Wb&#x2F;4R&#x2F;5H748Ul45esX&#x2F;KxOKX4fAmtpLTk&#x2F;VLW0vM&#x2F;OfxU9tOnZanLLi53Xr5pBXEFf0X7Su+VO1eprspb9XD15NV1a6hrite8XDtj7bnSCaWb1ymsk6zrKAstq19vtn7F+vflnPK2ikkVezbob1iy4fXGlI1XN&#x2F;lsqt1ssLlk87ufuT&#x2F;f3BK4pa7SorJ0K3Fr9tZH2+K2tWx33V5dpVdVUvVhB39Hx86onaeqXaqrd+nvWr4b3S3Z3VOTVHP5F79f6mvtarfs0dpTshfslex9si95X&#x2F;v+kP3NB1wP1B40P7jhkPqh4jqkLreu7zDncEd9Qv2VhuCG5kaPxkO&#x2F;2v+6o8m4qeKI5pHlRxWOFh79dCzvWP9xwfHeE2knHjbPaL5zcsrJ66ciT108HXL67JmAMydb6C3HznqebTrnfq7hvOv5wxecL9S1OrUe+s3pt0MXnS&#x2F;WXXK5VH&#x2F;Z7XLjlYlXjl71vnrimt+1M9cZ1y+0hbVdaY9tv3kj6UbHzZSb3bd4t57fzr49cGcB&#x2F;Igvvqdyr&#x2F;S+&#x2F;v3K38f+vqfDueNIp19n64PoB3cesh4+&#x2F;UP0x&#x2F;uuwkfkR6WPjR5Xdzt2N&#x2F;UE9Fx+MvVJ11PB04Heoj9V&#x2F;9zwzOrZwb98&#x2F;mrtm9LX9Vz4&#x2F;NPfS1&#x2F;ovtjxcsLL5v6I&#x2F;vuvMl8NvC5+o&#x2F;tm51vXty3v4t89Hpj9nvS+7MPYD40fQz7e&#x2F;ZT56dN&#x2F;AC1d8BzqtvWAAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAAeoAMABAAAAAEAAAAYAAAAAGbJ4J8AAAElSURBVDgRnZQxTsNAEEX&#x2F;WFGUC6RDEEGFREkPihEVokoVDkDFAWgISsUZuAIFQjQUFE5Ni1NEhEjQxQegy2fsFPHKu&#x2F;Zutpr5&#x2F;u&#x2F;vFOsBwDNOVhkDjroTxlA0DqBMayxMcMJfGeEH1CyfI9jlWHYwAZcaN&#x2F;Rhyh5eKbWM0FXxu&#x2F;zBq56rqxsVVt+BN7kFsYY3YlDlgPnIJx40JTlgHGOAT96zUxfggnOmgxFSXrjxOjin9vHKF&#x2F;bsAU1wTl1iynMb7gPrG8ZqW&#x2F;gZh&#x2F;Jug1s2saR94UbeSr1R1o39hzscuVHAdfMHZriVhXFRpXHAcl1xWoS6sS12U1rDYooeXUFEyNTa+AtU4nIiayHFKR&#x2F;YDlpDexgrnIJ9c6sFdH0N0P2ZbLd6&#x2F;wF85hyuQTMxjwAAAABJRU5ErkJggg&#x3D;&#x3D;&quot;);\n&#125;\n\n.content &#123;\n  margin-top: 10rpx;\n  font-size: 28rpx;\n\n  &#x2F;* 显示两行 *&#x2F;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  display: -moz-box;\n  -moz-line-clamp: 2;\n  -moz-box-orient: vertical;\n  word-wrap: break-word;\n  word-break: break-all;\n  white-space: normal;\n  overflow: hidden;\n&#125;\n\n父组件引入子组件\n 在home-video/index.json中引入子组件\n\n&#123;\n  &quot;enablePullDownRefresh&quot;: true,\n  &quot;backgroundTextStyle&quot;: &quot;dark&quot;,\n  &quot;usingComponents&quot;: &#123;\n    &quot;video-item-v1&quot;: &quot;&#x2F;components&#x2F;video-item-v1&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 改写home-video/index.wxml使用组件\n\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n父组件传值就是通过data-item传递的\n\n\\\n\n 最后我们还需要修改home-video/index.wxss\n\n&#x2F;* pages&#x2F;home-video&#x2F;index.wxss *&#x2F;\n.video &#123;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n&#125;\n\n.item &#123;\n  width: 48%;\n&#125;\n\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第一天","date":"2022-02-10T07:50:55.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"}]