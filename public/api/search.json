[{"id":"582707421ee18063b9b23493d1d2e12f","title":"计算机网络知识点","content":"一、HTTP协议1. GET和POST的区别\n应用场景：\nget是幂等的请求，post不是幂等\nget一般用于对服务器资源不会产生影响的场景，post修改资源场景\n\n\n是否缓存：一般对Get请求缓存，很少对post请求缓存\n发送的报文格式：get没有请求体，post有请求体\n安全性：get请求参数放在url中，相对post不安全\n请求长度：浏览器对url长度限制，影响数据长度，这个是浏览器规定的，不是RFC规定的\n参数类型：post的参数传递支持更多的数据类型\n\n2. POST和PUT的区别\nPOST用于创建数据，它的请求会改变数据的种类等资源，会创建新的内容\nPUT知识修改数据，不会增加数据的种类\n\n3. 常见的HTTP请求头和响应头Req\n\nAccept 浏览器能够处理的内容类型\nAccept-Charset 浏览器能够显示的字符集\nAccept-Encoding 浏览器能够处理的压缩编码\nAccept-Language 浏览器当前设置的语言\nConnection 浏览器与服务器之间连接的类型\nCookie 当前页面设置的任何Cookie\nHost 发送请求的页面所在的域\nReferer 发送请求的页面的URL\nUser-Agent 浏览器的用户代理字符串\n\nResp\n\nDate 表示消息发送的时间\nserver 服务器名称\nConnection 浏览器与服务器之间连接的类型\nCache-Control 控制http缓存\ncontent-type 表示后面的文档属于什么MIME类型\napplication/x-www-form-urlencoded 表单\nmultipart/form-data 上传文件\napplication/json JSON字符串\ntext/xml 提交XML格式的数据\n\n\n\n","slug":"计算机网络知识点","date":"2022-03-16T08:03:40.000Z","categories_index":"知识点","tags_index":"面试,http,网络","author_index":"LIYUNFU"},{"id":"52748ea8c7aacb653b9bc3a082a7560f","title":"基于koa-generator搭建通用服务端","content":"安装koa-generator全局安装koa-generatornpm i koa-generator -g\n\n初始化项目koa2 goudong-server \n\n进入并安装依赖cd goudong-server \nnpm install\n\n\n\n改造项目环境\n在根目录下新建src目录\n\n将public 、routes 、views 、app.js拖入src目录\n\n修改bin/www中的var app = require(&#39;../app&#39;);为var app = require(&#39;../src/app&#39;);\n\n改造后目录\n\n```shell|- bin  |- www|-node_modules|-src  |-public  |-routes  |-views  |-app.js|-package.json\n\n- 在&#96;src&#96;目录下创建四个目录&#96;controller&#96; 、&#96;db&#96; 、&#96;middleware&#96;、&#96;models&#96;\n\n\n\n\n\n## 实现登录功能\n\n### 配置开发环境\n\n#### 安装&#96;koa-generic-session&#96;依赖\n\n&#96;&#96;&#96;shell\nni koa-generic-session \n\n使用const session = require('koa-generic-session')\n\n//session配置\napp.keys = ['liyunfuAAA'] //密钥用于加密\napp.use(session(&#123;\n  //配置cookie\n  cookie: &#123;\n    path: '/',\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000\n  &#125;\n&#125;))\n\n\n\n跨域安装koa2-cors依赖ni koa2-cors\n\n使用const cors = require('koa2-cors')\n\n//cors配置\napp.use(cors(&#123;\n  origin: 'http://localhost:8080',  //前端origin\n  credentials: true //允许跨域带cookie\n&#125;))\n\n连接数据库安装mongooseni mongoose\n\n在db目录下新建db.js/**\n * @description mongoose 连接数据库\n * @author liyunfu\n */\nconst mongoose = require('mongoose')\n\nconst DB_URL = 'mongodb://root:example@47.99.147.11.27017/jingdong?authSource=admin'\n\n// 开始连接\nmongoose.connect(DB_URL, &#123;\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n&#125;)\n\n// 连接对象\nconst db = mongoose.connection\n\ndb.on('error', err => &#123;\n  console.error('mongoose connect error', err)\n&#125;)\ndb.once('open', () => &#123;\n  console.log('mongoose 连接成功')\n&#125;)\n\nmodule.exports = mongoose\n\n\n\n设计Schema和Model\n在models目录下新建User.js\n/**\n * @description user Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true,\n    unique: true\n  &#125;,\n  password: String\n&#125;, &#123; timestamps: true &#125;)\n\nconst User = mongoose.model('user', Schema)\n\nmodule.exports = User\n在models下新建Address.js\n/**\n * @description Address Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  city: String,\n  department: String,\n  houseNumber: String,\n  name: String,\n  phone: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Address = mongoose.model('address', Schema)\n\nmodule.exports = Address\n在models下新建Shop.js\n/**\n * @description Shop Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  expressLimit: &#123;\n    type: Number,\n    default: 0\n  &#125;,\n  expressPrice: Number,\n  slogan: String\n&#125;, &#123; timeStamps: true &#125;)\n\nconst Shop = mongoose.model('shop', Schema)\n\nmodule.exports = Shop\n在models下新建Product.js\n/**\n * @description Product Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  ShopId: &#123;\n    type: String,\n    require: true\n  &#125;,\n  name: String,\n  imgUrl: String,\n  sales: Number,\n  price: Number,\n  oldPrice: Number,\n  tabs: [String]  //示例 tabs:['all','seckill']\n&#125;, &#123; timestamps: true &#125;)\n\nconst Product = mongoose.model('product', Schema)\n\nmodule.exports = Product\n在models下新建Order.js \n/**\n * @description Order Model\n * @author liyunfu\n */\n\nconst mongoose = require('../db/db')\n\nconst Schema = mongoose.Schema(&#123;\n  username: &#123;\n    type: String,\n    require: true\n  &#125;,\n  shopId: String,\n  shopName: String,\n\n  idCanceled: &#123;\n    type: Boolean,\n    default: false\n  &#125;,\n  address: &#123;\n    username: String,\n    city: String,\n    department: String,\n    houseNumber: String,\n    name: String,\n    phone: String\n  &#125;,\n  products: [\n    &#123;\n      product: &#123;\n        shopId: &#123;\n          type: String,\n          require: true\n        &#125;,\n        name: String,\n        imgUrl: String,\n        sales: Number,\n        price: Number,\n        oldPrice: Number,\n        tabs: [String]\n      &#125;,\n      orderSales: Number\n    &#125;\n  ]\n&#125;, &#123; timestamps: true &#125;)\n\nconst Order = mongoose.model('order', Schema)\n\nmodule.exports = Order\n在models 下新建index.js \n/**\n * @description Model 入口文件\n * @author liyunfu\n */\nconst Address = require('./Address')\nconst Order = require('./Order')\nconst Product = require('./Product')\nconst Shop = require('./Shop')\nconst User = require(\"./User\")\n\nmodule.exports = &#123;\n  Address,\n  Order,\n  Product,\n  Shop,\n  User\n&#125;\n\n标准化请求成功与失败的响应信息\n在res-model 下新建ErrorModel.js\n/**\n * @description 错误返回的数据结构\n * @author liyunfu\n */\n\nclass ErrorModel &#123;\n  constructor(errno = -1, message = 'error') &#123;\n    this.errno = errno\n    this.message = message\n  &#125;\n&#125;\n\nmodule.exports = ErrorModel\n在res-model 下新建SuccessModel.js\n/**\n * @description 成功返回的数据类型\n * @author liyunfu\n */\n\nclass SuccessModel &#123;\n  constructor(data) &#123;\n    this.errno = 0\n    if (data !== null) &#123;\n      this.data = data\n    &#125;\n  &#125;\n&#125;\n\nmodule.exports = SuccessModel\n在res-model 下新建入口文件index.js\n/**\n * @description 返回数据类型 入口文件\n * @author liyunfu\n */\nconst SuccessModel = require('./SuccessModel')\nconst ErrorModel = require('./ErrorModel')\n\nmodule.exports = &#123; SuccessModel, ErrorModel &#125;\n\n编写登录验证中间件\n在middleware 下新建loginCheck.js\n/**\n * @description 登录验证中间件\n * @author liyunfu\n */\n\nconst &#123; ErrorModel &#125; = require('../res-model/index')\n\nmodule.exports = async (ctx, next) => &#123;\n  const session = ctx.session\n\n  if (session &amp;&amp; session.userInfo) &#123;\n    await next()\n    return\n  &#125;\n  ctx.body = new ErrorModel(10003, '中间件登录验证失败')\n&#125;\n\n用户操作接口\n在controller 下新建 user.js\n/**\n * @description user controller\n * @author liyunfu\n */\n\nconst &#123; User &#125; = require('../models/index')\n\n/**\n * 注册方法\n * @param &#123;Object&#125; userInfo 用户信息\n * @returns \n */\nasync function register(userInfo = &#123;&#125;) &#123;\n  // 注意验证一下username unique\n  const newUser = await User.create(userInfo)\n  return newUser\n&#125;\n\nasync function login(username, password) &#123;\n  const user = await User.findOne(&#123; username, password &#125;)\n  if (user != null) &#123;\n    // 登录成功\n    return true\n  &#125;\n  return false\n&#125;\n\nmodule.exports = &#123;\n  register, login\n&#125;\n在routes 下新建users.js\nconst router = require('koa-router')()\n\n\nconst &#123; register, login &#125; = require('../controller/user')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user')\n\n// 注册\nrouter.post('/register', async function (ctx, next) &#123;\n  const userInfo = ctx.request.body\n  try &#123;\n    await register(userInfo)\n    // 返回成功\n    ctx.body = new SuccessModel()\n  &#125; catch (ex) &#123;\n    console.log(ex)\n    // 返回失败\n    ctx.body = new ErrorModel(10001, `注册失败 - $&#123;ex.message&#125;`)\n  &#125;\n&#125;)\n\n// 登录\nrouter.post('/login', async (ctx, next) => &#123;\n  const &#123; username, password &#125; = ctx.request.body\n  // 查询单个用户\n  const res = await login(username, password)\n\n  if (res) &#123;\n    // 登录成功\n    ctx.session.userInfo = &#123; username &#125;  //设置session\n\n    ctx.body = new SuccessModel()\n  &#125; else &#123;\n    ctx.body = new ErrorModel(10002, `登录验证失败`)\n  &#125;\n&#125;)\n\nrouter.get('/info', loginCheck, async function (ctx, next) &#123;\n  // 加了loginCheck之后，因为保证了必须登录\n  const session = ctx.session\n  ctx.body = new SuccessModel(session.userInfo)\n&#125;)\nmodule.exports = router\n\n地址操作接口\n在controller 下新建address.js\n/**\n * @description address controller\n * @author liyunfu\n */\n\nconst &#123; Address &#125; = require('../models/index')\n\n/**\n * 创建地址 \n * @param &#123;string&#125; username 用户名\n * @param &#123;Object&#125; data 地址的详细信息\n * @returns \n */\nasync function createAddress(username, data) &#123;\n  const address = await Address.create(&#123; username, ...data &#125;)\n\n  return address\n&#125;\n\n/**\n * 获取地址列表\n * @param &#123;string&#125; username 用户名\n * @returns \n */\nasync function getAddressList(username) &#123;\n  const list = await Address.find(&#123; username &#125;).sort(&#123; updatedAt: -1 &#125;)\n  return list\n&#125;\n\n/**\n * 获取单个收获地址\n * @param &#123;string&#125; id id\n * @returns \n */\nasync function getAddressById(id) &#123;\n  const address = await Address.findById(id)\n  return address\n&#125;\n\nasync function updateAddress(id, username, data) &#123;\n  const address = await Address.findOneAndUpdate(\n    &#123;\n      // 查询条件\n      _id: id,\n      username,\n    &#125;,\n    &#123;\n      username, ...data\n    &#125;,\n    &#123;\n      new: true  //返回更新之后的最新数据，默认时false，返回更新之前的数据\n    &#125;\n  )\n  return address\n&#125;\n\nmodule.exports = &#123;\n  createAddress,\n  getAddressList,\n  getAddressById,\n  updateAddress\n&#125;\n在routes 下新建address.js\n/**\n * @description address router\n * @author liyunfu\n */\n\nconst router = require('koa-router')()\nconst &#123; createAddress, getAddressList, getAddressById, updateAddress &#125; = require('../controller/address')\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\n\nrouter.prefix('/api/user/address')\n\n// 创建收货地址\nrouter.post('/', loginCheck, async (ctx, next) => &#123;\n  // 获取用户信息\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  const data = ctx.request.body\n\n  // 创建数据\n  try &#123;\n    const newAddress = await createAddress(username, data)\n    ctx.body = new SuccessModel(newAddress)\n  &#125; catch (error) &#123;\n    console.log(error)\n    ctx.body = new ErrorModel(10004, '创建收货地址失败')\n  &#125;\n&#125;)\n\n// 获取收货地址列表\nrouter.get('/', loginCheck, async (ctx, next) => &#123;\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 获取列表\n  const list = await getAddressList(username)\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 获取单个收获地址\nrouter.get('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const address = await getAddressById(id)\n\n  ctx.body = new SuccessModel(address)\n&#125;)\n\n// 更新收货地址\nrouter.patch('/:id', loginCheck, async (ctx, next) => &#123;\n  const id = ctx.params.id\n  const data = ctx.request.body\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n  // 更新\n  const newAddress = await updateAddress(id, username, data)\n  ctx.body = new SuccessModel(newAddress)\n&#125;)\n\nmodule.exports = router\n\n商店商品接口\n在controller 下新建shop.js\n/**\n * @description shop controller\n * @author liyunfu\n */\n\nconst &#123; &#125; = require('../models/index')\n\n// 热门商店列表\nasync function getHotList() &#123;\n  const list = await Shop.find().sort(&#123; _id: -1 &#125;) //逆序\n  return list\n&#125;\n\n// 根据id获取单个商店信息\nasync function getShopInfo(id) &#123;\n  const shop = await Shop.findById(id)\n  return shop\n&#125;\n\n// 根据商店id获取商品\nasync function getProductByShopId(id, tab = '') &#123;\n  const pList = await Product.find(&#123;\n    shopId: id,\n    tabs: &#123;\n      $in: tab  //匹配tabs\n    &#125;\n  &#125;).sort(&#123; _id: -1 &#125;)  //逆序\n  return pList\n&#125;\n\nmodule.exports = &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125;\n在routes下新建shop.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel &#125; = require('../res-model/SuccessModel')\n\nconst &#123;\n  getHotList,\n  getShopInfo,\n  getProductByShopId\n&#125; = require('../controller/shop')\n\nrouter.prefix('/api/shop')\n\n// 热门商店（首页商店列表）\nrouter.get('/hot-list', async function (ctx, next) &#123;\n  const list = await getHotList()\n  ctx.body = new SuccessModel(list)\n&#125;)\n\n// 根据 id 查询单个商店信息\nrouter.get('/:id', async function (ctx, next) &#123;\n  const id = ctx.params.id  //商店id\n  const shop = await getShopInfo(id)\n  ctx.body = new SuccessModel(shop)\n&#125;)\n\nrouter.get('/:id/product', async function (ctx, next) &#123;\n  const id = ctx.params.id\n  const tab = ctx.query.tab || 'all'\n  const products = await getProductByShopId(id, tab)\n  ctx.body = new SuccessModel(products)\n&#125;)\n\n订单接口\n在controller 下新建order.js\n/**\n * @description order controller\n * @author liyunfu\n */\n\nconst &#123; Order, Product, Address &#125; = require('../models/index')\n\n// 创建订单(要从Address，Product里拷贝数据，比较麻烦)\nasync function createOrder(username, data = &#123;&#125;) &#123;\n  console.log(username, data)\n  // 结构data(前端传来的订单信息)\n  const &#123;\n    addressId,\n    shopId,\n    shopName,\n    isCanceled = false,\n    products = []\n  &#125; = data\n\n  // 根据addressId获取地址信息\n  const address = await Address.findById(addressId)\n\n  // 获取商品列表\n  const pIds = products.map(p => p.id)\n  const productList = await Product.find(&#123;\n    // 条件1：商品id\n    _id: &#123;\n      $in: pIds\n    &#125;,\n    // 条件2：商店id\n    shopId\n  &#125;)\n\n  // 给商品列表增加销售数量(订单里，每个商品都有销量)\n  const productListWithSales = productList.map(p => &#123;\n    // 商品id\n    const id = p._id.toString()\n\n    // 找到商品销量\n    const filterProducts = products.filter(item => item.id === id)\n    if (filterProducts.length === 0) &#123;\n      // 没有找到匹配的数量 报错\n      throw new Error('未找到匹配的销量数据')\n    &#125;\n\n    return &#123;\n      orderSales: filterProducts[0].num,\n      product: p\n    &#125;\n  &#125;)\n\n  // 创建订单\n  const newOrder = await Order.create(&#123;\n    username,\n    address,\n    shopId,\n    shopName,\n    isCanceled,\n    products: productListWithSales\n  &#125;)\n  return newOrder\n&#125;\n\n// 获取订单列表\nasync function getOrderList(username) &#123;\n  console.log('username', username)\n  const list = await Order.find(&#123; username &#125;).sort(&#123; _id: -1 &#125;)\n  console.log('list', 'list')\n  return list\n&#125;\n\nmodule.exports = &#123;\n  createOrder,\n  getOrderList\n&#125;\n在routes 下新建order.js\nconst router = require('koa-router')()\n\nconst &#123; SuccessModel, ErrorModel &#125; = require('../res-model/index')\nconst loginCheck = require('../middleware/loginCheck')\nconst &#123; createOrder, getOrderList &#125; = require('../controller/order')\n\nrouter.prefix('/api/order')\n\n// 创建订单\nrouter.post('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证 可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  // 订单数据\n  const data = ctx.request.body\n\n  try &#123;\n    const newOrder = await createOrder(username, data)\n    ctx.body = new SuccessModel(newOrder)\n  &#125; catch (ex) &#123;\n    console.error(ex)\n    ctx.body = new ErrorModel(10005, '订单创建失败')\n  &#125;\n&#125;)\n\n// 获取订单列表\nrouter.get('/', loginCheck, async function (ctx, next) &#123;\n  // 有登录验证，可以直接获取session\n  const userInfo = ctx.session.userInfo\n  const username = userInfo.username\n\n  const list = await getOrderList(username)\n\n  ctx.body = new SuccessModel(list)\n&#125;)\n\nmodule.exports = router\n\n改为适合部署到Vercel的项目\n在根目录下新建vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    &#125;\n  ]\n&#125;\n在根目录下新建index.js 将原bin/www内容移到此处\n\n修改package.json\n\"start\": \"node index.js\",\n\"dev\": \"./node_modules/.bin/nodemon index.js\",\n\"prd\": \"pm2 start index.js\",\n\n改造项目，实现跨域\n修改根目录下vercel.json\n&#123;\n  \"version\": 2,\n  \"builds\": [\n    &#123;\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    &#125;\n  ],\n  \"routes\": [\n    &#123;\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\",\n      \"headers\": &#123;\n        \"Access-Control-Allow-Credentials\": \"true\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,OPTIONS,PATCH,DELETE,POST,PUT\",\n        \"Access-Control-Allow-Headers\": \"X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version\"\n      &#125;\n    &#125;\n  ]\n&#125;\n\n​      \n","slug":"基于koa-generator搭建通用服务端","date":"2022-03-05T02:51:22.000Z","categories_index":"实战","tags_index":"实战,koa","author_index":"LIYUNFU"},{"id":"7bb7fcd214fc2de4ef1142bae196581d","title":"标准化大厂编码规范解决方案","content":"升级最新的vuenpm i vue@3.2.8 vue-router@4.0.11 vuex@4.0.2\n\nESLint规则// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象\n// 文档：https://eslint.bootcss.com/docs/user-guide/configuring\nmodule.exports = &#123;\n  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下\n  root: true,\n  // env 表示启用 ESLint 检测的环境\n  env: &#123;\n    // 在 node 环境下启动 ESLint 检测\n    node: true\n  &#125;,\n  // ESLint 中基础配置需要继承的配置\n  extends: [\"plugin:vue/vue3-essential\", \"@vue/standard\"],\n  // 解析器\n  parserOptions: &#123;\n    parser: \"babel-eslint\"\n  &#125;,\n  // 需要修改的启用规则及其各自的错误级别\n  /**\n   * 错误级别分为三种：\n   * \"off\" 或 0 - 关闭规则\n   * \"warn\" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n   * \"error\" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n   */\n  rules: &#123;\n    \"no-console\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    \"no-debugger\": process.env.NODE_ENV === \"production\" ? \"warn\" : \"off\",\n    'space-before-function-paren': 0  //函数参数前括号没有空格\n  &#125;\n&#125;;\n\nPrettier配置.prettierrc\n&#123;\n  // 不尾随分号\n  \"semi\": false,\n  // 使用单引号\n  \"singleQuote\": true,\n  // 多行逗号分割的语法中，最后一行不加逗号\n  \"trailingComma\": \"none\"\n&#125;\n\n修改VSCode的TabSize\n配置大厂git提交规范全局安装Commitizennpm install -g commitizen@4.2.4\n\n安装并配置 cz-customizable 插件安装npm i cz-customizable@6.3.0 --save-dev\n\n添加以下配置到 package.json 中\"config\": &#123;\n  \"commitizen\": &#123;\n    \"path\": \"node_modules/cz-customizable\"\n  &#125;\n&#125;\n\n项目根目录下创建 .cz-config.js 自定义提示文件module.exports = &#123;\n  // 可选类型\n  types: [\n    &#123; value: 'feat', name: 'feat:     新功能' &#125;,\n    &#123; value: 'fix', name: 'fix:      修复' &#125;,\n    &#123; value: 'docs', name: 'docs:     文档变更' &#125;,\n    &#123; value: 'style', name: 'style:    代码格式(不影响代码运行的变动)' &#125;,\n    &#123;\n      value: 'refactor',\n      name: 'refactor: 重构(既不是增加feature，也不是修复bug)'\n    &#125;,\n    &#123; value: 'perf', name: 'perf:     性能优化' &#125;,\n    &#123; value: 'test', name: 'test:     增加测试' &#125;,\n    &#123; value: 'chore', name: 'chore:    构建过程或辅助工具的变动' &#125;,\n    &#123; value: 'revert', name: 'revert:   回退' &#125;,\n    &#123; value: 'build', name: 'build:    打包' &#125;\n  ],\n  // 消息步骤\n  messages: &#123;\n    type: '请选择提交类型:',\n    customScope: '请输入修改范围(可选):',\n    subject: '请简要描述提交(必填):',\n    body: '请输入详细描述(可选):',\n    footer: '请输入要关闭的issue(可选):',\n    confirmCommit: '确认使用以上信息提交？(y/n/e/h)'\n  &#125;,\n  // 跳过问题\n  skipQuestions: ['body', 'footer'],\n  // subject文字长度默认是72\n  subjectLimit: 72\n&#125;\n\n使用 git cz 代替 git commit使用 husky + commitlint 检查提交描述是否符合规范要求commitlint安装依赖：npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4\n\n根目录下创建 commitlint.config.js 文件module.exports = &#123;\n  // 继承的规则\n  extends: ['@commitlint/config-conventional'],\n  // 定义规则类型\n  rules: &#123;\n    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    'type-enum': [\n      2,\n      'always',\n      [\n        'feat', // 新功能 feature\n        'fix', // 修复 bug\n        'docs', // 文档注释\n        'style', // 代码格式(不影响代码运行的变动)\n        'refactor', // 重构(既不增加新功能，也不是修复bug)\n        'perf', // 性能优化\n        'test', // 增加测试\n        'chore', // 构建过程或辅助工具的变动\n        'revert', // 回退\n        'build' // 打包\n      ]\n    ],\n    // subject 大小写不做校验\n    'subject-case': [0]\n  &#125;\n&#125;\n\n注意：确保保存为 UTF-8 的编码格式，否则可能会出现以下错误：\n\nhusky安装依赖：npm install husky@7.0.1 --save-dev\n\n启动 hooks ， 生成 .husky 文件夹npx husky install\n\n在 package.json 中生成 prepare 指令\n执行 prepare 指令npm run prepare\n\n执行成功，提示\n添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx –no-install commitlint –edit “$1” 指令npx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"'\n\n此时的 .husky 的文件结构\n至此， 不符合规范的 commit 将不再可提交\n通过 pre-commit 检测提交时代码规范我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint –ext .js,.vue src 指令来去进行相关检测：\n\n 执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; 添加 commit 时的 hook （npx eslint --ext .js,.vue src 会在执行到该 hook 时运行） \n 该操作会生成对应文件 pre-commit： \n\n\nlint-staged 自动修复格式错误lint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送lint-staged 无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了\n修改 package.json 配置\"lint-staged\": &#123;\n    \"src/**/*.&#123;js,vue&#125;\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  &#125;\n\n修改 .husky/pre-commit 文件#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\nnpx lint-staged\n","slug":"标准化大厂编码规范解决方案","date":"2022-02-10T08:33:17.000Z","categories_index":"规范","tags_index":"git,规范","author_index":"LIYUNFU"},{"id":"82a5309356b9c984c2a532692d47ab73","title":"CSS知识点","content":"","slug":"CSS面试题","date":"2022-03-15T05:02:20.000Z","categories_index":"知识点","tags_index":"css,面试","author_index":"LIYUNFU"},{"id":"1b47919438b08a0e56e1fac60890eb9a","title":"HTML知识点","content":"1. 如何理解HTML语义化优点\n\n对机器友好，更适合搜索引擎的爬取，有利于SEO。支持读屏软件，根据文章可以自动生成目录\n对开发者友好，增强可读性，结构更加清晰，便于维护\n\n常见语义化标签\n&lt;header>头部&lt;/header>\n&lt;nav>导航栏&lt;/nav>\n&lt;section>区块(有语义化的div)&lt;/section>\n&lt;main>主要区域&lt;/main>\n&lt;article>主要内容&lt;/article>\n&lt;aside>侧边栏&lt;/aside>\n&lt;footer>底部&lt;/footer>\n\n\n\n2. 常见块级和内联元素块级元素\n\ndiv、h1、h2、table、ul、ol、p等\n\n内联元素\n\nspan、img、input、button等\n\n3. DOCTYPE(文档类型的作用)告诉浏览器（解析器）应该以什么样的文档类型（html或xhtml）定义来解析文档\n浏览器渲染页面的两种模式（可通过document.compatMode 获取）\nCSS1Compat：标准模式(Strick mode) ，默认模式，浏览器使用W3C标准解析渲染页面，在标准模式下，浏览器以其支持的最高标准呈现页面\nBackCompat：怪异模式(Qiock mode) ，浏览器以自己的怪异模式解析渲染页面，在怪异模式中，页面以一种比较宽松的向后兼容的方式显示\n触发怪异模式的方式\n\nIE浏览器\n不写DOCTYPE\nbox-sizing:border-box \n\n4. src和href的区别\nsrc：表示对资源的引用，指向的内容会被下载并嵌入到当前标签所在位置，如js脚本，当浏览器解析到该元素时，会暂停其他资源的下载和处理，指导该资源加载、编译、执行完毕，所以一半js脚本会放在页面底部\nhref：表示超文本引用，它指向一些网络资源，建立和当前元素或当前文档的链接关系，当浏览器识别到它指向的文件时，会并行下载资源，不会停止对当前文档的处理，常用在a、link等标签上\n\n5. script标签中defer和async的区别如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素怒，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\ndefer和async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，区别如下：\n\n执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行\n脚本是否并行执行：async属性，并行加载，并行执行；defer属性，并行加载，等到文档所有元素解析完成之后才执行，在DOMContentLoaded触发之前\n\n6. 常用的meta标签有哪些\ncharset ，用来描述HTML文档的编码类型\n\n&lt;meta charset=\"utf-8\">\n\n\nkeywords ，页面关键词\n\n&lt;meta name=\"keywords\" content=\"关键词\" />\n\n\ndescription ，页面描述\n\n&lt;meta name=\"description\" content=\"页面描述\" />\n\n\nrefresh ，页面重定向和刷新\n\n&lt;meta http-equiv=\"refresh\" content=\"0;url=\" />\n\n\nviewport ，适配移动端，可以控制视口的大小和比例\n\n&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1\" />\n\ncontent 参数有以下几种\n\nwidth：宽度(数值/device-width)\nheight：高度(数值/device-height)\ninitial-scale：初始缩放比例\nmaximum-scale ：最大缩放比例\nminimum-scale ：最小缩放比例\nuser-scalable：是否允许用户缩放(yes/no)\n\n\n搜索引擎索引方式\n\n&lt;meta name=\"robots\" content=\"index,follow\" />\n\ncontent 参数有以下几种\n\nall：文件将被检索，且页面上的链接可以被查询\nnone：文件不被检索，且页面上的链接不可以被查询\nindex：文件将被检索\nfollow：页面上的链接可以被查询\nnoindex：文件不被检索\nnofollow：页面上的链接不可以被查询\n\n7. HTML有哪些更新1. 语义化标签\nheader：头部\nnav：导航\nfooter：底部\narticle：文章内容\nsection：文档中的节\naside：侧边栏\n\n2. 媒体标签\naudio：音频\n\n&lt;audio src='' controls autoplay loop />\n\n属性\n\ncontrols 控制面板\nautoplay 自动播放\nloop 循环播放\n\n\nvideo：适配\n\n&lt;video src='' poster='imgs/aa.jpg' controls />\n\n属性\n\nposter 指定封面\ncontrols 控制面板\nwidth 宽度\nheight 高度\n\n\nsource标签，兼容不同的浏览器\n\n&lt;video>\n  &lt;source src='aa.flv' type='video/flv'>&lt;/source>\n  &lt;source src='aa.mp4' type='video/mp4'>&lt;/source>\n&lt;/video>\n\n3. 表单表单类型\n\nemail 能够验证当前输入的邮箱地址是否合法\nurl 验证url\nnumber 只能输入数字，自带点击增加减小箭头，max属性设置为最大值，min设置为最小值，value为默认值\nsearch 可以一键删除输入内容\nrange 可以提供一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值\ncolor 提供一个颜色拾取器\ntime 时间选择器\ndata 日期选择器\ndatatime 时间和日期\ndatatime-local 日期时间控件\nweek 周控件\nmonth 月控件\n\n表单属性\n\nplaceholder 提示信息\nautofocus 自动获取焦点\nautocomplete=&quot;on&quot;或autocomplete=&quot;off&quot; 必须有name属性，并提交过，可以自动填写\nrequired 不能为空\npattern&quot;&quot;里面写入想要的正则模式，例如手机号pattern=&quot;^(+86)?\\d&#123;10&#125;$&quot; \nmutiple 可以选择多个我呢见或者多个邮箱\nform=form表单的ID\n\n表单事件\n\n oninput 每当input里的输入库内容发生变化都会触发此事件\noninvalid 当验证不通过时触发此事件\n\n4. 进度条、度量器\nprogress 标签用来表示任务的进入，max表示最大，value表示已完成多少\n\nmeter 属性：用来显示剩余容量或剩余库存\n\nhigh/low 规定被视作高/低的范围\nmax/min 规定最大/小值\nvalue 规定当前度量值\n\n设置规则：min &lt; low &lt; hight &lt; max\n\n\n5. DOM查询操作\ndocument.querySelector()\ndocument.querySelectorAll()\n\n6. Web存储\nlocalStorage - 没有时间限制的数据存储\nsessionStorage - 针对一个session的数据存储\n\n7. 其他\n拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置，设置元素可拖放\n\n&lt;img draggable=\"true\" />\n\n\n画布：canvas元素使用JS在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas拥有多种绘制路径、矩形、字符以及添加图像的方法\n\n&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\">&lt;/canvas>\n\n\nSVG：可伸缩矢量图形，用来定义用于网络的基于矢量的图形，使用XML格式定义图形，图像的放大或改变尺寸的情况下其图像质量不会有损失，它是万维网联盟的标准\n地理位置：Geolocation用于定位用户的位置\n\n移除\n纯表现的元素：basefont，big，center，font，s，strike，tt，u\n对可用性产生负面影响的元素：frame，frameset，noframes\n\n8. img的srcset属性的作用响应式页面中经常用到根据屏幕密度设置不同的图片，这时就用到了img标签的srcset属性，srcset属性用于设置不同屏幕密度下，img会自动加载不同的图片，用法如下\n&lt;img src=\"images-128.png\" srcset=\"images-256.png 2x\" />\n\n&lt;img src=\"image-128.png\"\n     srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n     sizes=\"(max-width: 360px) 340px, 128px\" />\n\n\n\n其中srcset指定图片的地址和对应的图片质量，sizes 设置临界点，可以按需加载\n\n9. 说一下web workerweb worker为web内容在后台线程中运行脚本提供了一种简单的方法，线程可以执行任务而不干扰用户界面\n10. HTML5的离线存储怎么使用，它的工作原理是什么离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n原理： HTML5的离线存储是基于一个新建的.appcache 文件的缓存机制，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储下来，之后网络处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n使用方法\n\n创建一个和html同名的manifest文件，然后在页面头部加入manifest属性\n\n&lt;html lang=\"en\" manifest=\"index.manifest\">\n\n\n在cache.manifest 文件中编写需要离线存储的资源\n\nCACHE MANIFEST\n    #v0.11\n    CACHE:\n    js/app.js\n    css/style.css\n    NETWORK:\n    resourse/logo.png\n    FALLBACK:\n    / /offline.html\n\n\n\nCACHE 表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身页列出来\nNETWORK 表示在它下面列出来的资源只有在在线的情况下才能访问，它们不会被离线存储，所以在离线情况下无法使用这些资源，不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高\nFALLBACK 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html \n\n\n在离线状态时，操作window.applicationCache 进行离线缓存的操作\n\n如何更新缓存\n\n更新manifest文件\n通过javascript操作\n清除浏览器缓存\n\n注意事项\n\n浏览器对缓存数据的容量限制可能不一样（某些浏览器设置的限制是每个站点5MD）\n如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存\n引用manifest的html必须与manifest文件同源，在同一个域下\nFALLBACK中的资源必须和manifest文件同源\n当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源\n站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问\n当manifest文件发生改变时，资源请求本身也会触发更新\n\n11. 浏览器是如何对HTML5的离线存储资源进行管理和加载\n在线的情况下：浏览器发i西安html头部有manifest属性，它会请求manifest文件，如果是第一次访问页面，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线缓存。如果已经访问过页面并且资源已经进行离线缓存，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件和旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储\n离线的情况下浏览器会直接使用离线存储的资源\n\n12. title与h1的区别、b与strong的区别、i与em的区别\nstrong标签有语义，起到加强语气强调的效果，b标签没有语义，只是加粗标签，搜索引擎更侧重strong\ntitle属性没有明确意义只表示标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响\ni内容展示位斜体，em表示强调的文本\n\n13. iframe有哪些优点优点\n\n用来加载速度较慢的内容\n可以使脚本并行下载\n可以实现跨子域通信\n\n缺点\n\niframe会阻塞主页面的onload事件\n无法被一些搜索引擎识别\n会产生很多页面，不易管理\n\n14. label的作用是什么，如何使用用来定义表单控件的关系：点击label时，自动将焦点定位到与label相关的表单控件上\n\n使用方法  for控件的id  或者直接包裹\n\n&lt;label for=\"mobile\">Phone&lt;/label>\n&lt;input type=\"text\" id=\"mobile\" />\n\n&lt;label>\nPhone:&lt;input  type=\"text\" />\n&lt;/label>\n\n\n\n15. Canvas和SVG的区别SVG 可伸缩矢量图形，是基于XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加JS事件处理器，在SVG中，每个被绘制的图形均被视作对象，如果SVG对象的属性发生变化，那么浏览器能够自动重现图形\n特点\n\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序(比如谷歌地图)\n复杂度高会减慢渲染速度(任何过度使用DOM的应用都不快)\n不适合游戏应用\n\nCanvas 画布，通过JS来绘制2D图形，是逐像素进行渲染的，其位置发生改变，就会重新进行渲染\n特点\n\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以.png或.jpg格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被反复重绘\n\n16. head标签有什么用，其中什么标签必不可少标签用于定义文档的头部，它是所有头部元素的容器，head中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等\n可在head中用的标签\n\n&lt;base&gt;\n&lt;link&gt;\n&lt;meta&gt;\n&lt;script&gt;\n&lt;style&gt;\n&lt;title&gt; 必需\n\n17. 浏览器乱码的原因是什么，如何解决产生乱码的原因：\n\n网页源代码是gbk 的编码，而内容中的中文字是utf-8 编码的，编码不匹配乱码\nhtml 页面编码是gbk ，而程序从数据库中调出呈现是utf-8编码的内容也会造成乱码\n浏览器不能自动检测网页编码，造成乱码\n\n解决办法：\n\n使用软件编辑HTML网页内容\n使用网页涉资编码类型，如果数据库和网页不匹配编码，可以对中文进行转码，使用转码函数\n如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换\n\n18. 渐进增强和优雅降级之间的区别**渐进增强(progressice enhancement)**主要针对低版本的浏览器进行页面重构，保证基本的功能的情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验\n**优雅降级(graceful degradation)**一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容\n19. 说一下HTML5 drag API\ndragstart 事件主体是被拖放元素，在开始拖放被拖放元素时触发\ndrag 事件主体是被拖放元素，在正在拖放被拖放元素时触发\ndragenter 事件主体时目标元素，在被拖放元素进入某元素时触发\ndragover 事件主体是目标元素，在被拖放元素进入某元素时触发\ndragleave 事件主体时目标元素，在被拖放元素移出目标元素时触发\ndrop 事件主体时目标元素，在目标元素完全接受被拖放元素时触发\ndragend 事件主体是被拖放元素，在整个拖放操作结束时触发\n\n20. 网页开发中，如何实现图片的懒加载描述：懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片\n直接将懒加载这事交给浏览器做，为图片加一个属性即可\n&lt;img src=\"kity.png\" loading=\"lazy\" />\n\n\n\n21. 浏览器中如何实现剪切板复制内容的功能描述：在一些博客系统中，可以复制代码，它是怎么实现的\n目前最为推荐的方式是用第三方库Clipboard API进行实现feross/clipboard-copy: Lightweight copy to clipboard for the web (github.com)\nnavigator.clipboard.writeText(text)\n\n复制\ndocument.execCommand(\"copy\")\n\n\n\n22. localhost:3000和localhost:5000的cookie信息是否共享根据同源策略，cookie是区分端口的，但是浏览器实现来说，cookie 区分域，而不区分端口，也就是说同一个ip下的cookie是共享的\n23. 什么是CSRF攻击CSRF跨站请求伪造，又称one-click-attack 顾名思义，通过恶意引导用户一次点击劫持cookie进行攻击，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\n\n使用JSON API，当进行CSRF攻击时，请求体通过&lt;form&gt; 构建，请求头application/www-form-urlencoded 它难以发送JSON数据被服务器所理解\nCSRF Token，生成一个随机的token，切勿放在cookie中，每次请求手动携带该token进行校验\nSameSite Cookie，设置为Lax或者Strict，禁止发送第三方Cookie\n\n24. 在浏览器中如何监听剪切板中内容通过Clipboard API 可以获取剪切板中内容，但需要获取到clipboard-read 权限\n// 是否有读取权限\nconst result=await navigator.permission.query(&#123;name:'clipboard-read'&#125;)\n\n// 获取剪切板内容\nconst text=await navigator.clipboard.readText()\n\n\n\n25. 如何把json数据转化为demo.json并下载文件json视为字符串，可以使用DataURL 进行下载，Text-&gt;DataURL \n除了使用DataURL，还可以转化为Object URL进行下载\nText - &gt; Blob -&gt; Object URL \n可以把以下代码直接粘贴到控制台下载文件\nfunction download(url, name) &#123;\n  const a = document.createElement(\"a\");\n  a.download = name;\n  a.rel = \"noopener\";\n  a.href = url;\n  // 触发模拟点击\n  a.dispatchEvent(new MouseEvent(\"click\"));\n  // 或者 a.click()\n&#125;\n\nconst json = &#123;\n  a: 3,\n  b: 4,\n  c: 5,\n&#125;;\nconst str = JSON.stringify(json, null, 2);\n\n// 方案一：Text -> DataURL\nconst dataUrl = `data:,$&#123;str&#125;`;\ndownload(dataUrl, \"demo.json\");\n\n// 方案二：Text -> Blob -> ObjectURL\nconst url = URL.createObjectURL(new Blob(str.split(\"\")));\ndownload(url, \"demo1.json\");\n\n总结\n\n模拟下载，可以通过新建一个&lt;a href=&quot;url&quot; download&gt; 标签并设置url 即download 属性来下载\n可以通过把json 转化为dataurl 来构造URL\n可以通过把json转化为Blob 再转化为ObjectURL 来构造URL\n\n26. 介绍requestIdleCallback及使用场景requestIdleCallback 维护一个队列，将在浏览器空闲时间内执行，属于后台任务API，可以使用setTimeout 来模拟实现\nconst rIC = window[\"requestIdleCallback\"] || ((f) => setTimeout(f, 1));\n\n在rIC 中执行任务时需要注意以下几点：\n\n执行重计算而非紧急任务\n空闲回调任务时间应该小于50ms，最好更少\n空闲回调中不要操作DOM，因为它本来就是利用的重排重绘后的空闲时间，重新操作DOM又会造成重绘重排\n\nReact的时间分片便是基于类似rIC而实现，然而因为rIC的见同行及50ms流畅问题，React自制了一个实现scheduler \n27. 如何计算白屏时间和首屏时间白屏时间: window.performance.timing.domLoading - window.performance.timing.navigationStart\n首屏时间: window.performance.timing.domInteractive - window.performance.timing.navigationStart\n28. 什么是重排重绘，如何减少重排重绘重排（Reflow）：元素的位置发生变动时发生重排，也叫回流\n重绘（Repaint）：元素的样式发生变动，位置不变。\n重排必定造成重绘，有以下方法\n\n使用DocumentFragment 进行DOM操作，不过现在原生操作很少，基本用不到\nCSS样式尽量批量修改\n避免使用table布局\n为元素提前设置好宽高，不因多次渲染改变位置\n\n29.  什么时Data URLData URL时将图片转换为base64直接嵌入到网页中，使用&lt;img src=&quot;data:[MIME type];base 64&quot; /&gt; 这种方式引用图片，不需要再发送请求获取图片，缺点\n\nbase64编码后的图片会比原来的体积大三分之一左右\nData URL形式的图片不会缓存下来，每次访问页面都要被下载一次，可以将Data URL写入到CSS文件中随着CSS被缓存下来\n\n30. textarea如何禁止拉伸使用CSS眼视光hi可以避免拉伸\ntextarea&#123;\n  resize:none\n&#125;\n\n\n\n31. 在Canvas中如何处理跨域的图片img.setAttribute('crossOrigin','anonymous')\n\n\n\n32. 如何取消请求的发送\nXHR使用xhr.abort() \n\nconst xhr=new XMLHttpRequest(),method=\"GET\",url=\"https://www.baidu.com\";\nxhr.open(method,url,true)\n\nxhr.end()\n\n// 取消发送请求\nxhr.abort()\n\n\nfetch使用AbortController\n\nconst controller = new AbortController()\nconst signal = controller.signal\n\nconst downloadBtn = document.querySelector('.download');\nconst abortBtn = document.querySelector('.abort');\n\ndownloadBtn.addEventListener('click', fetchVideo);\n\n// 点击取消按钮时，取消请求的发送\nabortBtn.addEventListener('click', function() &#123;\n  controller.abort();\n  console.log('Download aborted');\n&#125;);\n\nfunction fetchVideo() &#123;\n  ...\n  fetch(url, &#123;signal&#125;).then(function(response) &#123;\n    ...\n  &#125;).catch(function(e) &#123;\n   // 请求被取消之后将会得到一个 AbortError\n    reports.textContent = 'Download error: ' + e.message;\n  &#125;)\n&#125;\n\n\nAxios使用cancelToken 取消\n\nconst CancelToken=axios.CancelToken\nconst source=CancelToken.source()\n\naxios\n  .get('/user/1234',&#123;\n  cancelToken:souce.token\n&#125;)\n\t.catch(function(thrown)&#123;\n  if(axios.isCancel(thrown))&#123;\n    console.log('request canceled',thrown.message)\n  &#125;else&#123;\n    // handle error\n  &#125;\n&#125;)\n\naxios.post(\n\t'/user/123',\n  &#123;\n    name:'new name'\n  &#125;,\n  &#123;\n    cancelToken:source.token\n  &#125;\n)\n\nsource.cancel('operation canceled by the user')\n\n\n","slug":"HTML知识点","date":"2022-03-15T01:13:09.000Z","categories_index":"知识点","tags_index":"面试,HTML","author_index":"LIYUNFU"},{"id":"50ba5796497ecb4fe11ec2fa6f32ff0a","title":"常用算法","content":"题目1 - 将一个数组旋转k步\n输入数组[1,2,3,4,5,6,7]\n\nk=3,即旋转3步\n\n输出[5,6,7,1,2,3,4]\n\n\nconst arr = [1, 2, 3, 4, 5, 6, 7]\nfunction rotate2(arr, k) &#123;\n  const length = arr.length\n  if (!k || length === 0) return arr\n  const step = Math.abs(k % length)   // abs 取绝对值\n\n  const part1 = arr.slice(-step)\n  const part2 = arr.slice(0, length - step)\n  const part3 = [...part1, ...part2]\n  return part3\n&#125;\n\nconst arr2 = rotate2(arr, 3)\nconsole.log(arr2)\n\n\n\n题目2 - 快速排序\n用JavaScipt 实现快速排序，并说明时间复杂度\n\n找到中间位置midValue\n\n遍历数组，小于midValue放在left，否则放在right\n\n继续递归，最后concat拼接，返回\n\n\nfunction quickSort(arr:number[]):number[]&#123;\n  const length=arr.length\n  if(length===0)return arr\n  \n  const midIndex=Math.floor(length/2)\n  const midValue=arr.slice(midIndex,midIndex+1)[0]\n  \n  const left:number[]=[]\n  const right:number[]=[]\n  \n  for(let i=0;i&lt;length;i++)&#123;\n    if(i!==midIndex)&#123;\n      const n=arr[i]\n      if(n&lt;midValue)&#123;\n        // 小于midValue 则放在left\n        left.push(n)\n      &#125;else&#123;\n        // 大于 midValue 则放在right\n        right.push(n)\n      &#125;\n    &#125;\n  &#125;\n  \n  return quickSort(left).concat([midValue],quickSort(right))\n&#125;\n\nconst arr=[1,6,2,7,3,8,4,9,5]\nconsole.log(quickSort(arr))\n\n\n\n题目3 - 判断字符串是否括号匹配\n一个字符串s可能包含{} () [] 三种括号\n\n判断s是否是括号匹配的\n\n如(a{b}c)匹配，而{a(b或{a(b}c) 就不匹配\n\n\nfunction isMatch(left, right) &#123;\n  if (left === '[' &amp;&amp; right == ']') return true\n  if (left === '&#123;' &amp;&amp; right == '&#125;') return true\n  if (left === '(' &amp;&amp; right == ')') return true\n  return false\n&#125;\nfunction matchBracket(str) &#123;\n  const length = str.length\n  if (length === 0) return true\n\n  const stack = []\n\n  const leftSymbols = '&#123;[('\n  const rightSymbols = '&#125;])'\n\n  for (let i = 0; i &lt; length; i++) &#123;\n    const s = str[i]\n    if (leftSymbols.includes(s)) &#123;\n      // 左括号\n      stack.push(s)\n    &#125; else if (rightSymbols.includes(s)) &#123;\n      // 右括号，判断栈顶\n      console.log('右括号' + s)\n      const top = stack[stack.length - 1]\n      if (isMatch(top, s)) &#123;\n        stack.pop()\n      &#125; else &#123;\n        return false\n      &#125;\n    &#125;\n  &#125;\n  return stack.length === 0\n&#125;\n\nconst str = '&#123;a(b[c])&#125;'\nconsole.log(matchBracket(str))\n\n\n\n题目4 - 反转单向链表\n输入一个单向链表，输出它的反转(头变尾，尾变头)\n\ninterface ILinkListNode &#123;\n  value: number,\n  next?: ILinkListNode\n&#125;\n // 反转链表\nfunction reverseLinkList(listNode: ILinkListNode): ILinkListNode &#123;\n  // 定义三个指针\n  let prevNode: ILinkListNode | undefined = undefined\n  let curNode: ILinkListNode | undefined = undefined\n  let nextNode: ILinkListNode | undefined = listNode\n\n  // 以nextNode为主 遍历链表\n  while (nextNode) &#123;\n    // 第一个元素 删掉next 防止循环引用\n    if (curNode &amp;&amp; !prevNode) &#123;\n      delete curNode.next\n    &#125;\n\n    // 反转指针\n    if (curNode &amp;&amp; prevNode) &#123;\n      curNode.next = prevNode\n    &#125;\n\n    // 整体向后移动\n    prevNode = curNode\n    curNode = nextNode\n    nextNode = nextNode?.next\n  &#125;\n\n  // 当nextNode空时\n  curNode!.next = prevNode\n\n  return curNode\n&#125;\n  // 创建链表\nfunction createLinkList(arr: number[]): ILinkListNode &#123;\n  const length = arr.length\n  if (length === 0) throw new Error('arr is empty')\n\n  let curNode: ILinkListNode = &#123;\n    value: arr[length - 1]\n  &#125;\n  for (let i = length - 2; i >= 0; i--) &#123;\n    curNode = &#123;\n      value: arr[i],\n      next: curNode\n    &#125;\n  &#125;\n\n  return curNode\n&#125;\n\nconst arr = [100, 200, 300, 400, 500]\nconst list = createLinkList(arr)\nconsole.log(list)\n\nconst list1 = reverseLinkList(list)\nconsole.log(list1)\n\n\n\n题目5 - 用链表实现队列interface ILinkListNode &#123;\n  value: number,\n  next?: ILinkListNode\n&#125;\n\nclass MyQueue &#123;\n  private head: ILinkListNode | null = null\n  private tail: ILinkListNode | null = null\n  private len = 0\n  // 入队 在tail位置\n  add(n: number) &#123;\n    const newNode: ILinkListNode = &#123;\n      value: n,\n      next: null\n    &#125;\n    // 处理head\n    if (this.head === null) &#123;\n      this.head = newNode\n    &#125;\n\n    // 处理tail\n    const tailNode = this.tail\n    if (tailNode) &#123;\n      tailNode.next = newNode\n    &#125;\n    this.tail = newNode\n\n    // 记录长度\n    this.len++\n  &#125;\n  // 出队 在head位置\n  delete(): number | null &#123;\n    const headNode = this.head\n    if (headNode == null) return null\n    if (this.len &lt;= 0) return null\n\n    // 取值\n    const value = headNode.value\n\n    //处理head\n    this.head = headNode.next\n\n    // 记录长度\n    this.len--\n\n    return value\n  &#125;\n  get length(): number &#123;\n    // length要单独存储 不能遍历链表来存取 \n    return this.len\n  &#125;\n&#125;\n\nconst q = new MyQueue()\n\nq.add(100)\nq.add(200)\nq.add(300)\nconsole.log('length1', q.length)\nconsole.log(q.delete())\n\n\n\n题目6 - 用两个栈实现一个队列class MyQueue &#123;\n  private stack1: number[] = []\n  private stack2: number[] = []\n\n  /**\n   * 入队\n   */\n  add(n: number) &#123;\n    this.stack1.push(n)\n  &#125;\n\n  /**\n   * 出队\n   */\n  delete(): number | null &#123;\n    let res\n\n    const stack1 = this.stack1\n    const stack2 = this.stack2\n\n    // 将stack1 所有元素移动到stack2中\n    while (stack1.length) &#123;\n      const n = stack1.pop()\n      if (n != null) &#123;\n        stack2.push(n)\n      &#125;\n    &#125;\n\n    // stack2 pop\n    res = stack2.pop()\n\n    // 将stack2所有元素还给stack1\n    while (stack2.length) &#123;\n      const n = stack2.pop()\n      if (n != null) &#123;\n        stack1.push(n)\n      &#125;\n    &#125;\n    return res || null\n  &#125;\n  get length(): number &#123;\n    return this.stack1.length\n  &#125;\n&#125;\n\n\n\n题目7 - 用JS实现二分查找\n递归 - 代码逻辑更加清晰\n\n非递归 - 性能更好\n\n时间复杂度O(logn)\n\n循环查找\n\n凡有序必二分，凡二分，时间复杂度必包含O(logn)\n\n\nfunction binarySearch1(arr: number[], target: number): number &#123;\n  const length = arr.length\n  if (length === 0) return -1\n\n  let startIndex = 0  // 开始位置\n  let endIndex = length - 1  // 结束位置\n\n  while (startIndex &lt;= endIndex) &#123;\n    const midIndex = Math.floor((startIndex + endIndex) / 2)\n    const midValue = arr[midIndex]\n    if (target &lt; midValue) &#123;\n      // 目标值较小 则继续在左侧查找\n      endIndex = midIndex - 1\n    &#125; else if (target > midValue) &#123;\n      // 目标值较大，则继续在右侧查找\n      startIndex = midIndex + 1\n    &#125; else &#123;\n      // 相等 返回\n      return midIndex\n    &#125;\n  &#125;\n  return -1\n&#125;\n\n// 功能测试\nconst nums = [10, 20, 30, 40, 50, 60]\nconsole.log(binarySearch1(nums, 50))\n\n\n递归查找\n\nfunction binarySearch2(arr: number[], target: number, startIndex?: number, endIndex?: number) &#123;\n  const length = arr.length\n  if (length === 0) return -1\n\n  // 开始和结束的范围\n  if (startIndex == null) startIndex = 0\n  if (endIndex == null) endIndex = length - 1\n\n  // 如果start 和 end相遇，则结束\n  if (startIndex > endIndex) return -1\n\n  // 中间位置\n  const midIndex = Math.floor((startIndex + endIndex) / 2)\n  const midValue = arr[midIndex]\n\n  if (target &lt; midValue) &#123;\n    // 目标值较小 则继续在左侧查找\n    return binarySearch2(arr, target, startIndex, midIndex - 1)\n  &#125; else if (target > midValue) &#123;\n    // 目标值较大 则继续在右侧查找\n    return binarySearch2(arr, target, midIndex + 1, endIndex)\n  &#125; else &#123;\n    // 相等 返回\n    return midIndex\n  &#125;\n&#125;\n\n\n\n题目8 - 给一个数组，找出其中和为n的两个元素\n有一个递增的数组[1,2,4,7,11,15] 和一个n=15\n数组中有两个数，和是n，即4+11===15\n\nfunction findTowNumber(arr: number[], n: number): number[] &#123;\n  const res: number[] = []\n\n  const length = arr.length\n\n  let i = 0  // 头\n  let j = length - 1  //尾\n\n  while (i &lt; j) &#123;\n    const n1 = arr[i]\n    const n2 = arr[j]\n    const sum = n1 + n2\n\n    if (sum > n) &#123;\n      // sum大于n 则j要向前移动\n      j--\n    &#125; else if (sum &lt; n) &#123;\n      // sum小于n 则i要向后移动\n      i++\n    &#125; else &#123;\n      // 相等\n      res.push(n1)\n      res.push(n2)\n      break\n    &#125;\n  &#125;\n  return res\n&#125;\n\nconst nums = [1, 2, 4, 7, 11, 15]\nconsole.info(findTowNumber(nums, 15))\n\n\n\n题目9 - 求二叉搜索树的第k小值\n\n二叉搜索树BST即左边小于根，右边大于根\n\ninterface ITreeNode &#123;\n  value: number\n  left: ITreeNode | null\n  right: ITreeNode | null\n&#125;\n\nconst arr: number[] = []\nfunction preOrderTraverse(node: ITreeNode) &#123;\n  if (node == null) return\n  // console.log(node.value)\n  arr.push(node.value)\n  preOrderTraverse(node.left)\n  preOrderTraverse(node.right)\n&#125;\n\nfunction inOrderTraverse(node: ITreeNode | null) &#123;\n  if (node == null) return\n  inOrderTraverse(node.left)\n  // console.log(node.value)\n  arr.push(node.value)\n  inOrderTraverse(node.right)\n&#125;\n\nfunction postOrderTraverse(node: ITreeNode | null) &#123;\n  if (node == null) return\n  postOrderTraverse(node.left)\n  postOrderTraverse(node.right)\n  // console.log(node.value)\n  arr.push(node.value)\n&#125;\n\nfunction getKthValue(node: ITreeNode, k: number): number | null &#123;\n  inOrderTraverse(node)\n  console.log(arr)\n\n  return arr[k - 1] | null\n&#125;\nconst tree: ITreeNode = &#123;\n  value: 5,\n  left: &#123;\n    value: 3,\n    left: &#123;\n      value: 2,\n      left: null,\n      right: null\n    &#125;,\n    right: &#123;\n      value: 4,\n      left: null,\n      right: null\n    &#125;\n  &#125;,\n  right: &#123;\n    value: 7,\n    left: &#123;\n      value: 6,\n      left: null,\n      right: null\n    &#125;,\n    right: &#123;\n      value: 8,\n      left: null,\n      right: null\n    &#125;\n  &#125;\n&#125;\n\nconsole.log(getKthValue(tree, 3))\n\n\n\n题目10 - 求斐波那契数列的弟n值\n用JS计算斐波那契数列的第n个值\n注意时间复杂度\n\nfunction fibonacci(n:number):number&#123;\n  if(n&lt;=0) return 0\n  if(n===1)return 1\n  \n  let n1=0\n  let n2=1\n  let res=0\n  \n  for(let i=2;i&lt;=n;i++)&#123;\n    res=n1+n2\n    \n    n1=n2\n    n2=res\n  &#125;\n  return res\n&#125;\n\nconsole.log(fibonacci(3))\n\n\n\n题目11 - 青蛙跳台阶\n一只青蛙，一次可跳1级，也可跳2级\n问：青蛙跳到n级台阶，总共有多少种方式\n\nvar numWays = function(n) &#123;\n    if(n&lt;=0)return 1\n    if(n===1) return 1\n    \n    let n1=1\n    let n2=1\n    let res=0\n\n    for(let i=2;i&lt;=n;i++)&#123;\n        res=(n1+n2)%(1e9+7)\n        n1=n2\n        n2=res\n    &#125;\n    return res\n&#125;;\n\n\n\n题目12 - 将数组中的0移动到末尾\n如输入[1,0,3,0,11,0] ， 输出[1,3,11,0,0,0]\n\n只移动0，其他顺序不变\n\n必须在原数组进行操作\n\n\nfunction moveZero(arr:number[]):void&#123;\n  const length=arr.length\n  if(length===0) return\n  \n  let i\n  j=-1  //指向第一个0\n  for(i=0;i&lt;length;i++)&#123;\n    if(arr[i]===0)&#123;\n      // 第一个0\n      if(j&lt;0)&#123;\n        j=i\n      &#125;\n    &#125;\n    if(arr[i]!==0&amp;&amp;j>=0)&#123;\n      const n=arr[i]\n      arr[i]=arr[j]\n      arr[j]=n\n      \n      j++\n    &#125;\n  &#125;\n&#125;\n\nconst arr=[1,0,1,1,4,5,0,1,0,0,0,1,2]\nmoveZero(arr)\nconsole.log(arr)\n\n\n\n题目13 - 求字符串中连续最多的字符，以及次数\n如，输入’abbccddeeee1234’ ,计算得出\n连续最多的字符是’e’ 4次\n\n双指针\n\n定义指针i和j，j不动，i继续移动\n\n如果i和 j的值一直相等，则i继续移动\n\n直到i和j的值不相等，记录处理，让j追上i，继续第一步\n\n\nfunction findContinuousChar(str:string):IRes&#123;\n  const res:IRes=&#123;\n    char:'',\n    length:0\n  &#125;\n  \n  const length=str.length\n  if(length===0)return res\n  \n  let tempLength=0  // 临时记录当前连续字符的长度\n  let i=0\n  let j=0\n  \n  for(;i&lt;length;i++)&#123;\n    if(str[i]===str[j])&#123;\n      tempLength++\n    &#125;\n    \n    if(str[i]!==str[j]||i===length-1)&#123;\n      // 不相等 或者i到了字符串的末尾\n      if(tempLength>res.length)&#123;\n        res.char=str[j]\n        res.length=tempLength\n      &#125;\n      tempLength=0  //reset\n      \n      if(i&lt;length-1)&#123;\n        j=i  //让j追上 i\n        i-- // 细节\n      &#125;\n    &#125;\n  &#125;\n  \n  return res\n&#125;\n\nconsole.log(findContinuousChar(\"abaabbbbccddee\"))\n\n\n\n题目14 - 获取1-10000之前所有的对称数(回文数)function findPalindromeNumber(max:number):number[]&#123;\n  const res:number[]=[]\n  if(max&lt;=0)return res\n  \n  for(let i=1;i&lt;=max;i++)&#123;\n    let n=i\n    let rev=0  //存储反转数\n    \n    // 生成反转数\n    while(n>0)&#123;\n      rev=rev*10+n%10\n      n=Math.floor(n/10)\n    &#125;\n    if(i===rev)res.push(i)\n  &#125;\n  return res\n&#125;\n\nconsole.log(findPalindromeNumber(200))\n\n/*\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]\n*/\n\n\n\n题目15 - 高效的英文单词前缀匹配\n有一个英文单词库（数组），里面有几十万个英文单词\n\n输入一个字符串，快速判断是不是某一个单词的前缀\n\n（说明思路，不用写代码）\n\n\n实现方法\n\n将二十六个字母拆分匹配成一个26叉树  -  这一步很长时间才更新一次，不算进算法中\n\n使用hash key查找即可，例如str.a.c.b.c.d\n\n有明确范围的数据(如26个英文字母)，考虑使用哈希表(对象)\n\n\n题目16 - 数字千分位格式化\n将数字千分位格式化，输出字符串\n\n如输入数字12050100，输出字符串12，050，100\n\n（注意：逆序判断）\n\n\n常见思路\n\n使用数组\n\nfunction format(n: number): string &#123;\n    n = Math.floor(n) // 只考虑整数\n\n    const s = n.toString()\n    const arr = s.split('').reverse()\n    return arr.reduce((prev, val, index) => &#123;\n        if (index % 3 === 0) &#123;\n            if (prev) &#123;\n                return val + ',' + prev\n            &#125; else &#123;\n                return val\n            &#125;\n        &#125; else &#123;\n            return val + prev\n        &#125;\n    &#125;, '')\n&#125;\n\n\n使用字符串（推荐）\n\nfunction format(n: number): string &#123;\n    n = Math.floor(n) // 只考虑整数\n\n    let res = ''\n    const s = n.toString()\n    const length = s.length\n\n    for (let i = length - 1; i >= 0; i--) &#123;\n        const j = length - i\n        if (j % 3 === 0) &#123;\n            if (i === 0) &#123;\n                res = s[i] + res\n            &#125; else &#123;\n                res = ',' + s[i] + res\n            &#125;\n        &#125; else &#123;\n            res = s[i] + res\n        &#125;\n    &#125;\n\n    return res\n&#125;\n\n\n\n题目17 - 切换字母大小写\n输入一个字符串，切换其中字母的大小写\n如，输入字符串12bBc34，输出字符串12AbC34\n\n常见思路\n\n正则表达式\nASCII表\n\nfunction switchLetterCase(s:string):string&#123;\n  const res=''\n  \n  const length=s.length\n  if(length===0)return res\n  \n  for(let i=0;i&lt;length;i++)&#123;\n    const c=s[i]\n    const code=c.charCodeAt(0)\n    \n    if(code>=65&amp;&amp;code&lt;=90)&#123;\n      res+=c.toLowerCase()\n    &#125;else if(code>=97&amp;&amp;code&lt;=122)&#123;\n      res+=c.toUpperCase()\n    &#125;else&#123;\n      res+=c\n    &#125;\n  &#125;\n  \n  return res\n&#125;\n\nconsole.log(switchLetterCase('12bBc34'))\n\n\n\n题目18 - 为什么0.1+0.2!==0.3计算机使用二进制存储数据\n\n整数转换二进制没有误差，如9转换为二进制是1001\n\n而小数可能无法用二进制准确表达，如0.2转换为0.20000001\n\n可以用math.js库\n\n\n持续更新中……","slug":"常用算法","date":"2022-03-14T10:17:13.000Z","categories_index":"知识点","tags_index":"算法,数据结构","author_index":"LIYUNFU"},{"id":"ce895751a313319f06b50d562f5dd5db","title":"ES6新特性","content":"let&amp;const解构赋值数组新特性\nArray.of() ：将一组值转化为数组，返回一个新数组，并且不考虑参数的数量或类型\ncopyWithin() ：把指定位置的成员复制到其他位置，返回原数组\nfind() ：返回第一个符合条件的值\nfindIndex() ：返回第一个符合条件的索引\nkeys() ： 对键名的1遍历，返回一个遍历器对象，可用for-of 循环\nvalues() ：与keys() 用法一样，不过是对键值的遍历\nentries() ：与keys() 用法一样，不过是对 键值对的遍历\nArray.from() ： 从一个类数组或可迭代对象中新建一个新的数组实例\nfill() ： 使用定制的元素填充数组，返回原数组\nincludes() ：判断是否包含某一个元素，返回布尔值，对NaN有效，但不能定位，第二个参数开始寻找位置\nflatMap() ：方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组\nflat() ： 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，默认值为1(应用：数组扁平化(当输入Infinity 自动解到最底层))\n\nlet arr = [1, 2, 3, 4, 5]\n\n//Array.of()\nlet arr1 = Array.of(1, 2, 3);\nconsole.log(arr1) // [1, 2, 3]\n\n//copyWithin(): 三个参数 (target, start = 0, end = this.length)\n// target: 目标的位置\n// start: 开始位置，可以省略，可以是负数。\n// end: 结束位置，可以省略，可以是负数，实际位置是end-1。\nconsole.log(arr.copyWithin(0, 3, 5)) // [4, 5, 3, 4, 5]\n\n//find()\nconsole.log(arr.find((item) => item > 3 )) // 4\n\n//findIndex()\nconsole.log(arr.findIndex((item) => item > 3 )) // 3\n\n// keys()\nfor (let index of arr.keys()) &#123;\n    console.log(index); // 一次返回 0 1 2 3 4\n&#125;\n\n// values()\nfor (let index of arr.values()) &#123;\n    console.log(index); // 一次返回 1 2 3 4 5\n&#125;\n\n// entries()\nfor (let index of arr.entries()) &#123;\n    console.log(index); // 一次返回 [0, 1] [1, 2] [2, 3] [3, 4] [4, 5]\n&#125;\n\n let arr = [1, 2, 3, 4, 5]\n\n// Array.from(): 遍历的可以是伪数组，如 String、Set结构，Node节点\nlet arr1 = Array.from([1, 3, 5], (item) => &#123;\n    return item * 2;\n&#125;)\nconsole.log(arr1) // [2, 6, 10] \n\n// fill(): 三个参数 (target, start = 0, end = this.length)\n// target: 目标的位置\n// start: 开始位置，可以省略，可以是负数。\n// end: 结束位置，可以省略，可以是负数，实际位置是end-1。\nconsole.log(arr.fill(7)) // [7, 7, 7, 7, 7]\nconsole.log(arr.fill(7, 1, 3)) // [1, 7, 7, 4, 5]\n\nlet arr = [1, 2, 3, 4]\n\n//includes()\nconsole.log(arr.includes(3)) // true\nconsole.log([1, 2, NaN].includes(NaN)); // true\n\nlet arr = [1, 2, 3, 4]\n\n// flatMap()\nconsole.log(arr.map((x) => [x * 2])); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\nconsole.log(arr.flatMap((x) => [x * 2])); // [ 2, 4, 6, 8 ]\nconsole.log(arr.flatMap((x) => [[x * 2]])); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\n\nconst arr1 = [0, 1, 2, [3, 4]];\nconst arr2 = [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr1.flat()); // [ 0, 1, 2, 3, 4 ]\nconsole.log(arr2.flat(2)); // [ 0, 1, 2, [ 3, 4 ] ]\nconsole.log(arr2.flat(Infinity)); // [ 0, 1, 2, 3, 4 ]\n\n字符串新特性\nUnicode：大括号包含表示Unicode字符\ncodePointAt() ： 返回字符对应码点，与fromCharCode() 对应\nString.fromCharCode() ：将对应的码点返回为字符，与codePointAt() 对应\nString.raw() ：返回把字符串所有变量替换且对斜杠进行转义的结果\nstartsWith() ： 返回布尔值，表示参数字符串是否存在元字符串的头部\nendsWith ：返回布尔值，表示参数字符串是否存在源字符串的头部\nrepart() ：返回一个新字符串，表示将原字符串重复n次\nincludes() ：返回布尔值，表示是否找到了参数字符串\ntrimStart() ：方法从字符串的开头删除空格，trimLeft() 是此方法的别名\ntrimEnd() ：方法从字符串的末端删除空格，trimRight() 是此方法的别名\npadStart() ： 用于头部补全\npadEnd() ： 用于尾部补全\nJSON.stringify() : 可返回不符合UTF-8标准的字符串\nreplace() ：仅替换一个 字符串中某模式的首个实例\nreplaceAll() ： 返回一个新字符串，该字符串中用一个替换项替换了原字符串所有匹配了模式的部分\n模式可以是一个字符串或一个正则表达式，而替换项可以是一个字符串或一个应用于每个匹配项的函数\n\n//Unicode\nconsole.log(\"a\", \"\\u0061\"); // a a\nconsole.log(\"d\", \"\\u&#123;4E25&#125;\"); // d 严\n\nlet str = 'Domesy'\n\n//codePointAt()\nconsole.log(str.codePointAt(0)) // 68\n\n//String.fromCharCode()\nconsole.log(String.fromCharCode(68)) // D\n\n//String.raw()\nconsole.log(String.raw`Hi\\n$&#123;1 + 2&#125;`); // Hi\\n3\nconsole.log(`Hi\\n$&#123;1 + 2&#125;`); // Hi 3\n\nlet str = 'Domesy'\n\n//startsWith()\nconsole.log(str.startsWith(\"D\")) // true\nconsole.log(str.startsWith(\"s\")) // false\n\n//endsWith()\nconsole.log(str.endsWith(\"y\")) // true\nconsole.log(str.endsWith(\"s\")) // false\n\n//repeat(): 所传的参数会自动向上取整，如果是字符串会转化为数字\nconsole.log(str.repeat(2)) // DomesyDomesy\nconsole.log(str.repeat(2.9)) // DomesyDomesy\n\n// 遍历：for-of\n for(let code of str)&#123;\n   console.log(code) // 一次返回 D o m e s y\n &#125;\n \n //includes()\n console.log(str.includes(\"s\")) // true\n console.log(str.includes(\"a\")) // false\n \n // trimStart()\n const string = \"   Hello world!   \";\n console.log(string.trimStart()); // \"Hello world!   \"\n console.log(string.trimLeft()); // \"Hello world!   \"\n \n // trimEnd()\n const string = \"   Hello world!   \";\n console.log(string.trimEnd()); // \"   Hello world!\"\n console.log(string.trimRight()); // \"   Hello world!\"\n\nlet str = 'Domesy'\n\n//padStart(): 会以空格的形式补位吗，这里用0代替，第二个参数会定义一个模板形式，会以模板进行替换\nconsole.log(\"1\".padStart(2, \"0\")); // 01\nconsole.log(\"8-27\".padStart(10, \"YYYY-0M-0D\")); //  YYYY-08-27\n \n// padEnd()：与padStart()用法相同\nconsole.log(\"1\".padEnd(2, \"0\")); // 10\n\n//JSON.stringify() 升级\nconsole.log(JSON.stringify(\"\\uD83D\\uDE0E\")); // 😎\nconsole.log(JSON.stringify(\"\\u&#123;D800&#125;\")); // \\ud800\n\nlet str = \"Hi！，这是ES6~ES12的新特性，目前为ES12\"\n\nconsole.log(str.replace(\"ES\", \"SY\")); // Hi！，这是SY6~ES12的新特性，目前为ES12\nconsole.log(str.replace(/ES/g, \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\n\nconsole.log(str.replaceAll(\"ES\", \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\nconsole.log(str.replaceAll(/ES/g, \"Sy\")); // Hi！，这是Sy6~Sy12的新特性，目前为Sy12\n\n\n\n","slug":"ES6新特性","date":"2022-03-12T10:48:14.000Z","categories_index":"知识点","tags_index":"ES6,前瞻","author_index":"LIYUNFU"},{"id":"c1e8ab70e0a19618b82b65eaec3559f1","title":"React面试题","content":"1. React组件如何通讯\nprops\ncontext\nredux\n自定义事件\n\n2. JSX本质是什么3. context是什么，有何用途4. SCU的用途\n性能优化\n必须配合不可变值使用\n\n5. 描述redux单项数据流6. setState是同步还是异步（场景题）\n\nReact默认父组件有更新，子组件无条件更新\n\n异步action\n需要使用redux-thunk 中间件\n异步返回一个函数，如让网络请求等\n\n\n\n\nview触发一个新的action\naction到dispatch中\n如果dispatch有中间件可能再次触发action\ndispatch触发action到reducer\nreducer根据action生成新的state\nstate去更新view\n\n","slug":"React面试题","date":"2022-03-10T10:29:44.000Z","categories_index":"面试","tags_index":"React,Redux,Router","author_index":"LIYUNFU"},{"id":"deb07f2084ce5c6636760b3189f1eaa0","title":"git命令备忘录","content":"\ngit init 初始化版本库\ngit add 每次提交前都要添加\ngit commit -m “修改信息”  \ngit log 打印提交记录\ngit diff readme  查看版本区别\ngit reset 回到某个版本  git reset --hard  版本代号\ngit reflog 打印操作记录 再使用git reset 版本号可以到未来\n工作区的文件git add之后到了暂存区，暂存区git commit一次性提交到master分支\ngit diff HEAD -- readme.txt 查看工作区和版本库里面最新版本的区别\ngit checkout -- readme.txt 丢弃工作区的修改，从暂存区恢复\ngit reset HEAD readme.txt暂存区回到上一个版本\ngit remote add origin git@github.com:michaelliao/learngit.git 关联远程仓库\ngit push -u origin master第一次推送\ngit push origin master以后推送\ngit remote -v查看远程仓库\ngit remote rm origin解除远程仓库\ngit switch -c dev创建并切换到新的dev分支\ngit switch master切换到master分支\ngit branch查看分支\ngit branch -d dev删除分支\ngit merge dev将dev分支合并到当前分支上\ngit merge --no-ff -m &quot;merge with no-ff&quot; dev合并分支并禁用快速合并\ngit stash把当前工作现场储存下来，方便下一次恢复现场继续工作 \ngit stash pop恢复现场，并把stash内容删除\ngit cherry-pick &lt;commit&gt;  如果当前也有bug 就把原先的提交复制到这儿一份\n命令git push origin &lt;tagname&gt;可以推送一个本地标签；\n命令git push origin --tags可以推送全部未推送过的本地标签；\n命令git tag -d &lt;tagname&gt;可以删除一个本地标签；\n命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。\n\n","slug":"git命令备忘录","date":"2022-03-05T03:08:36.000Z","categories_index":"知识点","tags_index":"git,备忘录","author_index":"LIYUNFU"},{"id":"6f0689131b9192e324f81c8459e5c263","title":"ajax基本使用及跨域过程","content":"ajax\n是什么：ajax是Asynchronous JavaScript and XML（异步 JavaScript 和 XMl）的简写\n异步：异步得像服务器发送请求，在等待响应的过程中，不会阻塞当前页面，浏览器可以做自己的事情。直到成功获取响应后，浏览器才开始处理响应数据\nAjax 需要服务器环境，非服务器环境下，很多浏览器无法正常使用ajax\n\nXMLHttpRequest//创建xhr对象\nconst xhr=new XMLHttpRequest();\n\n//监听事件，处理响应\nxhr.addEventListener('readystatechange',()=>&#123;&#125;,false)\n//或\nxhr.onreadystatechange=()=>&#123;&#125;\n\n//处理响应\nxhr.onreadystatechange=()=>&#123;\n    if(xhr.readyState!==4)return;\n    \n    //http code\n    //获取到响应后，响应的内容会自动填充xhr对象的属性\n    if(xhr.status>=200&amp;&amp;xhr.status&lt;300||xhr.status===304)&#123;\n        console.log(xhr.responseText)\n    &#125;\n&#125;\n\n/*\nreadystatechange 事件监听readyState这个状态的变化\n0: 未初始化，尚未调用open()\n1: 启动，已经调用open() 但尚未调用send()\n2: 发送，已经调用send() 但尚未接收到响应\n3: 接收，已经接收到部分响应数据\n4: 完成，已经接收到全部响应数据，而且已经可以在浏览器中使用了\n*/\n\n//准备发送请求\nxhr.open(\n\t'HTTP 方法 GET、POST、PUT、DELETE',\n    '地址 URL',\n    true //是否异步\n)\n\n//发送请求 send的参数是通过请求体携带的数据 只有post能携带请求体\nxhr.send(null)\n\n属性\nresponseType 和 response 属性\nxhr.onreadystatechange = () => &#123;\n  if (xhr.readyState != 4) return;\n  if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n    // 文本形式的响应内容\n    // responseText 只能在没有设置 responseType 或者 responseType = '' 或 'text' 的时候才能使用\n    // console.log('responseText:', xhr.responseText);\n    // 可以用来替代 responseText\n    console.log('response:', xhr.response);\n    // console.log(JSON.parse(xhr.responseText));\n  &#125;\n&#125;;\n\nxhr.responseType = 'text';\ntimeout属性\n//设置请求的超时时间（单位ms） 在发送之前\n xhr.open('GET', url, true);\n\nxhr.timeout = 10000;\n\nxhr.send(null);\nwithCredentials属性\n//指定使用ajax发送请求时是否携带cookie\nxhr.open('GET', url, true);\n\nxhr.withCredentials = true;\n\nxhr.send(null);\n\n方法\nabort() 终止当前请求\nxhr.open('GET', url, true);\nxhr.send(null);\nxhr.abort();\n//放在发送之后\nsetRequestHeader()设置请求头消息\nxhr.setRequestHeader(头部字段的名称, 头部字段的值);\nxhr.setRequestHeader('Content-Type','application/json')\n\n事件\nload事件 响应数据可用时触发\nxhr.onload=()=>&#123;&#125;\nxhr.addEventListener('load',()=>&#123;&#125;)\n//代替readystatechange 可以有效减少判断标识为4 的状态\nerror事件 请求发生错误时触发\nxhr.addEventListener(\n  'load',\n  () => &#123;\n    if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;\n      console.log(xhr.response);\n    &#125;\n  &#125;,\n  false\n);\nxhr.addEventListener(\n  'error',\n  () => &#123;\n    console.log('error');\n  &#125;,\n  false\n)\nabort事件 调用abort方法后触发\nxhr.addEventListener(\n  'abort',\n  () => &#123;\n    console.log('abort');\n  &#125;,\n  false\n);\n\nJson不支持undefined\n\nJSON.parse()\n将json字符串转化为JS的数据类型，对象或者数组\n\n\nJSON.stringify()\n将JS的基本数据类型，对象或者数组转化为JSON的字符串\n\n\n\nCORS\n使用CORS 跨域的过程\n① 浏览器发送请求\n② 后端在响应头中添加Access-Control-Allow-Origin 头信息\n③ 浏览器接收到响应\n④ 如果是同域下的请求，浏览器不会额外做什么，这次前后端通信就圆满了\n⑤ 如果是跨域请求，浏览器会从响应头中查找是否允许跨域访问\n⑥ 如果允许跨域，通信圆满完成\n⑦ 如果没找到或步包含想要跨域的域名，就丢弃响应结果\n\n\n","slug":"ajax基本使用及跨域过程","date":"2022-03-05T03:06:30.000Z","categories_index":"知识点","tags_index":"ajax,跨域","author_index":"LIYUNFU"},{"id":"c123efc46127ac74fdea33d3d47fa7a0","title":"远程服务器安装Docker并配置数据库","content":"Docker命令安装docker-desktop点击前往官网下载，一直下一步安装即可\n如果出现错误，说明wsl内核未更新到wsl2，点击下载安装之后重启docker-desktop即可\n查看已安装docker版本docker --version\n安装docker-compose\n\n\n\n\n\n\n\n\nDocker Compose是一个工具，旨在帮助定义和共享多容器应用程序。使用Compose，我们可以创建一个YAML文件来定义服务，并且使用单个命令，可以启动所有内容或将其全部拆解。使用 Compose的最大优点是，您可以在文件中定义应用程序堆栈，将其保留在项目存储库的根目录下（现在是受版本控制的），并轻松地让其他人能够为您的项目做出贡献。有人只需要克隆你的存储库并启动撰写应用。事实上，你现在可能会在GitHub/GitLab上看到相当多的项目在做这件事。\n简单来说就是 docker-compose能够让你自定义一个YAML配置文件，能够一键启动所有任务安装了docker desktop的自带docker-compose不需要再安装了\n\nLinux安装教程 https://docs.docker.com/compose/install/\n\n安装mongo使用Docker Hub搜索mongo 点击进入mongo-Docker Hub\ndocker pull mongo:4  #可接版本号也可不接\n\n查看本地下载了哪些镜像docker images\n\n运行mongo映射到宿主机上docker run -d --name some-mongo -p 10050:27017 mongo:4\n\n运行MYSQL映射到宿主机上docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -p 10051:3306 -d mysql:5.6\n\n查看当前运行的服务docker ps\n\n在Linux机器中需要放行端口 10050方案一 直接关闭防火墙#ubuntu\nservice ufw stop\n#centos\nservice firewalld stop\n\n方案二 放行指定端口# ubuntu\nufw allow Port 端口号\n\n#centos\nfirewall-cmd --zone&#x3D;public --add-port&#x3D;10050&#x2F;tcp --permanent\n\n重载防火墙firewall-cmd --reload\n\n提交自己的images提交到docker仓库docker commit id号  liyunfu&#x2F;mysql:1.0\ndocker push liyunfu&#x2F;mysql:1.0 \n\n拉取自己的imagesdocker pull liyunfu&#x2F;mysql:1.0\n\n删除imagesdocker image rm id号\n\n\n\ndocker-compose编写YML文件version: '3'\nservices:\n  mysql1:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10052:3306\n\n  mysql2:\n    image: mysql\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n    ports:\n    - 10053:3306\n\n执行YMLdocker-compose up\n\n\n\nLinux连接远程服务器ssh -p 27822 root@server.bontor.cn   # ssh -p 端口  用户名@服务器地址\n\n查看操作系统版本lsb_release -a\n\n查看内核版本uname -a\n\n检查文件系统磁盘空间占用情况df -Th  # 后缀变为以G为单位 不加以字节为单位\n\n目录结构&#x2F;home  主目录\n&#x2F;etc   软件配置文件\n&#x2F;sys   系统目录\n&#x2F;usr   系统可执行文件\n&#x2F;var   日志文件 不断增长大小\n\nCPU和内存top #查看正在运行的进程 已经cpu占用情况 和内存使用情况\n\n文档型：文件相关命令(touch，cat，echo，rm，vi，cd)touch test.txt \nvi test.txt\ncd &#x2F;home\ncat test.txt\necho &quot;123123&quot;&gt;&gt;test.txt  #两个箭头追加 一个箭头覆盖  \n\n硬件型：磁盘/进程/服务/网络查看进程ps -ef | grep docker  #查询并使用grep筛选 docker进程\n\n强制关闭进程kill -9 进程的PID\n\n查看服务的状态service sshd status\n\n关闭服务service sshd stop  #关闭sshd服务\n\n重启服务service sshd restart\n\n功能型：压缩/解压，下载，远程下载wget 资源地址\n\n解压tar zxvf app.tar.gz\n\n压缩tar zcvf app.tar.gz app\n\n\n\n修改默认SSH端口查看默认监听端口netstat -anlp | grep sshd\n\n修改默认监听端口vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config\n#删除#  修改port 22 为 port 27001\n\n#centos修改之后必须运行\nsemanage port -a -t ssh_port_t -p tcp 27001   \n#提示没有该命令\nyum whatprovides semanage\n#找到拥有命令的包安装\nyum install -y policycoreutils-python\n#查看端口\nsemanage port -l | grep ssh\n\n#删除端口\nsemanage port -d -t ssh_port_t -p tcp 22\n","slug":"远程服务器安装Docker并配置数据库","date":"2022-03-05T03:02:36.000Z","categories_index":"实战","tags_index":"数据库,Docker","author_index":"LIYUNFU"},{"id":"417b0753cea51755f39f949bc1137c41","title":"Webpack5搭建标准开发环境","content":"Webpack安装&amp;使用安装npm install webpack webpack-cli -D\n\n使用方式方式一.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version\n\n方式二npx webpack --version\n\n\n\n入口(entry)\n\n\n\n\n\n\n\n\n**入口起点(entry point)*指示 webpack 应该使用哪个模块，来作为构建其内部依赖图*的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。\n出口(output)\n\n\n\n\n\n\n\n\noutput 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist\nconst config = &#123;\n    entry: './src/index.js',\n    output: &#123;\n        filename: 'bundle.js',\n        path: path.join(__dirname, './dist')\n    &#125;\n&#125;\n\n\nloader\n\n\n\n\n\n\n\n\nloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。\n让webpack处理CSS文件\n\n\n\n\n\n\n\n\nwebpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这种情况下，以 .css 结尾的全部文件，都将被提供给 style-loader 和 css-loader。\n\n下载依赖loader\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\n编写规则，匹配哪些后缀使用哪些loader  webpack.config.js\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.css$/,\n            use:['style-loader','css-loader']\n        &#125;\n    ]\n&#125;\nloader链式传递，先从后面的loader开始\n\n\n让webpack处理scss文件\n下载依赖loader\nnpm install sass-loader node-sass -D\n编写规则\nmodule:&#123;\n    rules:[\n        &#123;\n            test:/\\.(scss|sass)$/,\n            use:['style-loader','css-loader','sass-loader']\n        &#125;\n    ]\n&#125;,\n\nfile-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。\n让webpack处理图片\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test: /\\.(png|jpg|svg|gif)$/,\n    use:['file-loader']\n&#125;\n可以在index.js中引入\nimport Icon from './icon.jpg';\n\n//将图像添加到我们现有的div\nconst myIcon = new Image();\nmyIcon.src = Icon;\nelement.appendChild(myIcon);\n也可在index.scss中引入\n.hello&#123;\n  color: red;\n  background: url(\"./icon.jpg\");\n&#125;\n\n让webpack处理字体\n下载依赖loader\nnpm install file-loader -D\n编写规则\n&#123;\n    test:/\\.(woff|woff2|eot|ttf|otf)$/,\n    use:['file-loader']\n&#125;\n在index.scss中引入\n@font-face &#123;\n  font-family: 'Myfont';\n  src: url(\"./myfont.TTF\") format('ttf');\n  font-weight: 600;\n  font-style: normal;\n&#125;\n.hello&#123;\n  color: red;\n  font-family: Myfont;\n&#125;\n\n让webpack处理CSV、TSV 、XML\n下载依赖loader\nnpm install csv-loader xml-loader -D\n编写规则\n&#123;\n    test:/\\.(csv|tsv)$/,\n    use:['csv-loader']\n&#125;,\n&#123;\n    test:/\\.xml$/,\n    use:['xml-loader']\n&#125;\n在src下创建data.xml并在index.js中引入\n\ndata.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;note>\n    &lt;to>mary&lt;/to>\n    &lt;from>john&lt;/from>\n    &lt;heading>reminder&lt;/heading>\n    &lt;body>call cindy on tuesday&lt;/body>\n&lt;/note>\n\n\nindex.js\n\nimport Data from './data.xml';\n\nconsole.log(Data);\n\n插件(plugins)\n\n\n\n\n\n\n\n\nloader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。\n使用plugins处理html\n下载依赖plugins\nnpm install html-webpack-plugin -D\n由于插件可以携带参数/选项，所以必须在webpack配置中，向plugins属性传入new实例\n\n```js//处理src下的html文件plugins: [\n    new HtmlWebpackPlugin(&#123;template: &quot;./src/index.html&quot;&#125;)\n\n],\n\n## 模式(mode)\n\n&gt; 通过选择 &#96;development&#96; 或 &#96;production&#96; 之中的一个，来设置 &#96;mode&#96; 参数，你可以启用相应模式下的 webpack 内置的优化\n\n&#96;&#96;&#96;jsx\nmodule.exports &#x3D; &#123;\n  mode: &#39;production&#39;\n&#125;;\n\n模块热替换过程在应用程序中置换模块\n应用程序代码要求HMR runtime检查更新\nHMR runtime(异步)下载更新，然后通知应用程序代码\n应用程序代码要求HMR runtime应用更新\nHMR runtime(同步)应用更新\n\n在编译器中除了普通资源，编译器需要发出update，以允许更新之前的版本到新的版本，update由两部分组成：\n\n更新后的manifest(JSON)\n一个或多个更新后的chunk(JavaScript)\n\n配置标准开发环境ni babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;plugin-transform-runtime -D\nni @babel&#x2F;runtime \n\n创建.babelrc&#123;\n  \"presets\": [\n    \"@babel/preset-env\"\n  ],\n  \"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n  ]\n&#125;\n\n在webpack.config.js中rules添加规则&#123;\n    test:/\\.js$/,\n    loader: \"babel-loader\"\n&#125;\n\n\n\n\n\n\n\n\n\n\n第一里程碑\n自动清理dist目录webpack5.x之后在输出中添加clean:true即可\noutput: &#123;\n    filename: &#39;bundle.js&#39;,\n    path: path.join(__dirname, &#39;.&#x2F;dist&#39;),\n    clean: true\n&#125;,\n\n\nCleanWebpackPlugin does not clean in Webpack 5 - fsou (nilmap.com)\n复制资源到dist目录\n引入对应插件\n\nnpm install --save-dev copy-webpack-plugin\n\n\n编写新的plugin语法，旧语法有问题，因为CopyWebpackPlugin构造函数还支持其他选项\n\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nnew CopyWebpackPlugin(\n    &#123;\n        patterns: [\n            &#123;\n                from: path.join(__dirname, 'assets')\n                to: 'assets'\n            &#125;\n        ]\n    &#125;\n)\n\n\n\n\n\n\n\n\n\n\n\n错误信息：[webpack-cli] Invalid options object. Copy Plugin has been initialized using an options object that does not match the API schema.\n对js和css压缩 丑化JS和CSS压缩css和js\n安装依赖\nni css-minimizer-webpack-plugin -D\nni terser-webpack-plugin -D   &#x2F;&#x2F;让他来增强...扩展运算符\nni mini-css-extract-plugin -D  &#x2F;&#x2F;支持头部单独引用不许安装\n引入对应插件 \nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserJSPlugin=require('terser-webpack-plugin')\nrules\n&#123;\n    test: /\\.(scss|sass)$/,\n    use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']\n&#125;,\noptimization\noptimization: &#123;\n    minimize: true,  //设置开发环境可用，若不设置默认false只能支持生产环境\n    minimizer: [\n        `...`,   //使用扩展运算符增强\n        new CssMinimizerPlugin(),\n      \tnew TerserJSPlugin()\n    ]\n&#125;,\nplugins\nnew MiniCssExtractPlugin(&#123;\n    filename: '[name].css',\n    chunkFilename:'[id].css',\n&#125;),\nnew MiniCssExtractPlugin(),\nnew TerserJSPlugin()\n\n","slug":"Webpack5搭建标准开发环境","date":"2022-03-05T03:00:17.000Z","categories_index":"实战","tags_index":"Webpack,前端工程化","author_index":"LIYUNFU"},{"id":"fe45cec90ec11b72673f92c41490ffd7","title":"基于koa-generator实现验证码功能","content":"第一步\n全局安装koa-generator\n\n```shellnpm install -g koa-generator\n\n- 生成基本框架\n\n- &#96;&#96;&#96;shell\n  koa2 apiname    \n  # 使用koa2后面接目录名即可自动创建名为apiname的目录\n根据命令行提示，进入创建的文件夹，执行npm install\n\n```shellcd apinamenpm install\n\n- 下载依赖完成之后，可以启动看看\n\n- &#96;&#96;&#96;shell\n  npm run start\n打开浏览器访问3000端口\n\n```shellhttp://localhost:3000\n\n- 如果浏览器中页面显示出数据即创建成功，可以进入下一步\n\n\n\n### 第二步\n\n- 在根目录下新建&#96;src&#96;目录\n\n- 将&#96;public&#96; 、&#96;routes&#96; 、&#96;views&#96; 、&#96;app.js&#96;拖入&#96;src&#96;目录\n\n- 修改&#96;bin&#x2F;www&#96;中的&#96;var app &#x3D; require(&#39;..&#x2F;app&#39;);&#96;为&#96;var app &#x3D; require(&#39;..&#x2F;src&#x2F;app&#39;);&#96;\n\n- 改造后目录\n\n- &#96;&#96;&#96;shell\n  |- bin\n    |- www\n  |-node_modules\n  |-src\n    |-public\n    |-routes\n    |-views\n    |-app.js\n  |-package.json\n在src目录下创建目录controller\n\n\n第三步\n安装用于聚合router的包\n\n安装koa-combine-routers包\n\n```shellnpm install koa-combine-routers\n\n- 安装&#96;svg-captcha&#96;  包 用于生成&#96;svg&#96;验证码\n\n- &#96;&#96;&#96;shell\n  npm install svg-captcha\n在controller目录下创建publicController.js 用于生成验证码 并输入以下代码\n\n```jsconst svgCaptcha = require(“svg-captcha”);\nfunction  publicController(ctx) {  //创建一个新验证码svg对象  const newCaptcha = svgCaptcha.create({\nsize: 4,  //验证码长度\nignoreChars: &quot;0o1il&quot;, //排除易混淆的几个0o1il字符\ncolor: true,   //验证码有颜色\nnoise: Math.floor(Math.random() * 5), //干扰线\nwidth: 150,  \nheight: 50,\n\n  });  ctx.body = {\nmsg: newCaptcha.data,\n\n  };}\nmodule.exports = publicController;\n\n- 在&#96;routes&#96;目录下新建&#96;publicRouter.js &#96; 输入以下代码\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;koa-router&quot;)();\n  const getCaptcha &#x3D; require(&quot;..&#x2F;controller&#x2F;PublicController&quot;);\n  \n  router.get(&quot;&#x2F;getCaptcha&quot;, getCaptcha);\n  \n  module.exports &#x3D; router;\n在routes目录下新建routes.js 输入以下代码\n\n```jsconst combineRoutes=require(‘koa-combine-routers’)\nconst aRoutes=require(‘./publicRouter’)\nmodule.exports=combineRoutes(  aRoutes   //如果有多个 可以引入多个，并写在此处用逗号隔开)\n\n- 在&#96;app.js&#96;引入&#96;routes.js&#96; 并使用\n\n- &#96;&#96;&#96;js\n  const router &#x3D; require(&quot;.&#x2F;routes&#x2F;routes&quot;);\n  app.use(router())\n实现跨域请求，下载并引入koa2-cors包\n\n```shellnpm install koa2-cors\nconst cors = require(“koa2-cors”);\n//cors配置app.use(  cors({\norigin: &quot;http://localhost:8080&quot;, //前端origin\ncredentials: true, //允许跨域带cookie\n\n  }));\n\n\n\n### 第四步\n\n使用&#96;vue&#96;项目，尝试请求验证码  下载&#96;axios&#96;包\n\n&#96;&#96;&#96;vue\n&lt;template&gt;\n\t&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div class&#x3D;&quot;svg&quot; @click&#x3D;&quot;getCaptcha&quot; v-html&#x3D;&quot;svg&quot;&gt;验证码&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nconst axios &#x3D; require(&#39;axios&#39;)\nexport default &#123;\n  name: &#39;app&#39;,\n  data () &#123;\n    return &#123;\n      svg: &#39;&#39;\n    &#125;\n  &#125;,\n  mounted () &#123;\n    this.getCaptcha()\n  &#125;,\n  methods: &#123;\n    getCaptcha () &#123;\n      axios.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;getCaptcha&#39;).then((res) &#x3D;&gt; &#123;\n        if (res.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          this.svg &#x3D; res.data.msg\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n","slug":"基于koa-generator实现验证码功能","date":"2022-03-05T02:56:54.000Z","categories_index":"实战","tags_index":"Koa","author_index":"LIYUNFU"},{"id":"2dd921bc2e0b67b467ed4b61518bdc3d","title":"MongoDB的CRUD","content":"MongoDB初见\nDocker中MongoDB数据的备份与恢复#备份\ndocker exec -it 镜像名 mongodump -h 地址 -u root -p example -o 备份到的地址\ndocker exec -it some-mongo mongodump -h localhost -u root -p example -o &#x2F;temp&#x2F;test\n\n\n\n是什么\n存储文档的非关系型数据库\n\n\n\n可以将多个不同的内容添加到一个集合里面，如果想要添加字段，直接添加，不会报错\n\nMongoDB的CRUD创建文档创建一个文档\n自己提供文档主键_id值，容易出现错误，可以省略文档_id字段，让它自动生成，collection为集合\n\ndb.collection.insertOne(\n\t&#123;\n\t_id: &quot;account1&quot;,\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\ndb.collection.insertOne(\n\t&#123;\n\tname: &quot;alice&quot;,\n\tbalance: 100\n\t&#125;\n)\n\n创建多个文档\nordered参数用来决定mongoDB是否要按顺序来写入这些文档\nordered:false 表示可以打乱文档写入顺序，以便优化写入的操作\nordered:true(默认值)按顺序执行，如果第一条插入数据错误，那么第二天不会执行\n\n\n\ndb.accounts.insertMany(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t,\n\t&#123;\n\t\tordered:false  &#x2F;&#x2F;可选\n\t&#125;\n)\n\n\n创建单个或多个文档\nsave命令运行时调用insert   db.collection.save \n\ndb.accounts.insert(\n\t&#123;\n\tname: &quot;alice1&quot;,\n\tbalance: 100\n\t&#125;,\n)\n\ndb.accounts.insert(\n\t[\n\t\t&#123;\n\t\tname: &quot;alice1&quot;,\n\t\tbalance: 100\n\t\t&#125;,\n\t\t&#123;\n\t\tname: &quot;alice2&quot;,\n\t\tbalance: 200\n\t\t&#125;\n\t]\t\n)\n\n\n\ninsertOne 、insertMany 、insert的区别\n正确和错误返回的结果不同\n\ninsertOne和insertMany命令不支持db.collection.explain()名\n\ninsert支持db.collection.explain命令\n\n\n读取文档读取全部文档\n既不筛选，也不投射\ndb.accounts.find()\n更清晰的显示文档\ndb.accounts.find().pretty()\n\n匹配查询\n读取alice的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;&#125;)\n读取alice的余额为100元的银行账户文档\ndb.accounts.find(&#123;name: &quot;alice&quot;,balance: 100&#125;)\n读取复合主键的文档\ndb.accounts.find(&#123;&quot;_id.type&quot;: &quot;savings&quot;&#125;)\n\n比较操作符\n\n\n操作符\n含义\n\n\n\n$eq\n相等查询值的文档\n\n\n$ne\n不等查询值的文档\n\n\n$gt\n大于查询值的文档\n\n\n$gte\n大于或等于查询值的文档\n\n\n$lt\n小于查询值的文档\n\n\n$lte\n小于或等于查询值的文档\n\n\n$in\n与任一查询值相等的文档\n\n\n$nin\n与任何查询值都不等的文档\n\n\n\n读取不属于alice的银行账户文档\ndb.accounts.find(&#123;name: &#123;$ne:&quot;alice&quot;&#125;&#125;)\n读取余额大于500的银行账户文档\ndb.accounts.find(&#123;balance: &#123;$gt:500&#125;&#125;)\n读取用户名字排在fred之前的银行账户文档\ndb.accounts.find(&#123;name: &#123;$lt:&quot;fred&quot;&#125;&#125;)\n读取alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$in:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n读取既不是alice和charlie的银行账户文档\ndb.accounts.find(&#123;name: &#123;$nin:[&quot;alice&quot;,&quot;charlie&quot;]&#125;&#125;)\n\n逻辑操作符\n\n\n逻辑操作符\n含义\n\n\n\n$not\n筛选条件不成立的文档\n\n\n$and\n多个条件全部成立的文档\n\n\n$or\n至少一个筛选条件成立的文档\n\n\n$nor\n多个筛选条件全部不成立的文档\n\n\n\n读取余额不小于500的银行账户文档  \ndb.accounts.find(&#123;balance:&#123;$not:&#123;$lt:500&#125;&#125;&#125;)\n读取余额大于100并且用户姓名排在fred之后的银行账户文档\ndb.accounts.find(&#123;$and:[&#123;balance:&#123;$gt:100&#125;&#125;,&#123;name:&#123;$gt:&quot;fred&quot;&#125;&#125;]&#125;)\n读取余额大于100并且小于500的银行账户文档\ndb.accounts.find(&#123;balance:&#123;$lt:500,$gt:100&#125;&#125;&#125;)\n读取属于alice或者charlie的银行账户文档\ndb.accounts.find(&#123;\n\t$or:[\n\t\t&#123;name:&#123;$eq:&quot;alice&quot;&#125;&#125;,\n\t\t&#123;name:&#123;$eq:&quot;charlie&quot;&#125;&#125;\n\t]\n&#125;)\n读取既不属于alice和charlie且余额不小于100的银行账户文档\ndb.accounts.find(&#123;\n\t$nor:[\n\t\t&#123;name:&quot;alice&quot;&#125;,\n\t\t&#123;name:&quot;charlie&quot;&#125;,\n\t\t&#123;balance:&#123;$lt:100&#125;&#125;\n\t]\n&#125;)\n\n字段操作符\n\n\n操作符\n含义\n\n\n\n$exists\n包含查询字段的文档\n\n\n$type\n字段类型符合查询值的文档\n\n\n\n读取包含账户类型字段的银行账户文档\ndb.accounts.find(&#123;&quot;_id.type&quot;:&#123;$exists:true&#125;&#125;)\n读取文档主键是字符串的银行账户文档\ndb.accounts.find(&#123;_id:&#123;$type:&quot;string&quot;&#125;&#125;)\n\n数组操作符\n\n\n操作符\n含义\n\n\n\n$all\n数组字段中包含所有查询值的文档\n\n\n$elemMatch\n数组字段中至少存在一个值满足筛选条件的文档\n\n\n\n读取联系地址位于中国北京的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$all:[&quot;china&quot;,&quot;beijing&quot;]&#125;&#125;)\n读取联系电话范围在100000和200000之间的银行账户文档\ndb.accounts.find(&#123;contact:&#123;$elemMatch:&#123;$gt:&quot;100000&quot;,$lt:&quot;200000&quot;&#125;&#125;&#125;)\n\n正则操作符\n读取用户姓名以c或者j开头的银行账号文档\ndb.accounts.find(&#123;name:&#123;$in:[&#x2F;^c&#x2F;,&#x2F;^j&#x2F;]&#125;&#125;)\n读取用户姓名包含LIE(不区分大小写)的银行账户文档\ndb.accounts.find(&#123;name:&#123;$regex:&#x2F;LIE&#x2F;,$options:&#39;i&#39;&#125;&#125;)\n\n文档游标\n查询语句默认返回的是文档游标，默认只显示前二十条\n\n游标函数var cursor=db.accounts.find()\n\n\ncursor.hasNext() cursor.next()\n\n```jsvar myCursor=db.accounts.find({name:”alice”})while(myCursor.hasNext()){  printjson(myCursor.next())}  //只要还有就把剩余文档打印出来\n\n- &#96;cursor.forEach()&#96;\n\n- &#96;&#96;&#96;js\n  var myCursor&#x3D;db.accounts.find(&#123;name:&quot;alice&quot;&#125;)\n  myCursor.forEach(printjson)   &#x2F;&#x2F;每篇文档被打印\ncursor.limit()\n\ncursor.skip()\n\n```jsdb.accounts.find({name:”alice”}).limit(1)  //只返回第一篇文档db.accounts.find({name:”alice”}).skip(1)   //跳过第一篇 只显示第二篇和第三篇\n\n- &#96;cursor.count()&#96;\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count()   &#x2F;&#x2F;返回3\n  db.accounts.find(&#123;name:&quot;alice&quot;&#125;).limit(1).count(true)  &#x2F;&#x2F;返回1\n  &#x2F;&#x2F;默认不接收limit和skip返回的结果\ncursor.sort()\n\n按照余额从大到小，用户名按字母顺序排序\n\n```jsdb.accounts.find().sort({balance:-1,name:1})\n\n\n\n#### 游标注意事件\n\n- &#96;cursor.skip()&#96;在&#96;cursor.limit()&#96;之前执行\n- &#96;cursor.sort()&#96;在&#96;cursor.skip()&#96;和&#96;cursor.limit()&#96;之前执行\n\n\n\n#### 文档投影\n\n- 只返回银行账户文档中的用户姓名\n\n- &#96;&#96;&#96;js\n  db.accounts.find(&#123;&#125;,&#123;name:1&#125;)\n\n\n只返回银行账户文档中的用户姓名(不包含文档主键)\n\ndb.accounts.find(&#123;&#125;,&#123;name:1,_id:0&#125;)\n\n\n除了文档主键之外，我们不可以在投影文档中混合使用包含和不包含这两种投影操作要么在投影文档中列出所有应该包含的字段，要么列出所有不应该包含的字段\n\n\n更新文档","slug":"MongoDB的CRUD","date":"2022-03-05T02:54:11.000Z","categories_index":"实战","tags_index":"MongoDB,数据库,Mongoose","author_index":"LIYUNFU"},{"id":"b9b69e275d0ea3fd4374ffde1f72e980","title":"JSX如何\"摇身一变\"成为DOM的","content":"JSX代码如何变成DOM抛出问题\n  JSX的本质是什么，它和JS之间到底是什么关系？\n\n  为什么要用JSX？不用会有什么后果？\n\n  JSX背后的功能模块是什么，这个功能模块都做了那些事\n\n\n尝试解答\n  JSX的本质是JS的拓展，但是浏览器不能天然支持JSX，所以需要Babel将它编译为React.createElement()的调用，语法糖返回一个叫React Element的JS对象\n\n\n\n  既然最后编译为React.createElement()的调用，为什么不直接使用React.createElement()呢？\n答：\n  由于实现同样的功能的情况下，JSX代码层次分明，语言简练，而React.createElement()代码繁重\n  JSX语法糖允许前端开发者使用我们最为熟悉的类HTML标签语法来创建虚拟DOM，在降低学习成本的同时，也提升了研发效率和研发体验\n\n\n\n\\\n\n  \n\n\\\ncreateElement解析&#x2F;**\n  React的创建元素方法\n *&#x2F;\n\nfunction createElement(type, config, children) &#123;\n  &#x2F;&#x2F; propName用于储存后面需要用到的元素属性\n  var propName;\n  &#x2F;&#x2F; props用于储存元素属性的键值对集合\n  var props &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; key、ref、self、source均为React元素的属性\n  var key &#x3D; null;\n  var ref &#x3D; null;\n  var self &#x3D; null;\n  var source &#x3D; null;\n\n  &#x2F;&#x2F; config 对象中存储的是元素的属性\n  if (config !&#x3D; null) &#123;\n    &#x2F;&#x2F; 进来之后的第一件事，依次对ref、key、self和source属性赋值\n    if (hasValidRef(config)) &#123;\n      ref &#x3D; config.ref;\n\n      &#123;\n        warnIfStringRefCannotBeAutoConverted(config);\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 此处将key 值字符串化\n    if (hasValidKey(config)) &#123;\n      key &#x3D; &#39;&#39; + config.key;\n    &#125;\n\n    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;\n    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source; &#x2F;&#x2F; Remaining properties are added to a new props object\n\n    &#x2F;&#x2F; 接着就是要把config里面的属性都一个一个挪到props对象里面\n    for (propName in config) &#123;\n      if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;\n        props[propName] &#x3D; config[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; childrenLength 指的是当前元素的子元素的个数，减去的2是type和config两个参数占用的长度\n  var childrenLength &#x3D; arguments.length - 2;\n\n  &#x2F;&#x2F; 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;\n    &#x2F;&#x2F; 直接把这个值赋值给props.children\n    props.children &#x3D; children;\n  &#125; else if (childrenLength &gt; 1) &#123;\n    &#x2F;&#x2F; 处理嵌套多个子元素的情况\n    &#x2F;&#x2F; 声明一个数组，把所有剩余对象参数都遍历传入，最后把数组赋值给props.children对象\n    var childArray &#x3D; Array(childrenLength);\n\n    for (var i &#x3D; 0; i &lt; childrenLength; i++) &#123;\n      childArray[i] &#x3D; arguments[i + 2];\n    &#125;\n\n    &#123;\n      if (Object.freeze) &#123;\n        Object.freeze(childArray);\n      &#125;\n    &#125;\n\n    props.children &#x3D; childArray;\n  &#125; &#x2F;&#x2F; Resolve default props\n\n  &#x2F;&#x2F; 处理defaultProps\n  if (type &amp;&amp; type.defaultProps) &#123;\n    var defaultProps &#x3D; type.defaultProps;\n\n    for (propName in defaultProps) &#123;\n      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;\n        props[propName] &#x3D; defaultProps[propName];\n      &#125;\n    &#125;\n  &#125;\n\n  &#123;\n    if (key || ref) &#123;\n      var displayName &#x3D; typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39; ? type.displayName || type.name || &#39;Unknown&#39; : type;\n\n      if (key) &#123;\n        defineKeyPropWarningGetter(props, displayName);\n      &#125;\n\n      if (ref) &#123;\n        defineRefPropWarningGetter(props, displayName);\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n&#125;\n\n参数说明：\n  type:用于标识节点的类型，它可以是HTML标签字符串，也可以是React组件类型\n\n  config: 以对象形式传入，组件所有的属性都会以键值对的形式存储在config对象中\n\n  children: 以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的”子节点””子元素”\n\n\n例子DOM结构\n&lt;ul className&#x3D;&quot;list&quot; id&#x3D;&quot;lis&quot;&gt;\n  &lt;li key&#x3D;&#123;1&#125;&gt;&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&#123;2&#125;&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact.createElement语法糖\nReact.createElement(&quot;ul&quot;, &#123;\n  &#x2F;&#x2F; 传入属性键值对\n  className: &quot;list&quot;,\n  id: &quot;lis&quot;\n  &#x2F;&#x2F; 从第三个入参开始往后，传入的参数都是children\n&#125;, React.createElement(&quot;li&quot;, &#123;\n  key: 1\n&#125;), React, createElement(&quot;li&quot;, &#123;\n  key: 2\n&#125;))\n\n流程\n 处理key、ref、self、source四个属性值\n\n 遍历config，筛选出可以提进props里的属性\n\n 提取子元素，推入props.children\n\n 格式化defaultProps\n\n 将以上数据作为入参，发起ReactElement调用\n\n\n总结createElement就像是开发者和ReactElement调用之间的一个“转换器”，在开发者出接收相对简单的参数，然年后将这些参数按照ReactElement的预期做一层格式化，最终通过调用ReactElement来实现元素的创建\nReactElement解析var ReactElement &#x3D; function (type, key, ref, self, source, owner, props) &#123;\n  var element &#x3D; &#123;\n    &#x2F;&#x2F; 用来标识该对象是一个ReactElement\n    $$typeof: REACT_ELEMENT_TYPE,\n    &#x2F;&#x2F; 内置属性赋值\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    &#x2F;&#x2F; 记录创建该元素的组件\n    _owner: owner\n  &#125;;\n\n  return element;\n&#125;;\n\nReactElement只做了一件事情，就是组装，把传入的参数按照一定的规范，组装进element对象里，并把它返回给React.createElement，最终React.createElement又把它交回到开发者手中\n\nrender初识function render(element, container, callback) &#123;\n  if (!isValidContainer(container)) &#123;\n    &#123;\n      throw Error( &quot;Target container is not a DOM element.&quot; );\n    &#125;\n  &#125;\n\n  &#123;\n    var isModernRoot &#x3D; isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer &#x3D;&#x3D;&#x3D; undefined;\n\n    if (isModernRoot) &#123;\n      error(&#39;You are calling ReactDOM.render() on a container that was previously &#39; + &#39;passed to ReactDOM.createRoot(). This is not supported. &#39; + &#39;Did you mean to call root.render(element)?&#39;);\n    &#125;\n  &#125;\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n&#125;\n\n参数说明\n  element:需要渲染的元素(ReactElement)\n\n  container:元素挂载的目标容器(一个真实DOM)\n\n  callback: 回调函数，可选参数，可以用来处理渲染结束后的逻辑\n\n\n总结\n","slug":"JSX如何变成DOM","date":"2022-02-27T09:46:50.000Z","categories_index":"React源码","tags_index":"React,源码","author_index":"LIYUNFU"},{"id":"bdee22d1805781f30b666804c7635df8","title":"flex布局","content":"flex容器属性改变主轴方向flex-directionflex-direction: row默认\nflex-direction: row-reverse\nflex-direction: column\nflex-direction: column-reverse\n换行flex-wrapflex-wrap: nowrap默认\nflex-wrap: wrap\nflex-wrap: wrap-reverse\n缩写flex-flow: [flex-direction] [flex-wrap]flex-flow: column wrap\n主轴对齐justify-contentjustify-content: flex-start默认\njustify-content: flex-end\njustify-content: space-around 平均分配  每个方块的margin-left+margin-right+width相等\njustify-content: space-between 两边没有空隙 中间空隙平均分配\njustify-content: space-evenly所有空隙平均分配\n交叉轴整体对齐align-content 必须要有折行属性才能生效  \nalign-content: stretch默认\n如果交叉轴上的宽度未设置则自动拉伸填满交叉轴\n\n\n\n若交叉轴上的宽度已经设置则效果和flex-start一样\n\n\n\n\nalign-content: flex-start\nalign-content: flex-end\nalign-content: center\n其他属性 space-around``space-between``space-evenly和主轴属性类似交叉轴每一行对齐 align-itemsalign-items: stretch默认align-items: flex-start\nalign-items: flex-end\nalign-items: center\nalign-items: baseline 内容以小写x为基线对齐\n内联与块的上下左右居中布局内联上下左右居中\n块级上下左右居中\n不定项居中布局\n均分列布局\n子项分组布局复杂模式 使用div嵌套\n简单方式 margin-right: auto\nflex子项属性扩展比例flex-grow一个子元素时\n默认值为0\n\n比例值大于等于1，沾满剩余所有空间\n\n比例值为0.5，占剩余空间的一半\n\n\n\n\n多个子元素时\n只有一个有flex-grow时\n\n\n\n两个都有flex-grow时\n\n\n\n当多个元素加起来小于1时，还有剩余空间\n\n\n收缩比例flex-shrink\n默认值为1，溢出部分完全收缩，小数按比例收缩\n\n\n默认情况当有两个及以上需要收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，默认情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-2/5*(200+300-400)=160\n\nbox2收缩后所占尺寸：300-3/5*(200+300-400)=240\n\n\n\n不同比例收缩时\nmainwidth: 400\n\nbox1width: 200\n\nbox2width: 300\n\n则，比例情况下收缩后 所占比例按照宽度计算\n\nbox1收缩后所占尺寸：200-4/7*(200+300-400)=142\n\nbox2收缩后所占尺寸：300-3/7*(200+300-400)=257\n\n\n\n指定flex元素在主轴上的初始大小flex-basis\n当主轴方向是水平时，覆盖水平宽度\n\n当主轴方向是垂直时，覆盖垂直高度\n\n可选值：0% auto 200px 100%  0  \n\n\n\nflex-basis: auto默认值\nflex-basis: 0表示占据最小宽度，会竖起来\nflex缩写flex: 1\nflex: 0\nflex: auto\n改变某个子项的排序位置order\norder: 0当前位置保持不变\n\norder: -1向前排\n\norder: 1向后拍\n\n\n\n控制单独某一个元素交叉轴的布局align-self\n等高布局 内容填充两边也等高\n两列或三列布局  两边固定宽度 中间自适应\nSticky Footer布局 内容空页脚在最底部 内容满也在最底部\n溢出项布局\n\n","slug":"flex布局","date":"2022-02-12T13:46:33.000Z","categories_index":"","tags_index":"CSS,布局","author_index":"LIYUNFU"},{"id":"6436dbae418d43dcb9001fac6bd76e96","title":"布局中的尺寸与位置","content":"相对长度单位&emsp;&emsp;相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应。以下列出了常见相对单位。\n\n\n\n单位\n名称\n\n\n\nem\n在font-size中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小\n\n\nex\n字符“x”的高度\n\n\nch\n数字“0”的宽度\n\n\nrem\n根元素的字体大小\n\n\nlh\n元素的line-height\n\n\nvw\n视窗宽度的1%\n\n\nvh\n视窗高度的1%\n\n\nvmin\n视窗较小尺寸的1%\n\n\nvmax\n视图大尺寸的1%\n\n\nmargin-top传递的现象与解决方案现象：为子元素设置margin-top后，会把父元素一块带下来&lt;div class=\"box1\">\n  &lt;div class=\"box2\">&lt;/div>\n&lt;/div>\n\n.box1&#123;\n  width: 200px;\n  height: 200px;\n  background: pink;\n&#125;\n.box2&#123;\n  width: 100px;\n  height: 100px;\n  background: skyblue;\n  margin-top: 30px;\n&#125;\n\n\n解决方案1： 为父元素加边框\n解决方案2：格式化上下文BFC\n解决方案3：使用padding替代margin\n自适应盒模型的特性当子盒子不写宽度的时候，添加padding，margin，border等，向内缩\n\n标准盒模型和怪异盒模型\n标准盒模型content-box：width，height=content\n怪异盒模型border-box：width，height=content+padding+border\n\n常见清除浮动的方案clear属性 清除上下\nBFC 清除父组件塌陷\n空标签.clearfix::after{}.clearfix::after&#123;\n\tcontent:\"\";\n  clear:both;\n  display:block;\n&#125;\n\n浮动特性注意点\n只会影响后面的元素\n\n文本不会被浮动元素覆盖\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n浮动放不下，会自动换行\n\n\n定位相对定位position：ralative\n相对定位的元素是在文档中的正常位置偏移给定的值\n\n不影响其他元素布局\n\n相对于自身进行偏移\n\n\n绝对定位position：absolute\n脱离标准文档流，不占据空间\n\n具备内联盒子特性：宽度由内容决定\n\n具备块级盒子特性：支持所有样式\n\n绝对定位元素相对于最近的非static祖先元素定位，当这样的祖先元素不存在时，则相对于可视区定位\n\n\n固定定位position：fixed粘性定位position：sticky\n粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位\n\n详解display属性display-outside外部值定义自身元素的外部表现，而不影响其内的子元素\n\nblock：表示块级盒子\ninline：表示内联盒子\n\ndisplay-inside内部值定义子元素布局的\n\ntable：带有内部表格布局的块级盒子\n\nflex：带有内部弹性布局的块级盒子\n\ngrid：带有内部网格布局的块级盒子\n\n\nglobal全局值\ninherit：继承父元素的display属性\n\ninitial：不管父元素怎么设定，恢复到浏览器最初时的display属性\n\nunset：unset混合了inherit和initial，如果父元素设值了，就用父元素的设定，如果父元素没有设值，就用浏览器的缺省设定\n\n\n书写模式与逻辑属性writing-mode书写模式\nhorizontal-tb：水平方向自上而下的书写方式\n\nvertical-lr：垂直方向自左而右的书写方式\n\nvertical-rl：垂直方向自右而左的书写方式\n\n\n\nBFC块级格式化上下文概念：\n可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何，都不会影响到外部\n\n触发条件：\nfloat的值不是none\n\nposition的值不是static或relative\n\ndisplay的值是inline-block、table-cel、flex、table-caption或inline-flex\n\noverflow的值不是visible\n\n\nBFC的应用：\n解决margin-top传递问题   在父元素上加\n\n解决纵向margin重叠问题\n\n\n\n\n\n解决浮动高度塌陷  在父元素上加\n\n\n","slug":"布局中的尺寸与位置","date":"2022-02-11T13:28:00.000Z","categories_index":"","tags_index":"css,布局","author_index":"LIYUNFU"},{"id":"72f191bcb7ec59bd5f1454660b2b3dff","title":"西瓜音乐小程序开发第二天","content":"✅ 引入第三方 UI 库 vant✅ 封装 banner 请求✅ 实时获取组件高度解决不同屏幕中的 swiper 样式问题✅ 使用节流函数优化性能\n\n今日完成效果\n\n\n\\\n引入 vantUI 库步骤如下\n 第一步进入微信开发工具，点开详情，勾选使用 npm 模块，并调低基础库，由于当前测试基础库2.22.0无法正常显示 vant 中的van-search标签，遂调低基础库至2.21.2\n\n\n\n 打开终端，初始化package.json并且安装 vant 依赖 npm i @vant/weapp\n\n\n\n\\\n\n 点击工具菜单中的构建 npm，等待构建完成，自动产生miniprogram_npm这就是小程序依赖的包\n\n\n\n\n 最后删除 app.json 中的style:v2防止样式冲突\n\n使用第三方 UI 库\n 在pages/home-music/index.json中导入需要的search组件\n\n&#123;\n  &quot;usingComponents&quot;: &#123;\n    &quot;van-search&quot;: &quot;@vant&#x2F;weapp&#x2F;search&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 在pages/home-music/index.wxml中使用search组件\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n\n这里使搜索框无法输入，绑定了点击方法，使用户点击搜索框跳转到搜索页面，index.js 中实现方法即可，shape属性可以设置为圆角或者方角\n\n&#x2F;**\n  * 事件处理\n  *&#x2F;\n handleSearchClick: function () &#123;\n   wx.navigateTo(&#123;\n     url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n   &#125;);\n &#125;,\n\n\n效果如图\n\n\n\\\n封装 banner 请求新建 service/api_music.jsimport hyRequest from &quot;.&#x2F;index&quot;;\nexport function getBanners() &#123;\n  return hyRequest.get(&quot;&#x2F;banner&quot;, &#123;\n    type: 2,\n  &#125;);\n&#125;\n\n\ntype 的值有四种：0 代表 PC 1 代表 Android 2 代表 Iphone 3 代表 pad\n\n\\\n请求数据并渲染到页面\n 根据官方文档可知，可以通过以下示例获得每次渲染完成的组件的rect\n\n\n\n 新建utils/query-rect.js用以获取组件高度\n\nexport default function (selector) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 获取图片的高度(如何获取组件高度)\n    const query &#x3D; wx.createSelectorQuery();\n    query.select(selector).boundingClientRect();\n    query.exec((res) &#x3D;&gt; &#123;\n      resolve(res);\n    &#125;);\n  &#125;);\n&#125;\n\n\n 在pages/home-music/index.js中定义数据和方法，并调用\n\n&#x2F;&#x2F; pages&#x2F;home-music&#x2F;index.js\nimport &#123; getBanners &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_music&quot;;\nimport queryRect from &quot;..&#x2F;..&#x2F;utils&#x2F;query-rect&quot;;\nimport throttle from &quot;..&#x2F;..&#x2F;utils&#x2F;throttle&quot;;\n\nconst throttleQueryRect &#x3D; throttle(queryRect);\n\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    swiperHeight: 0,\n    banners: &#123;&#125;,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getPageData();\n  &#125;,\n\n  &#x2F;**\n   * 事件处理\n   *&#x2F;\n  handleSearchClick: function () &#123;\n    wx.navigateTo(&#123;\n      url: &quot;&#x2F;pages&#x2F;detail-search&#x2F;index&quot;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 网络请求\n   *&#x2F;\n  getPageData: function () &#123;\n    getBanners().then((res) &#x3D;&gt; &#123;\n      this.setData(&#123; banners: res.banners &#125;);\n    &#125;);\n  &#125;,\n\n  handleSwiperImageLoaded: function () &#123;\n    &#x2F;&#x2F; 获取图片的高度\n    throttleQueryRect(&quot;#swiper-img&quot;).then((res) &#x3D;&gt; &#123;\n      const rect &#x3D; res[0];\n      this.setData(&#123;\n        swiperHeight: rect.height,\n      &#125;);\n    &#125;);\n  &#125;,\n&#125;)\n\n\n 在pages/home-music/index.wxml中调用数据，并绑定image加载完成的方法bindonload\n\n&lt;!--pages&#x2F;home-music&#x2F;index.wxml--&gt;\n&lt;!-- 搜索框 --&gt;\n&lt;van-search disabled  placeholder&#x3D;&quot;搜索您喜欢的歌曲&quot; background&#x3D;&quot;#fafafa&quot; shape&#x3D;&quot;round&quot; bind:click-input&#x3D;&quot;handleSearchClick&quot; &#x2F;&gt;\n\n&lt;!-- 轮播图 --&gt;\n&lt;swiper class&#x3D;&quot;swiper&quot; style&#x3D;&quot;height:&#123;&#123;swiperHeight&#125;&#125;&quot; indicator-dots autoplay circular&gt;\n  &lt;block wx:for&#x3D;&quot;&#123;&#123;banners&#125;&#125;&quot; wx:key&#x3D;&quot;bannerId&quot;&gt;\n    &lt;swiper-item class&#x3D;&quot;swiper-item&quot; &gt;\n      &lt;image id&#x3D;&quot;swiper-img&quot; class&#x3D;&quot;image&quot; mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#123;&#123;item.pic&#125;&#125;&quot;  bindload&#x3D;&quot;handleSwiperImageLoaded&quot; &#x2F;&gt;\n    &lt;&#x2F;swiper-item&gt;\n  &lt;&#x2F;block&gt;\n&lt;&#x2F;swiper&gt;\n\n参数说明:\n\ncircular无限滑动\nmode高度自适应\n\n\n\n\nbindload当image标签加载完成时执行\nindicator-dots显示小圆点\n\n上面用到的节流函数utils/throttle.js\nexport default function throttle(\n  fn,\n  interval &#x3D; 1000,\n  options &#x3D; &#123; leading: true, trailing: false &#125;\n) &#123;\n  &#x2F;&#x2F; 1.记录上一次的开始时间\n  const &#123; leading, trailing, resultCallback &#125; &#x3D; options;\n  let lastTime &#x3D; 0;\n  let timer &#x3D; null;\n\n  &#x2F;&#x2F; 2.事件触发时, 真正执行的函数\n  const _throttle &#x3D; function (...args) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 2.1.获取当前事件触发时的时间\n      const nowTime &#x3D; new Date().getTime();\n      if (!lastTime &amp;&amp; !leading) lastTime &#x3D; nowTime;\n\n      &#x2F;&#x2F; 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数\n      const remainTime &#x3D; interval - (nowTime - lastTime);\n      if (remainTime &lt;&#x3D; 0) &#123;\n        if (timer) &#123;\n          clearTimeout(timer);\n          timer &#x3D; null;\n        &#125;\n\n        &#x2F;&#x2F; 2.3.真正触发函数\n        const result &#x3D; fn.apply(this, args);\n        if (resultCallback) resultCallback(result);\n        resolve(result);\n        &#x2F;&#x2F; 2.4.保留上次触发的时间\n        lastTime &#x3D; nowTime;\n        return;\n      &#125;\n\n      if (trailing &amp;&amp; !timer) &#123;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n          timer &#x3D; null;\n          lastTime &#x3D; !leading ? 0 : new Date().getTime();\n          const result &#x3D; fn.apply(this, args);\n          if (resultCallback) resultCallback(result);\n          resolve(result);\n        &#125;, remainTime);\n      &#125;\n    &#125;);\n  &#125;;\n\n  _throttle.cancel &#x3D; function () &#123;\n    if (timer) clearTimeout(timer);\n    timer &#x3D; null;\n    lastTime &#x3D; 0;\n  &#125;;\n\n  return _throttle;\n&#125;\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第二天","date":"2022-02-10T07:54:45.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"},{"id":"27fc989783c0d00e7c3b706a3747978d","title":"西瓜音乐小程序开发第一天","content":"\n✅ 初始化项目\n✅ 配置 tabbar\n✅ 封装请求函数\n✅ 分层架构二次封装请求函数\n✅ 封装格式化方法 (utils/format.wxs)\n✅ 封装视频列表 item 组件\n✅ 完成视频列表页展示\n今日完成效果如下\n\n\n\\\n初始化项目\n\n\\\n删除无关项目文件\n删除 pages 目录下的 index 和 logs，删除 utils 目录下的 util.js\n初始化 app.js 为\n\n&#x2F;&#x2F; app.js\nApp(&#123;\n\n&#125;)\n\n\n初始化 app.json 为\n\n&#123;\n  &quot;pages&quot;: [\n\n  ],\n  &quot;window&quot;: &#123;\n    &quot;backgroundTextStyle&quot;: &quot;light&quot;,\n    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,\n    &quot;navigationBarTitleText&quot;: &quot;Weixin&quot;,\n    &quot;navigationBarTextStyle&quot;: &quot;black&quot;\n  &#125;,\n  &quot;style&quot;: &quot;v2&quot;,\n  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,\n  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;\n&#125;\n\n\n初始化 app.wxss 为\n\n&#x2F;**app.wxss**&#x2F;\n\n\n目前为止编译器/模拟器会报错\n\n\n\\\n配置 tabbar新建两个页面\n 在 pages 右键创建文件夹home-music和home-video\n 在home-video和home-music上右键新建page为index\n\n\n\n\n 小程序开发工具会自动在目录下创建四个文件，并自动在app.json中添加 url\n \n\n\n\n\n \n\n导入静态资源 assets\n 在文件管理器中打开项目，复制已经准备好的 assets 资源到根目录\n \n\n\\\n在app.json中配置 tabbar&quot;tabBar&quot;: &#123;\n    &quot;list&quot;: [\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-music&#x2F;index&quot;,\n        &quot;text&quot;: &quot;音乐&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;music_active.png&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;home-video&#x2F;index&quot;,\n        &quot;text&quot;: &quot;视频&quot;,\n        &quot;iconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_normal.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;assets&#x2F;images&#x2F;tabbar&#x2F;video_active.png&quot;\n      &#125;\n    ]\n  &#125;,\n\n\n\n效果\n\n\n\\\n封装请求函数由于微信小程序给我们提供的wx.request请求许多参数都可以复用，所以可以封装一个请求函数\n\n 在根目录下新建service文件夹\n 新建service/index.js\n\nconst BASE_URL &#x3D; &quot;http:&#x2F;&#x2F;123.207.32.32:9001&quot;;\nclass HYRequest &#123;\n  request(url, method, params) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      wx.request(&#123;\n        url: BASE_URL + url,\n        method: method,\n        data: params,\n        success: function (res) &#123;\n          resolve(res.data);\n        &#125;,\n        fail: function (err) &#123;\n          reject(err);\n        &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  get(url, params) &#123;\n    return this.request(url, &quot;GET&quot;, params);\n  &#125;\n  post(url, data) &#123;\n    return this.request(url, &quot;POST&quot;, data);\n  &#125;\n&#125;\n\nconst hyRequest &#x3D; new HYRequest();\nexport default hyRequest;\n\n二次封装请求函数某些动作需要反复调用请求函数，但是有不变的参数，没必要每次传递，可以再封装一次\n\n 新建service/api_video.js\n\nimport hyRequest from &#39;.&#x2F;index&#39;\nexport function getTopMV(offset,limit&#x3D;10)&#123;\n  return hyRequest.get(&#39;&#x2F;top&#x2F;mv&#39;,&#123;\n    offset,\n    limit\n  &#125;)\n&#125;\n\n\n 由于我们的 api 后台需要接收两个参数，一个是偏移量，一个是数量，我们默认每次截取十个即可\n\n调用请求获得数据\n 在home-video/index.js中引入 getTopMV 方法\n\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\n\n\n 在home-video/index.js的 data 中定义两个变量\n\ndata: &#123;\n   topMVs: [],   &#x2F;&#x2F;用以保存请求到的数据列表\n   hasMore: true,  &#x2F;&#x2F; 判断还有没有更多数据能够请求\n &#125;,\n\n\n 封装专属于home-video的网络请求方法，用以在不同操作下复用\n\n&#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n\n 当生命周期 onLoad 执行时，调用请求方法\n\n&#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n\n 当下拉刷新时调用请求方法\n\n&#x2F;**\n  * 下拉刷新\n  *&#x2F;\n onPullDownRefresh: function () &#123;\n   this.getTopMVData(0);\n &#125;,\n\n\n 当页面触底时调用请求方法\n\n&#x2F;**\n * 页面上拉触底事件的处理函数\n *&#x2F;\nonReachBottom: function () &#123;\n  this.getTopMVData(this.data.topMVs.length);\n&#125;,\n\n\n home-video/index.js完整代码\n\n&#x2F;&#x2F; pages&#x2F;home-video&#x2F;index.js\nimport &#123; getTopMV &#125; from &quot;..&#x2F;..&#x2F;service&#x2F;api_video&quot;;\nPage(&#123;\n  &#x2F;**\n   * 页面的初始数据\n   *&#x2F;\n  data: &#123;\n    topMVs: [],\n    hasMore: true,\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   * async await\n   *&#x2F;\n  onLoad: function (options) &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 封装网络请求的方法\n   *&#x2F;\n  async getTopMVData(offset) &#123;\n    &#x2F;&#x2F; 判断是否可以请求\n    if (!this.data.hasMore) return;\n\n    &#x2F;&#x2F; 展示加载动画\n    wx.showNavigationBarLoading();\n    &#x2F;&#x2F; 真正请求数据\n    const res &#x3D; await getTopMV(offset);\n\n    let newData &#x3D; this.data.topMVs;\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      newData &#x3D; res.data;\n    &#125; else &#123;\n      newData &#x3D; newData.concat(res.data);\n    &#125;\n    this.setData(&#123;\n      topMVs: newData,\n    &#125;);\n    this.setData(&#123;\n      hasMore: res.hasMore,\n    &#125;);\n\n    &#x2F;&#x2F; 隐藏navigation刷新动画\n    wx.hideNavigationBarLoading();\n    &#x2F;&#x2F; 当请求数据完成 关闭下拉刷新动画\n    if (offset &#x3D;&#x3D;&#x3D; 0) &#123;\n      wx.stopPullDownRefresh();\n    &#125;\n  &#125;,\n\n  &#x2F;**\n   * 封装事件处理的方法\n   *&#x2F;\n  handleVideoItemClick: function (event) &#123;\n    const id &#x3D; event.currentTarget.dataset.item.id;\n\n    &#x2F;&#x2F; 页面跳转\n    wx.navigateTo(&#123;\n      url: &#96;&#x2F;pages&#x2F;detail-video&#x2F;index?id&#x3D;$&#123;id&#125;&#96;,\n    &#125;);\n  &#125;,\n  &#x2F;**\n   * 下拉刷新\n   *&#x2F;\n  onPullDownRefresh: function () &#123;\n    this.getTopMVData(0);\n  &#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面初次渲染完成\n   *&#x2F;\n  onReady: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面显示\n   *&#x2F;\n  onShow: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面隐藏\n   *&#x2F;\n  onHide: function () &#123;&#125;,\n\n  &#x2F;**\n   * 生命周期函数--监听页面卸载\n   *&#x2F;\n  onUnload: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面相关事件处理函数--监听用户下拉动作\n   *&#x2F;\n  onPullDownRefresh: function () &#123;&#125;,\n\n  &#x2F;**\n   * 页面上拉触底事件的处理函数\n   *&#x2F;\n  onReachBottom: function () &#123;\n    this.getTopMVData(this.data.topMVs.length);\n  &#125;,\n\n  &#x2F;**\n   * 用户点击右上角分享\n   *&#x2F;\n  onShareAppMessage: function () &#123;&#125;,\n&#125;);\n\n遍历数据到页面前面我们已经请求到数据了，可以直接在home-video/index.wxml中调用，由于列表的 item 也可以复用，我们将它封装成一个 component\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;!-- &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt; --&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\\\n封装 item 组件\n 在根目录下新建文件夹components/video-item-v1，右键video-item-v1新建component为 index\n \n\n\n\n\n 可以看到component的 index.js 和普通组件不同，其中有一个专门接收父组件传递过来数据的函数\n\n&#x2F;**\n  * 组件的属性列表\n  *&#x2F;\n properties: &#123;\n\n &#125;,\n\n\n 可以在这儿定义接收的数据，就可以直接在 wxml 页面中使用了\n\n&#x2F;**\n   * 组件的属性列表\n   *&#x2F;\n  properties: &#123;\n    item:&#123;\n      type:Object,\n      default:&#123;&#125;\n    &#125;\n  &#125;,\n\n\n 由于服务器返回的数据里面播放量和 时间都需要转换格式，我们可以在 utils 目录下定义一个format.wxs用于格式化数据，wxml 中只能调用 wxs 定义的方法\n\nfunction formatCount(count) &#123;\n  var counter &#x3D; parseInt(count);\n  if (counter &gt; 100000000) &#123;\n    return (counter &#x2F; 100000000).toFixed(1) + &quot;亿&quot;;\n  &#125; else if (counter &gt; 10000) &#123;\n    return (counter &#x2F; 10000).toFixed(1) + &quot;万&quot;;\n  &#125; else &#123;\n    return counter + &quot;&quot;;\n  &#125;\n&#125;\n\nfunction padLeftZero(time) &#123;\n  time &#x3D; time + &quot;&quot;;\n  return (&quot;00&quot; + time).slice(time.length);\n&#125;\nfunction formatDuration(duration) &#123;\n  duration &#x3D; duration &#x2F; 1000;\n\n  var minute &#x3D; Math.floor(duration &#x2F; 60);\n  &#x2F;&#x2F; 计算秒钟\n  var second &#x3D; duration % 60;\n\n  return padLeftZero(minute) + &quot;:&quot; + padLeftZero(second);\n&#125;\n&#x2F;&#x2F; commonjs\nmodule.exports &#x3D; &#123;\n  formatCount: formatCount,\n  formatDuration: formatDuration,\n&#125;;\n\n\n 现在我们可以在 wxml 中使用父组件传递过来的数据了\n\n&lt;!--components&#x2F;video-item-v1&#x2F;index.wxml--&gt;\n&lt;wxs src&#x3D;&quot;..&#x2F;..&#x2F;utils&#x2F;format.wxs&quot; module&#x3D;&quot;format&quot;&gt;&lt;&#x2F;wxs&gt;\n&lt;view class&#x3D;&quot;item&quot;&gt;\n  &lt;view class&#x3D;&quot;album&quot;&gt;\n    &lt;image class&#x3D;&quot;images&quot; src&#x3D;&quot;&#123;&#123;item.cover&#125;&#125;&quot; mode&#x3D;&quot;widthFix&quot; &#x2F;&gt;\n    &lt;view class&#x3D;&quot;info&quot;&gt;\n      &lt;view class&#x3D;&quot;count&quot;&gt;&#123;&#123;format.formatCount(item.playCount)&#125;&#125;&lt;&#x2F;view&gt;\n      &lt;view class&#x3D;&quot;duration&quot;&gt;&#123;&#123;format.formatDuration(item.mv.videos[0].duration)&#125;&#125;&lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class&#x3D;&quot;content&quot;&gt;\n    &#123;&#123;item.name&#125;&#125; - &#123;&#123;item.artisName&#125;&#125;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n\n 为 item 组件配置样式\n\n&#x2F;* components&#x2F;video-item-v1&#x2F;index.wxss *&#x2F;\n.item &#123;\n  width: 100%;\n  margin-bottom: 30rpx;\n&#125;\n\n.album &#123;\n  position: relative;\n  border-radius: 12rpx;\n  overflow: hidden;\n  display: flex;\n&#125;\n\n.album .image &#123;\n  width: 100%;\n&#125;\n\n.info &#123;\n  position: absolute;\n  padding: 0 10rpx;\n  box-sizing: border-box;\n  width: 100%;\n  bottom: 8rpx;\n  display: flex;\n  justify-content: space-between;\n  color: #fff;\n  font-size: 24rpx;\n&#125;\n\n.info .count &#123;\n  padding-left: 36rpx;\n  position: relative;\n&#125;\n\n.info .count::before &#123;\n  content: &quot;&quot;;\n  position: absolute;\n  left: -2rpx;\n  top: 4rpx;\n  width: 30rpx;\n  height: 24rpx;\n  background-size: cover;\n  background-image: url(&quot;data:image&#x2F;jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAYCAQAAABHYIU0AAAM82lDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY0dyYXlHYW1tYTJfMgAAWIWlVwdYU8kWnluS0BJ6lRI60gwoXUqkBpBeBFGJIZBACDEFAbEhiyu4dhHBsqKiKIsdgcWGBQtrB7sLuigo6+IqNixvEopYdt&#x2F;7vnfzzb3&#x2F;nXPOnDpnbgBQ5TAFAh4KAMjki4WBUfSEKQmJVNJdIAe0gTKwB8pMlkhAj4gIhSyAn8Vng2+uV+0AkT6v2UnX+pb+rxchhS1iwedxOHJTRKxMAJCJAJC6WQKhGAB5MzhvOlsskOIgiDUyYqJ8IU4CQE5pSFZ6GQWy+Wwhl0UNFDJzqYHMzEwm1dHekRohzErl8r5j9f97ZfIkI7rhUBJlRIfApz20vzCF6SfFrhDvZzH9o4fwk2xuXBjEPgCgJgLxpCiIgyGeKcmIpUNsC3FNqjAgFmIviG9yJEFSPAEATCuPExMPsSHEwfyZYeEQu0PMYYl8EyG2griSw2ZI8wRjhp3nihkxEEN92DNhVpSU3xoAfGIK289&#x2F;cB5PzcgKkdpgAvFBUXa0&#x2F;7DNeRzfsEFdeHs6MzgCYguIX7J5gVGD6xD0BOII6ZrwneDH54WFDvpFKGWLZP7Cd0K7mBMjzZkjAEQTsTAmatA2YkwqN4ABcQDEORxhUNSgv8SjAp6szmBMiO+FkqjYQR9JAWx+rHRNaV0sYAr9AwdjRWoCcQgTsEEWmAnvLMAHnYAKRIALsmUoDTBBJhxUaIEtHIGQiw+HEHKIQIaMQwi6RujDElIZAaRkgVTIyYNyw7NUkALlB+Wka2TBIX2Trtstm2MN6bOHw9dwO5DANw7ohXQORJNBh2wmB9qXCZ++cFYCaWkQj9YyKB8hs3XQBuqQ9T1DWrJktjBH5D7b5gvpfJAHZ0TDnuHaOA0fD4cHHop74jSZlBBy5AI72fxE2dyw1s+eS33rGdE6C9o62vvR8RqO4QkoJYbvPOghfyg+ImjNeyiTMST9lZ8r9CRWAkHpskjG9KoRK6gFwhlc1qXlff+StW+1232Rt&#x2F;DRdSGrlJRv6gLqIlwlXCbcJ1wHVPj8g9BG6IboDuEu&#x2F;N36blSyRmKQBkfWSAWwv8gNG3LyZFq+tfNzzgbX+WoFBBvhpMtWkVIz4eDKeEQj+ZNALIb3VJm03Ve5C&#x2F;xab0t+kw6gti89fg5Qa1Qazn6Odhten3RNqSU&#x2F;lb9CTyCYXpU&#x2F;wBZ8pkrzwF4c9ioMFNjS9tJ6adtoNbQXtPufOWg3aH&#x2F;S2mhbIOUptho7hB3BGrBGrBVQ4VsjdgJrkKEarAn+9v1Dhad9p8KlFcMaqmgpVTxUU6Nrf3Rk6aOiJeUfjnD6P9Tr6IqRZux&#x2F;s2j0Ol92BPbnXUcxpThQSBRrihOFTkEoxvDnSPGByJRiQgmlaENqEMWS4kcZMxKP4VrnDWWY+8X+HrQ4AVKHK4Ev6y5MyCnlYA75+7WP1C+8lHrGHb2rEDLcVdxRPeF7vYj6xc6KhbJcMFsmL5Ltdr5MTvBF&#x2F;YlkXQjOIFNlOfyObbgh7oAzYAcKB1ScjjvhPkN4sCsN9yVZpnBvSPXC&#x2F;XBXaR&#x2F;7oi+w&#x2F;qv1o3cGm+hOtCT6Ey0&#x2F;04l+xCBiAHw6SOeJ44jBELtJucTsHLH0kPfNEuQKuWkcMZUOv3LYVAafZW9LdaQ5wNNN+s00+CnwIlL2LYRotbIkwuzBOVx6IwAF+D2lAXThqWoKT2s7qNUFeMAz0x+ed+EgBuZ1OvSDA+0Wwsjmg4WgCJSAFWAtKAebwTZQDWrBfnAYNMEeewZcAJdBG7gDz5Mu8BT0gVdgAEEQEkJG1BFdxAgxR2wQR8QV8UL8kVAkCklAkpE0hI9IkHxkEVKCrELKkS1INbIPaUBOIOeQK8gtpBPpQf5G3qEYqoRqoAaoBToOdUXpaAgag05D09BZaB5aiC5Dy9BKtAatQ0+gF9A2tAN9ivZjAFPEtDBjzA5zxXyxcCwRS8WE2DysGCvFKrFa2ANasGtYB9aLvcWJuDpOxe1gFoPwWJyFz8Ln4UvxcnwnXoefwq&#x2F;hnXgf&#x2F;pFAJugTbAjuBAZhCiGNMJtQRCglVBEOEU7DDt1FeEUkErVgflxg3hKI6cQ5xKXEjcQ9xOPEK8SHxH4SiaRLsiF5ksJJTJKYVERaT6ohHSNdJXWR3sgpyhnJOcoFyCXK8eUK5Erldskdlbsq91huQF5F3lzeXT5cPkU+V365&#x2F;Db5RvlL8l3yAwqqCpYKngoxCukKCxXKFGoVTivcVXihqKhoouimGKnIVVygWKa4V&#x2F;GsYqfiWyU1JWslX6UkJYnSMqUdSseVbim9IJPJFmQfciJZTF5GriafJN8nv6GoU+wpDEoKZT6lglJHuUp5piyvbK5MV56unKdcqnxA+ZJyr4q8ioWKrwpTZZ5KhUqDyg2VflV1VQfVcNVM1aWqu1TPqXarkdQs1PzVUtQK1baqnVR7qI6pm6r7qrPUF6lvUz+t3qVB1LDUYGika5Ro&#x2F;KJxUaNPU01zgmacZo5mheYRzQ4tTMtCi6HF01qutV+rXeudtoE2XZutvUS7Vvuq9mudMTo+OmydYp09Om0673Spuv66GbordQ&#x2F;r3tPD9az1IvVm623SO63XO0ZjjMcY1pjiMfvH3NZH9a31o&#x2F;Tn6G&#x2F;Vb9XvNzA0CDQQGKw3OGnQa6hl6GOYbrjG8Khhj5G6kZcR12iN0TGjJ1RNKp3Ko5ZRT1H7jPWNg4wlxluMLxoPmFiaxJoUmOwxuWeqYOpqmmq6xrTZtM&#x2F;MyGyyWb7ZbrPb5vLmruYc83XmLeavLSwt4i0WWxy26LbUsWRY5lnutrxrRbbytpplVWl1fSxxrOvYjLEbx162Rq2drDnWFdaXbFAbZxuuzUabK7YEWzdbvm2l7Q07JTu6XbbdbrtOey37UPsC+8P2z8aZjUsct3Jcy7iPNCcaD55udxzUHIIdChwaHf52tHZkOVY4Xh9PHh8wfv74+vHPJ9hMYE&#x2F;YNOGmk7rTZKfFTs1OH5xdnIXOtc49LmYuyS4bXG64arhGuC51PetGcJvkNt+tye2tu7O72H2&#x2F;+18edh4ZHrs8uidaTmRP3DbxoaeJJ9Nzi2eHF9Ur2etnrw5vY2+md6X3Ax9TnxSfKp&#x2F;H9LH0dHoN&#x2F;dkk2iThpEOTXvu6+871Pe6H+QX6Fftd9Ffzj&#x2F;Uv978fYBKQFrA7oC&#x2F;QKXBO4PEgQlBI0MqgGwwDBotRzegLdgmeG3wqRCkkOqQ85EGodagwtHEyOjl48urJd8PMw&#x2F;hhh8NBOCN8dfi9CMuIWRG&#x2F;RhIjIyIrIh9FOUTlR7VEq0fPiN4V&#x2F;SpmUszymDuxVrGS2OY45bikuOq41&#x2F;F+8aviO6aMmzJ3yoUEvQRuQn0iKTEusSqxf6r&#x2F;1LVTu5KckoqS2qdZTsuZdm663nTe9CMzlGcwZxxIJiTHJ+9Kfs8MZ1Yy+2cyZm6Y2cfyZa1jPU3xSVmT0sP2ZK9iP071TF2V2p3mmbY6rYfjzSnl9HJ9ueXc5+lB6ZvTX2eEZ+zI+MSL5+3JlMtMzmzgq&#x2F;Ez+KeyDLNysq4IbARFgo5Z7rPWzuoThgirRIhomqherAH&#x2F;YLZKrCQ&#x2F;SDqzvbIrst&#x2F;Mjpt9IEc1h5&#x2F;TmmuduyT3cV5A3vY5+BzWnOZ84&#x2F;yF+Z1z6XO3zEPmzZzXPN90fuH8rgWBC3YuVFiYsfC3AlrBqoKXi+IXNRYaFC4ofPhD4A+7iyhFwqIbiz0Wb&#x2F;4R&#x2F;5H748Ul45esX&#x2F;KxOKX4fAmtpLTk&#x2F;VLW0vM&#x2F;OfxU9tOnZanLLi53Xr5pBXEFf0X7Su+VO1eprspb9XD15NV1a6hrite8XDtj7bnSCaWb1ymsk6zrKAstq19vtn7F+vflnPK2ikkVezbob1iy4fXGlI1XN&#x2F;lsqt1ssLlk87ufuT&#x2F;f3BK4pa7SorJ0K3Fr9tZH2+K2tWx33V5dpVdVUvVhB39Hx86onaeqXaqrd+nvWr4b3S3Z3VOTVHP5F79f6mvtarfs0dpTshfslex9si95X&#x2F;v+kP3NB1wP1B40P7jhkPqh4jqkLreu7zDncEd9Qv2VhuCG5kaPxkO&#x2F;2v+6o8m4qeKI5pHlRxWOFh79dCzvWP9xwfHeE2knHjbPaL5zcsrJ66ciT108HXL67JmAMydb6C3HznqebTrnfq7hvOv5wxecL9S1OrUe+s3pt0MXnS&#x2F;WXXK5VH&#x2F;Z7XLjlYlXjl71vnrimt+1M9cZ1y+0hbVdaY9tv3kj6UbHzZSb3bd4t57fzr49cGcB&#x2F;Igvvqdyr&#x2F;S+&#x2F;v3K38f+vqfDueNIp19n64PoB3cesh4+&#x2F;UP0x&#x2F;uuwkfkR6WPjR5Xdzt2N&#x2F;UE9Fx+MvVJ11PB04Heoj9V&#x2F;9zwzOrZwb98&#x2F;mrtm9LX9Vz4&#x2F;NPfS1&#x2F;ovtjxcsLL5v6I&#x2F;vuvMl8NvC5+o&#x2F;tm51vXty3v4t89Hpj9nvS+7MPYD40fQz7e&#x2F;ZT56dN&#x2F;AC1d8BzqtvWAAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAAeoAMABAAAAAEAAAAYAAAAAGbJ4J8AAAElSURBVDgRnZQxTsNAEEX&#x2F;WFGUC6RDEEGFREkPihEVokoVDkDFAWgISsUZuAIFQjQUFE5Ni1NEhEjQxQegy2fsFPHKu&#x2F;Zutpr5&#x2F;u&#x2F;vFOsBwDNOVhkDjroTxlA0DqBMayxMcMJfGeEH1CyfI9jlWHYwAZcaN&#x2F;Rhyh5eKbWM0FXxu&#x2F;zBq56rqxsVVt+BN7kFsYY3YlDlgPnIJx40JTlgHGOAT96zUxfggnOmgxFSXrjxOjin9vHKF&#x2F;bsAU1wTl1iynMb7gPrG8ZqW&#x2F;gZh&#x2F;Jug1s2saR94UbeSr1R1o39hzscuVHAdfMHZriVhXFRpXHAcl1xWoS6sS12U1rDYooeXUFEyNTa+AtU4nIiayHFKR&#x2F;YDlpDexgrnIJ9c6sFdH0N0P2ZbLd6&#x2F;wF85hyuQTMxjwAAAABJRU5ErkJggg&#x3D;&#x3D;&quot;);\n&#125;\n\n.content &#123;\n  margin-top: 10rpx;\n  font-size: 28rpx;\n\n  &#x2F;* 显示两行 *&#x2F;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  display: -moz-box;\n  -moz-line-clamp: 2;\n  -moz-box-orient: vertical;\n  word-wrap: break-word;\n  word-break: break-all;\n  white-space: normal;\n  overflow: hidden;\n&#125;\n\n父组件引入子组件\n 在home-video/index.json中引入子组件\n\n&#123;\n  &quot;enablePullDownRefresh&quot;: true,\n  &quot;backgroundTextStyle&quot;: &quot;dark&quot;,\n  &quot;usingComponents&quot;: &#123;\n    &quot;video-item-v1&quot;: &quot;&#x2F;components&#x2F;video-item-v1&#x2F;index&quot;\n  &#125;\n&#125;\n\n\n 改写home-video/index.wxml使用组件\n\n&lt;!--pages&#x2F;home-video&#x2F;index.wxml--&gt;\n&lt;view class&#x3D;&quot;video&quot;&gt;\n  &lt;view class&#x3D;&quot;item&quot; wx:for&#x3D;&quot;&#123;&#123;topMVs&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;\n     &lt;video-item-v1 item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;\n      bindtap&#x3D;&quot;handleVideoItemClick&quot;\n      data-item&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;video-item-v1&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n\n父组件传值就是通过data-item传递的\n\n\\\n\n 最后我们还需要修改home-video/index.wxss\n\n&#x2F;* pages&#x2F;home-video&#x2F;index.wxss *&#x2F;\n.video &#123;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n&#125;\n\n.item &#123;\n  width: 48%;\n&#125;\n\n\n\\\n其他：\n项目地址: https://gitee.com/LUNIONT/xhumusic\n\n","slug":"西瓜音乐小程序开发第一天","date":"2022-02-10T07:50:55.000Z","categories_index":"","tags_index":"实战,小程序","author_index":"LIYUNFU"}]